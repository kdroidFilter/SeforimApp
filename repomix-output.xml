This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
composeApp/
  desktopAppIcons/
    MacosIcon.icns
  src/
    androidMain/
      kotlin/
        io/
          github/
            kdroidfilter/
              seforimapp/
                theme/
                  Theme.android.kt
                App.android.kt
      res/
        mipmap-anydpi-v26/
          ic_launcher.xml
      AndroidManifest.xml
    commonMain/
      composeResources/
        values/
          strings.xml
      kotlin/
        io/
          github/
            kdroidfilter/
              seforimapp/
                theme/
                  Color.kt
                  Theme.kt
                App.kt
    jvmMain/
      kotlin/
        io/
          github/
            kdroidfilter/
              seforimapp/
                core/
                  presentation/
                    utils/
                      WindowUtils.kt
                framework/
                  di/
                    desktopModule.kt
                theme/
                  Theme.jvm.kt
        main.kt
  build.gradle.kts
gradle/
  wrapper/
    gradle-wrapper.properties
  libs.versions.toml
jewel/
  src/
    jvmMain/
      java/
        com/
          jetbrains/
            DesktopActions.java
            JBR.java
            RoundedCornersManager.java
            WindowDecorations.java
            WindowMove.java
      kotlin/
        org/
          jetbrains/
            jewel/
              window/
                styling/
                  DecoratedWindowStyling.kt
                  TitleBarStyling.kt
                utils/
                  macos/
                    Foundation.kt
                    FoundationLibrary.kt
                    ID.kt
                    MacUtil.kt
                  DesktopPlatform.kt
                  JnaLoader.kt
                  UnsafeAccessing.kt
                  WindowControlArea.kt
                DecoratedWindow.kt
                Theme.kt
                TitleBar.kt
                TitleBar.Linux.kt
                TitleBar.MacOS.kt
                TitleBar.Windows.kt
  build.gradle.kts
lib/
  core/
    src/
      commonMain/
        kotlin/
          io/
            github/
              kdroidfilter/
                seforimlibrary/
                  core/
                    extensions/
                      LineExtensions.kt
                    models/
                      Author.kt
                      Book.kt
                      Category.kt
                      Line.kt
                      LineTocMapping.kt
                      Link.kt
                      Metadata.kt
                      PubDate.kt
                      PubPlace.kt
                      SearchResult.kt
                      TocEntry.kt
                      TocText.kt
                      Topic.kt
    build.gradle.kts
  dao/
    src/
      commonMain/
        kotlin/
          io/
            github/
              kdroidfilter/
                seforimlibrary/
                  dao/
                    extensions/
                      ModelExtensions.kt
                    repository/
                      SeforimRepository.kt
        sqldelight/
          io/
            github/
              kdroidfilter/
                seforimlibrary/
                  db/
                    AuthorQueries.sq
                    BookHasLinksQueries.sq
                    BookQueries.sq
                    CategoryQueries.sq
                    ConnectionTypeQueries.sq
                    Database.sq
                    LineQueries.sq
                    LinkQueries.sq
                    PubDateQueries.sq
                    PubPlaceQueries.sq
                    SearchQueries.sq
                    TocQueries.sq
                    TocTextQueries.sq
                    TopicQueries.sq
    build.gradle.kts
  generator/
    src/
      commonMain/
        kotlin/
          io/
            github/
              kdroidfilter/
                seforimlibrary/
                  generator/
                    Generator.kt
                    HebrewTextUtils.kt
                    Main.kt
    build.gradle.kts
  gradle/
    wrapper/
      gradle-wrapper.properties
    libs.versions.toml
  sample/
    composeApp/
      src/
        androidMain/
          kotlin/
            sample/
              app/
                DatabaseUtils.kt
                main.kt
          AndroidManifest.xml
        commonMain/
          kotlin/
            sample/
              app/
                App.kt
                BookContentView.kt
                BookPopup.kt
                CategoryBookTree.kt
                LineCommentsView.kt
                LineWithUniqueKey.kt
                SearchPopup.kt
                Theme.kt
                Type.kt
        jvmMain/
          kotlin/
            sample/
              app/
                DatabaseUtils.kt
                main.kt
      build.gradle.kts
  .git
  .gitignore
  build.gradle.kts
  gradle.properties
  gradlew
  gradlew.bat
  README.MD
  settings.gradle.kts
.gitignore
.gitmodules
build.gradle.kts
gradle.properties
gradlew
gradlew.bat
README.MD
settings.gradle.kts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="lib/core/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/core/extensions/LineExtensions.kt">
package io.github.kdroidfilter.seforimlibrary.core.extensions

import io.github.kdroidfilter.seforimlibrary.core.models.Line
import io.github.kdroidfilter.seforimlibrary.core.models.LineTocMapping

/**
 * Extensions to facilitate the transition to the new structure without tocEntryId
 */

/**
 * Retrieves the first TOC entry associated with this line
 * (to be used with a list of LineTocMapping)
 *
 * @param mappings The list of line-to-TOC mappings to search in
 * @return The ID of the first TOC entry associated with this line, or null if none found
 */
fun Line.findTocEntryId(mappings: List<LineTocMapping>): Long? {
    return mappings.firstOrNull { it.lineId == this.id }?.tocEntryId
}

/**
 * Checks if this line has an associated TOC entry
 *
 * @param mappings The list of line-to-TOC mappings to search in
 * @return True if this line has an associated TOC entry, false otherwise
 */
fun Line.hasTocEntry(mappings: List<LineTocMapping>): Boolean {
    return mappings.any { it.lineId == this.id }
}
</file>

<file path="lib/core/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/core/models/Author.kt">
package io.github.kdroidfilter.seforimlibrary.core.models

import kotlinx.serialization.Serializable

/**
 * Represents a book author in the library
 *
 * @property id The unique identifier of the author
 * @property name The name of the author
 */
@Serializable
data class Author(
    val id: Long = 0,
    val name: String
)
</file>

<file path="lib/core/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/core/models/Book.kt">
package io.github.kdroidfilter.seforimlibrary.core.models

import kotlinx.serialization.Serializable

/**
 * Represents a book in the library
 *
 * @property id The unique identifier of the book
 * @property categoryId The identifier of the category this book belongs to
 * @property title The title of the book
 * @property authors The list of authors of this book
 * @property topics The list of topics associated with this book
 * @property pubPlaces The list of publication places for this book
 * @property pubDates The list of publication dates for this book
 * @property heShortDesc A short description of the book in Hebrew
 * @property order The display order of the book within its category
 * @property totalLines The total number of lines in the book
 */
@Serializable
data class Book(
    val id: Long = 0,
    val categoryId: Long,
    val title: String,
    val authors: List<Author> = emptyList(),
    val topics: List<Topic> = emptyList(),
    val pubPlaces: List<PubPlace> = emptyList(),
    val pubDates: List<PubDate> = emptyList(),
    val heShortDesc: String? = null,
    val order: Float = 999f,
    val totalLines: Int = 0
)
</file>

<file path="lib/core/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/core/models/Category.kt">
package io.github.kdroidfilter.seforimlibrary.core.models

import kotlinx.serialization.Serializable

/**
 * Represents a category in the library hierarchy
 *
 * @property id The unique identifier of the category
 * @property parentId The identifier of the parent category, or null if this is a root category
 * @property title The title of the category
 * @property level The level of the category in the hierarchy (0 for root categories)
 */
@Serializable
data class Category(
    val id: Long = 0,
    val parentId: Long? = null,
    val title: String,
    val level: Int = 0
)
</file>

<file path="lib/core/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/core/models/Line.kt">
package io.github.kdroidfilter.seforimlibrary.core.models

import kotlinx.serialization.Serializable

/**
 * Represents an individual line of a book
 *
 * @property id The unique identifier of the line
 * @property bookId The identifier of the book this line belongs to
 * @property lineIndex The index of the line within the book
 * @property content The original HTML content of the line
 * @property plainText The cleaned text for search purposes
 */
@Serializable
data class Line(
    val id: Long = 0,
    val bookId: Long,
    val lineIndex: Int,
    val content: String,
    val plainText: String
)
</file>

<file path="lib/core/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/core/models/LineTocMapping.kt">
package io.github.kdroidfilter.seforimlibrary.core.models

import kotlinx.serialization.Serializable

/**
 * Mapping between lines and table of contents entries
 *
 * @property lineId The identifier of the line
 * @property tocEntryId The identifier of the table of contents entry
 */
@Serializable
data class LineTocMapping(
    val lineId: Long,
    val tocEntryId: Long
)
</file>

<file path="lib/core/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/core/models/Link.kt">
package io.github.kdroidfilter.seforimlibrary.core.models

import kotlinx.serialization.Serializable

/**
 * Link between two texts (commentary, reference, etc.)
 *
 * @property id The unique identifier of the link
 * @property sourceBookId The identifier of the source book
 * @property targetBookId The identifier of the target book
 * @property sourceLineId The identifier of the source line
 * @property targetLineId The identifier of the target line
 * @property connectionType The type of connection between the texts
 */
@Serializable
data class Link(
    val id: Long = 0,
    val sourceBookId: Long,
    val targetBookId: Long,
    val sourceLineId: Long,
    val targetLineId: Long,
    val connectionType: ConnectionType
)

/**
 * Types of connections between texts
 *
 * @property COMMENTARY A commentary on the source text
 * @property TARGUM A translation of the source text
 * @property REFERENCE A reference to the source text
 * @property OTHER Any other type of connection
 */
@Serializable
enum class ConnectionType {
    COMMENTARY, TARGUM, REFERENCE, OTHER;

    companion object {
        /**
         * Creates a ConnectionType from a string value
         *
         * @param value The string representation of the connection type
         * @return The corresponding ConnectionType, or OTHER if not recognized
         */
        fun fromString(value: String): ConnectionType = when (value.lowercase()) {
            "commentary" -> COMMENTARY
            "targum" -> TARGUM
            "reference" -> REFERENCE
            else -> OTHER
        }
    }
}
</file>

<file path="lib/core/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/core/models/Metadata.kt">
package io.github.kdroidfilter.seforimlibrary.core.models

import kotlinx.serialization.Serializable

/**
 * Book metadata from the JSON file
 *
 * @property title The title of the book
 * @property description The full description of the book
 * @property shortDescription A short description of the book
 * @property author The author of the book
 * @property extraTitles Alternative titles for the book
 * @property heShortDesc A short description in Hebrew
 * @property pubDate The publication date of the book
 * @property pubPlace The publication place of the book
 * @property order The display order of the book within its category
 */
@Serializable
data class BookMetadata(
    val title: String,
    val description: String? = null,
    val shortDescription: String? = null,
    val author: String? = null,
    val extraTitles: List<String>? = null,
    val heShortDesc: String? = null,
    val pubDate: String? = null,
    val pubPlace: String? = null,
    val order: Float? = null
)
</file>

<file path="lib/core/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/core/models/PubDate.kt">
package io.github.kdroidfilter.seforimlibrary.core.models

import kotlinx.serialization.Serializable

/**
 * Represents a publication date
 *
 * @property id The unique identifier of the publication date
 * @property date The publication date as a string
 */
@Serializable
data class PubDate(
    val id: Long = 0,
    val date: String
)
</file>

<file path="lib/core/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/core/models/PubPlace.kt">
package io.github.kdroidfilter.seforimlibrary.core.models

import kotlinx.serialization.Serializable

/**
 * Represents a publication place
 *
 * @property id The unique identifier of the publication place
 * @property name The name of the publication place
 */
@Serializable
data class PubPlace(
    val id: Long = 0,
    val name: String
)
</file>

<file path="lib/core/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/core/models/SearchResult.kt">
package io.github.kdroidfilter.seforimlibrary.core.models

import kotlinx.serialization.Serializable

/**
 * Search result
 *
 * @property bookId The identifier of the book containing the result
 * @property bookTitle The title of the book containing the result
 * @property lineId The identifier of the line containing the result
 * @property lineIndex The index of the line containing the result
 * @property snippet The text excerpt with highlighting
 * @property rank The relevance score of the result
 */
@Serializable
data class SearchResult(
    val bookId: Long,
    val bookTitle: String,
    val lineId: Long,
    val lineIndex: Int,
    val snippet: String,
    val rank: Double
)
</file>

<file path="lib/core/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/core/models/TocEntry.kt">
package io.github.kdroidfilter.seforimlibrary.core.models

import kotlinx.serialization.Serializable

/**
 * Table of contents entry
 *
 * @property id The unique identifier of the TOC entry
 * @property bookId The identifier of the book this TOC entry belongs to
 * @property parentId The identifier of the parent TOC entry, or null if this is a root entry
 * @property textId The identifier of the associated text in the tocText table
 * @property text The text of the TOC entry (for compatibility with existing code)
 * @property level The level of the TOC entry in the hierarchy
 * @property lineId The identifier of the associated line, or null if not linked to a specific line
 */
@Serializable
data class TocEntry(
    val id: Long = 0,
    val bookId: Long,
    val parentId: Long? = null,
    val textId: Long? = null,
    val text: String = "",
    val level: Int,
    val lineId: Long? = null
)
</file>

<file path="lib/core/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/core/models/TocText.kt">
package io.github.kdroidfilter.seforimlibrary.core.models

import kotlinx.serialization.Serializable

/**
 * Represents a text used in table of contents entries
 *
 * @property id The unique identifier of the TOC text
 * @property text The content of the TOC text
 */
@Serializable
data class TocText(
    val id: Long = 0,
    val text: String
)
</file>

<file path="lib/core/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/core/models/Topic.kt">
package io.github.kdroidfilter.seforimlibrary.core.models

import kotlinx.serialization.Serializable

/**
 * Represents a topic (keyword) associated with books in the library
 *
 * @property id The unique identifier of the topic
 * @property name The name of the topic
 */
@Serializable
data class Topic(
    val id: Long = 0,
    val name: String
)
</file>

<file path="lib/core/build.gradle.kts">
import com.vanniktech.maven.publish.SonatypeHost

plugins {
    alias(libs.plugins.multiplatform)
    alias(libs.plugins.android.library)
    alias(libs.plugins.maven.publish)
    alias(libs.plugins.kotlinx.serialization)
}

kotlin {
    jvmToolchain(17)

    androidTarget { publishLibraryVariants("release") }
    jvm()

    sourceSets {
        commonMain.dependencies {
            implementation(libs.kotlinx.serialization.json)
        }

        commonTest.dependencies {
            implementation(kotlin("test"))
        }

        androidMain.dependencies {

        }

        jvmMain.dependencies {

        }

    }

}

android {
    namespace = "io.github.kdroidfilter.seforimlibrary"
    compileSdk = 35

    defaultConfig {
        minSdk = 21
    }
}

//Publishing your Kotlin Multiplatform library to Maven Central
//https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-publish-libraries.html
mavenPublishing {
    publishToMavenCentral(SonatypeHost.CENTRAL_PORTAL)
    coordinates("io.github.kdroidfilter.seforimlibrary", "core", "1.0.0")

    pom {
        name = "SeforimLibrary"
        description = "Kotlin Multiplatform library"
        url = "github url" //todo

        licenses {
            license {
                name = "MIT"
                url = "https://opensource.org/licenses/MIT"
            }
        }

        developers {
            developer {
                id = "" //todo
                name = "" //todo
                email = "" //todo
            }
        }

        scm {
            url = "github url" //todo
        }
    }
    if (project.hasProperty("signing.keyId")) signAllPublications()
}
</file>

<file path="lib/dao/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/dao/extensions/ModelExtensions.kt">
package io.github.kdroidfilter.seforimlibrary.dao.extensions

import io.github.kdroidfilter.seforimlibrary.core.models.Author
import io.github.kdroidfilter.seforimlibrary.core.models.Book
import io.github.kdroidfilter.seforimlibrary.core.models.Category
import io.github.kdroidfilter.seforimlibrary.core.models.ConnectionType
import io.github.kdroidfilter.seforimlibrary.core.models.Line
import io.github.kdroidfilter.seforimlibrary.core.models.Link
import io.github.kdroidfilter.seforimlibrary.core.models.PubDate
import io.github.kdroidfilter.seforimlibrary.core.models.PubPlace
import io.github.kdroidfilter.seforimlibrary.core.models.SearchResult
import io.github.kdroidfilter.seforimlibrary.core.models.TocEntry
import io.github.kdroidfilter.seforimlibrary.core.models.Topic
import io.github.kdroidfilter.seforimlibrary.db.SearchAll
import io.github.kdroidfilter.seforimlibrary.db.SearchByAuthor
import io.github.kdroidfilter.seforimlibrary.db.SearchInBook
import io.github.kdroidfilter.seforimlibrary.db.SearchWithBookFilter
import kotlinx.serialization.json.Json
import kotlinx.serialization.decodeFromString
import co.touchlab.kermit.Logger

/**
 * This file contains extension functions to convert database entities to domain models.
 * These functions facilitate the mapping between the database layer and the domain layer.
 */

private val logger = Logger.withTag("ModelExtensions")

/**
 * Converts a database Author entity to a domain Author model.
 *
 * @return The domain Author model
 */
fun io.github.kdroidfilter.seforimlibrary.db.Author.toModel(): Author {
    return Author(
        id = id,
        name = name
    )
}

/**
 * Converts a database Pub_place entity to a domain PubPlace model.
 *
 * @return The domain PubPlace model
 */
fun io.github.kdroidfilter.seforimlibrary.db.Pub_place.toModel(): PubPlace {
    return PubPlace(
        id = id,
        name = name
    )
}

/**
 * Converts a database Pub_date entity to a domain PubDate model.
 *
 * @return The domain PubDate model
 */
fun io.github.kdroidfilter.seforimlibrary.db.Pub_date.toModel(): PubDate {
    return PubDate(
        id = id,
        date = date
    )
}

/**
 * Converts a database Book entity to a domain Book model.
 *
 * @param json The JSON parser for deserialization
 * @param authors The list of authors associated with the book
 * @param pubPlaces The list of publication places associated with the book
 * @param pubDates The list of publication dates associated with the book
 * @return The domain Book model
 */
fun io.github.kdroidfilter.seforimlibrary.db.Book.toModel(json: Json, authors: List<Author> = emptyList(), pubPlaces: List<PubPlace> = emptyList(), pubDates: List<PubDate> = emptyList()): Book {
    return Book(
        id = id,
        categoryId = categoryId,
        title = title,
        authors = authors,
        topics = emptyList(),
        pubPlaces = pubPlaces,
        pubDates = pubDates,
        heShortDesc = heShortDesc,
        order = orderIndex.toFloat(),
        totalLines = totalLines.toInt()
    )
}

/**
 * Converts a database Category entity to a domain Category model.
 *
 * @return The domain Category model
 */
fun io.github.kdroidfilter.seforimlibrary.db.Category.toModel(): Category {
    return Category(
        id = id,
        parentId = parentId,
        title = title,
        level = level.toInt()
    )
}

/**
 * Converts a database Line entity to a domain Line model.
 *
 * @return The domain Line model
 */
fun io.github.kdroidfilter.seforimlibrary.db.Line.toModel(): Line {
    logger.d{"Converting database Line to model with id: $id, bookId: $bookId, tocEntryId: $tocEntryId"}
    return Line(
        id = id,
        bookId = bookId,
        lineIndex = lineIndex.toInt(),
        content = content,
        plainText = plainText
    )
}

/**
 * Converts a database SelectTocById result to a domain TocEntry model.
 * This is used when retrieving a TOC entry by its ID.
 *
 * @return The domain TocEntry model
 */
fun io.github.kdroidfilter.seforimlibrary.db.SelectTocById.toModel(): TocEntry {
    logger.d{"Converting database TocEntry (from SelectTocById) with id: $id, bookId: $bookId, lineId: $lineId"}
    return TocEntry(
        id = id,
        bookId = bookId,
        parentId = parentId,
        textId = textId,
        text = text,
        level = level.toInt(),
        lineId = lineId
    )
}

/**
 * Converts a database SelectByBookId result to a domain TocEntry model.
 * This is used when retrieving TOC entries by book ID.
 *
 * @return The domain TocEntry model
 */
fun io.github.kdroidfilter.seforimlibrary.db.SelectByBookId.toModel(): TocEntry {
    logger.d{"Converting database TocEntry (from SelectByBookId) with id: $id, bookId: $bookId, lineId: $lineId"}
    return TocEntry(
        id = id,
        bookId = bookId,
        parentId = parentId,
        textId = textId,
        text = text,
        level = level.toInt(),
        lineId = lineId
    )
}

/**
 * Converts a database SelectRootByBookId result to a domain TocEntry model.
 * This is used when retrieving root TOC entries for a book.
 *
 * @return The domain TocEntry model
 */
fun io.github.kdroidfilter.seforimlibrary.db.SelectRootByBookId.toModel(): TocEntry {
    logger.d{"Converting database TocEntry (from SelectRootByBookId) with id: $id, bookId: $bookId, lineId: $lineId"}
    return TocEntry(
        id = id,
        bookId = bookId,
        parentId = parentId,
        textId = textId,
        text = text,
        level = level.toInt(),
        lineId = lineId
    )
}

/**
 * Converts a database SelectChildren result to a domain TocEntry model.
 * This is used when retrieving child TOC entries for a parent TOC entry.
 *
 * @return The domain TocEntry model
 */
fun io.github.kdroidfilter.seforimlibrary.db.SelectChildren.toModel(): TocEntry {
    logger.d{"Converting database TocEntry (from SelectChildren) with id: $id, bookId: $bookId, lineId: $lineId"}
    return TocEntry(
        id = id,
        bookId = bookId,
        parentId = parentId,
        textId = textId,
        text = text,
        level = level.toInt(),
        lineId = lineId
    )
}

/**
 * Converts a database Connection_type entity to a domain ConnectionType enum.
 *
 * @return The domain ConnectionType enum
 */
fun io.github.kdroidfilter.seforimlibrary.db.Connection_type.toModel(): ConnectionType {
    return ConnectionType.fromString(name)
}

/**
 * Converts a database SelectLinkById result to a domain Link model.
 *
 * @return The domain Link model
 */
fun io.github.kdroidfilter.seforimlibrary.db.SelectLinkById.toModel(): Link {
    return Link(
        id = id,
        sourceBookId = sourceBookId,
        targetBookId = targetBookId,
        sourceLineId = sourceLineId,
        targetLineId = targetLineId,
        connectionType = ConnectionType.fromString(connectionType)
    )
}

/**
 * Converts a database SelectLinksBySourceLineIds result to a domain Link model.
 *
 * @return The domain Link model
 */
fun io.github.kdroidfilter.seforimlibrary.db.SelectLinksBySourceLineIds.toModel(): Link {
    return Link(
        id = id,
        sourceBookId = sourceBookId,
        targetBookId = targetBookId,
        sourceLineId = sourceLineId,
        targetLineId = targetLineId,
        connectionType = ConnectionType.fromString(connectionType)
    )
}

/**
 * Converts a database SelectLinksBySourceBook result to a domain Link model.
 *
 * @return The domain Link model
 */
fun io.github.kdroidfilter.seforimlibrary.db.SelectLinksBySourceBook.toModel(): Link {
    return Link(
        id = id,
        sourceBookId = sourceBookId,
        targetBookId = targetBookId,
        sourceLineId = sourceLineId,
        targetLineId = targetLineId,
        connectionType = ConnectionType.fromString(connectionType)
    )
}


/**
 * Converts a SearchAll database result to a domain SearchResult model.
 * This is used for global search across all books.
 *
 * @return The domain SearchResult model
 */
fun SearchAll.toSearchResult(): SearchResult = SearchResult(
    bookId = bookId ?: 0,
    bookTitle = bookTitle ?: "",
    lineId = id ?: 0,
    lineIndex = lineIndex?.toInt() ?: 0,
    snippet = snippet ?: "",
    rank = rank
)

/**
 * Converts a SearchInBook database result to a domain SearchResult model.
 * This is used for searching within a specific book.
 *
 * @return The domain SearchResult model
 */
fun SearchInBook.toSearchResult(): SearchResult = SearchResult(
    bookId = bookId ?: 0,
    bookTitle = bookTitle ?: "",
    lineId = id ?: 0,
    lineIndex = lineIndex?.toInt() ?: 0,
    snippet = snippet ?: "",
    rank = rank
)

/**
 * Converts a SearchByAuthor database result to a domain SearchResult model.
 * This is used for searching books by a specific author.
 *
 * @return The domain SearchResult model
 */
fun SearchByAuthor.toSearchResult(): SearchResult = SearchResult(
    bookId = bookId ?: 0,
    bookTitle = bookTitle ?: "",
    lineId = id ?: 0,
    lineIndex = lineIndex?.toInt() ?: 0,
    snippet = snippet ?: "",
    rank = rank
)

/**
 * Converts a SearchWithBookFilter database result to a domain SearchResult model.
 * This is used for searching with specific book filters applied.
 *
 * @return The domain SearchResult model
 */
fun SearchWithBookFilter.toSearchResult(): SearchResult = SearchResult(
    bookId = bookId ?: 0,
    bookTitle = bookTitle ?: "",
    lineId = id ?: 0,
    lineIndex = lineIndex?.toInt() ?: 0,
    snippet = snippet ?: "",
    rank = rank
)
</file>

<file path="lib/dao/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/dao/repository/SeforimRepository.kt">
package io.github.kdroidfilter.seforimlibrary.dao.repository



import app.cash.sqldelight.db.SqlDriver
import co.touchlab.kermit.Logger
import io.github.kdroidfilter.seforimlibrary.core.models.*
import io.github.kdroidfilter.seforimlibrary.dao.extensions.toModel
import io.github.kdroidfilter.seforimlibrary.dao.extensions.toSearchResult
import io.github.kdroidfilter.seforimlibrary.db.SeforimDb
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.serialization.json.Json

/**
 * Repository class for accessing and manipulating the Seforim database.
 * Provides methods for CRUD operations on books, categories, lines, TOC entries, and links.
 *
 * @property driver The SQL driver used to connect to the database
 * @constructor Creates a repository with the specified database path and driver
 */
class SeforimRepository(databasePath: String, private val driver: SqlDriver) {
    private val database = SeforimDb(driver)
    private val json = Json { ignoreUnknownKeys = true }
    private val logger = Logger.withTag("SeforimRepository")

    init {

        logger.d{"Initializing SeforimRepository"}
        // Create the database schema if it doesn't exist
        SeforimDb.Schema.create(driver)
        // SQLite optimizations
        driver.execute(null, "PRAGMA journal_mode=WAL", 0)
        driver.execute(null, "PRAGMA synchronous=NORMAL", 0)
        driver.execute(null, "PRAGMA cache_size=40000", 0)
        driver.execute(null, "PRAGMA temp_store=MEMORY", 0)

        // Check if the database is empty
        try {
            val bookCount = database.bookQueriesQueries.countAll().executeAsOne()
            logger.d{"Database contains $bookCount books"}
        } catch (e: Exception) {
            logger.d{"Error counting books: ${e.message}"}
        }
    }

    // --- Categories ---

    /**
     * Retrieves a category by its ID.
     *
     * @param id The ID of the category to retrieve
     * @return The category if found, null otherwise
     */
    suspend fun getCategory(id: Long): Category? = withContext(Dispatchers.IO) {
        database.categoryQueriesQueries.selectById(id).executeAsOneOrNull()?.toModel()
    }

    /**
     * Retrieves all root categories (categories without a parent).
     *
     * @return A list of root categories
     */
    suspend fun getRootCategories(): List<Category> = withContext(Dispatchers.IO) {
        database.categoryQueriesQueries.selectRoot().executeAsList().map { it.toModel() }
    }

    /**
     * Retrieves all child categories of a parent category.
     *
     * @param parentId The ID of the parent category
     * @return A list of child categories
     */
    suspend fun getCategoryChildren(parentId: Long): List<Category> = withContext(Dispatchers.IO) {
        database.categoryQueriesQueries.selectByParentId(parentId).executeAsList().map { it.toModel() }
    }



    /**
     * Inserts a category into the database.
     * If a category with the same title already exists, returns its ID instead.
     *
     * @param category The category to insert
     * @return The ID of the inserted or existing category
     * @throws RuntimeException If the insertion fails
     */
// Dans SeforimRepository.kt, remplacez la méthode insertCategory par celle-ci :

    suspend fun insertCategory(category: Category): Long = withContext(Dispatchers.IO) {
        logger.d { "🔧 Repository: Attempting to insert category '${category.title}'" }
        logger.d { "🔧 Category details: parentId=${category.parentId}, level=${category.level}" }

        try {
            // IMPORTANT: Check if a category with the same title AND SAME PARENT already exists
            // Two categories can have the same name if they have different parents!
            val existingCategories = if (category.parentId != null) {
                // Look for categories with the same parent
                database.categoryQueriesQueries.selectByParentId(category.parentId).executeAsList()
            } else {
                // Look for root categories (parentId is null)
                database.categoryQueriesQueries.selectRoot().executeAsList()
            }

            // Find a category with the same title in the same parent
            val existingCategory = existingCategories.find { it.title == category.title }

            if (existingCategory != null) {
                logger.d { "⚠️ Category with title '${category.title}' already exists under parent ${category.parentId} with ID: ${existingCategory.id}" }
                return@withContext existingCategory.id
            }

            // Try the insertion
            database.categoryQueriesQueries.insert(
                parentId = category.parentId,
                title = category.title,
                level = category.level.toLong()
            )

            val insertedId = database.categoryQueriesQueries.lastInsertRowId().executeAsOne()
            logger.d { "✅ Repository: Category inserted with ID: $insertedId" }

            if (insertedId == 0L) {

                // Check again if the category was inserted despite lastInsertRowId() returning 0
                val updatedCategories = if (category.parentId != null) {
                    database.categoryQueriesQueries.selectByParentId(category.parentId).executeAsList()
                } else {
                    database.categoryQueriesQueries.selectRoot().executeAsList()
                }

                val newCategory = updatedCategories.find { it.title == category.title }

                if (newCategory != null) {
                    logger.d { "🔄 Category found after insertion, returning existing ID: ${newCategory.id}" }
                    return@withContext newCategory.id
                }

                // If all else fails, throw an exception
                throw RuntimeException("Failed to insert category '${category.title}' with parent ${category.parentId}")
            }

            return@withContext insertedId

        } catch (e: Exception) {
            // Changed from error to warning level to reduce unnecessary error logs
            logger.w(e) { "❌ Repository: Error inserting category '${category.title}': ${e.message}" }

            // In case of error, check if the category exists anyway
            val categories = if (category.parentId != null) {
                database.categoryQueriesQueries.selectByParentId(category.parentId).executeAsList()
            } else {
                database.categoryQueriesQueries.selectRoot().executeAsList()
            }

            val existingCategory = categories.find { it.title == category.title }

            if (existingCategory != null) {
                logger.d { "🔄 Category exists after error, returning existing ID: ${existingCategory.id}" }
                return@withContext existingCategory.id
            }

            // Re-throw the exception if we can't recover
            throw e
        }
    }

    // --- Books ---

    /**
     * Retrieves a book by its ID, including all related data (authors, topics, etc.).
     *
     * @param id The ID of the book to retrieve
     * @return The book if found, null otherwise
     */
    suspend fun getBook(id: Long): Book? = withContext(Dispatchers.IO) {
        val bookData = database.bookQueriesQueries.selectById(id).executeAsOneOrNull() ?: return@withContext null
        val authors = getBookAuthors(bookData.id)
        val topics = getBookTopics(bookData.id)
        val pubPlaces = getBookPubPlaces(bookData.id)
        val pubDates = getBookPubDates(bookData.id)
        return@withContext bookData.toModel(json, authors, pubPlaces, pubDates).copy(topics = topics)
    }

    /**
     * Retrieves all books in a specific category.
     *
     * @param categoryId The ID of the category
     * @return A list of books in the category
     */
    suspend fun getBooksByCategory(categoryId: Long): List<Book> = withContext(Dispatchers.IO) {
        val books = database.bookQueriesQueries.selectByCategoryId(categoryId).executeAsList()
        return@withContext books.map { bookData ->
            val authors = getBookAuthors(bookData.id)
            val topics = getBookTopics(bookData.id)
            val pubPlaces = getBookPubPlaces(bookData.id)
            val pubDates = getBookPubDates(bookData.id)
            bookData.toModel(json, authors, pubPlaces, pubDates).copy(topics = topics)
        }
    }



    suspend fun searchBooksByAuthor(authorName: String): List<Book> = withContext(Dispatchers.IO) {
        val books = database.bookQueriesQueries.selectByAuthor("%$authorName%").executeAsList()
        return@withContext books.map { bookData ->
            val authors = getBookAuthors(bookData.id)
            val topics = getBookTopics(bookData.id)
            val pubPlaces = getBookPubPlaces(bookData.id)
            val pubDates = getBookPubDates(bookData.id)
            bookData.toModel(json, authors, pubPlaces, pubDates).copy(topics = topics)
        }
    }

    // Get all authors for a book
    private suspend fun getBookAuthors(bookId: Long): List<Author> = withContext(Dispatchers.IO) {
        logger.d{"Getting authors for book ID: $bookId"}
        val authors = database.authorQueriesQueries.selectByBookId(bookId).executeAsList()
        logger.d{"Found ${authors.size} authors for book ID: $bookId"}
        return@withContext authors.map { it.toModel() }
    }

    // Get all topics for a book
    private suspend fun getBookTopics(bookId: Long): List<Topic> = withContext(Dispatchers.IO) {
        logger.d{"Getting topics for book ID: $bookId"}
        val topics = database.topicQueriesQueries.selectByBookId(bookId).executeAsList()
        logger.d{"Found ${topics.size} topics for book ID: $bookId"}
        return@withContext topics.map { Topic(id = it.id, name = it.name) }
    }

    // Get all publication places for a book
    private suspend fun getBookPubPlaces(bookId: Long): List<PubPlace> = withContext(Dispatchers.IO) {
        logger.d{"Getting publication places for book ID: $bookId"}
        val pubPlaces = database.pubPlaceQueriesQueries.selectByBookId(bookId).executeAsList()
        logger.d{"Found ${pubPlaces.size} publication places for book ID: $bookId"}
        return@withContext pubPlaces.map { it.toModel() }
    }

    // Get all publication dates for a book
    private suspend fun getBookPubDates(bookId: Long): List<PubDate> = withContext(Dispatchers.IO) {
        logger.d{"Getting publication dates for book ID: $bookId"}
        val pubDates = database.pubDateQueriesQueries.selectByBookId(bookId).executeAsList()
        logger.d{"Found ${pubDates.size} publication dates for book ID: $bookId"}
        return@withContext pubDates.map { it.toModel() }
    }

    // Get an author by name, returns null if not found
    suspend fun getAuthorByName(name: String): Author? = withContext(Dispatchers.IO) {
        logger.d{"Looking for author with name: $name"}
        val author = database.authorQueriesQueries.selectByName(name).executeAsOneOrNull()
        if (author != null) {
            logger.d{"Found author with ID: ${author.id}"}
        } else {
            logger.d{"Author not found: $name"}
        }
        return@withContext author?.toModel()
    }

    // Insert an author and return its ID
    suspend fun insertAuthor(name: String): Long = withContext(Dispatchers.IO) {
        logger.d{"Inserting author: $name"}

        // Check if author already exists
        val existingAuthor = database.authorQueriesQueries.selectByName(name).executeAsOneOrNull()
        if (existingAuthor != null) {
            logger.d{"Author already exists with ID: ${existingAuthor.id}"}
            return@withContext existingAuthor.id
        }

        // Insert the author
        database.authorQueriesQueries.insert(name)

        // Get the ID of the inserted author
        val authorId = database.authorQueriesQueries.lastInsertRowId().executeAsOne()

        // If lastInsertRowId returns 0, it might be because the insertion was ignored due to a conflict
        // Try to get the ID by name
        if (authorId == 0L) {

            val insertedAuthor = database.authorQueriesQueries.selectByName(name).executeAsOneOrNull()
            if (insertedAuthor != null) {
                logger.d{"Found author after insertion with ID: ${insertedAuthor.id}"}
                return@withContext insertedAuthor.id
            }

            // If we can't find the author by name, try to insert it again with a different method
            logger.d{"Author not found after insertion, trying insertAndGetId"}
            database.authorQueriesQueries.insertAndGetId(name)

            // Check again
            val retryAuthor = database.authorQueriesQueries.selectByName(name).executeAsOneOrNull()
            if (retryAuthor != null) {
                logger.d{"Found author after retry with ID: ${retryAuthor.id}"}
                return@withContext retryAuthor.id
            }

            // If all else fails, return a dummy ID that will be used for this session only
            // This allows the process to continue without throwing an exception
            logger.w{"Could not insert author '$name' after multiple attempts, using temporary ID"}
            return@withContext 999999L
        }

        logger.d{"Author inserted with ID: $authorId"}
        return@withContext authorId
    }

    // Link an author to a book
    suspend fun linkAuthorToBook(authorId: Long, bookId: Long) = withContext(Dispatchers.IO) {
        logger.d{"Linking author $authorId to book $bookId"}
        database.authorQueriesQueries.linkBookAuthor(bookId, authorId)
        logger.d{"Linked author $authorId to book $bookId"}
    }

    suspend fun getBookByTitle(title: String): Book? = withContext(Dispatchers.IO) {
        val bookData = database.bookQueriesQueries.selectByTitle(title).executeAsOneOrNull() ?: return@withContext null
        val authors = getBookAuthors(bookData.id)
        val topics = getBookTopics(bookData.id)
        val pubPlaces = getBookPubPlaces(bookData.id)
        val pubDates = getBookPubDates(bookData.id)
        return@withContext bookData.toModel(json, authors, pubPlaces, pubDates).copy(topics = topics)
    }

    // Get a topic by name, returns null if not found
    suspend fun getTopicByName(name: String): Topic? = withContext(Dispatchers.IO) {
        logger.d{"Looking for topic with name: $name"}
        val topic = database.topicQueriesQueries.selectByName(name).executeAsOneOrNull()
        if (topic != null) {
            logger.d{"Found topic with ID: ${topic.id}"}
        } else {
            logger.d{"Topic not found: $name"}
        }
        return@withContext topic?.let { Topic(id = it.id, name = it.name) }
    }

    // Get a publication place by name, returns null if not found
    suspend fun getPubPlaceByName(name: String): PubPlace? = withContext(Dispatchers.IO) {
        logger.d{"Looking for publication place with name: $name"}
        val pubPlace = database.pubPlaceQueriesQueries.selectByName(name).executeAsOneOrNull()
        if (pubPlace != null) {
            logger.d{"Found publication place with ID: ${pubPlace.id}"}
        } else {
            logger.d{"Publication place not found: $name"}
        }
        return@withContext pubPlace?.toModel()
    }

    // Get a publication date by date, returns null if not found
    suspend fun getPubDateByDate(date: String): PubDate? = withContext(Dispatchers.IO) {
        logger.d{"Looking for publication date with date: $date"}
        val pubDate = database.pubDateQueriesQueries.selectByDate(date).executeAsOneOrNull()
        if (pubDate != null) {
            logger.d{"Found publication date with ID: ${pubDate.id}"}
        } else {
            logger.d{"Publication date not found: $date"}
        }
        return@withContext pubDate?.toModel()
    }

    // Insert a topic and return its ID
    suspend fun insertTopic(name: String): Long = withContext(Dispatchers.IO) {
        logger.d{"Inserting topic: $name"}

        // Check if topic already exists
        val existingTopic = database.topicQueriesQueries.selectByName(name).executeAsOneOrNull()
        if (existingTopic != null) {
            logger.d{"Topic already exists with ID: ${existingTopic.id}"}
            return@withContext existingTopic.id
        }

        // Insert the topic
        database.topicQueriesQueries.insert(name)

        // Get the ID of the inserted topic
        val topicId = database.topicQueriesQueries.lastInsertRowId().executeAsOne()

        // If lastInsertRowId returns 0, it might be because the insertion was ignored due to a conflict
        // Try to get the ID by name
        if (topicId == 0L) {

            val insertedTopic = database.topicQueriesQueries.selectByName(name).executeAsOneOrNull()
            if (insertedTopic != null) {
                logger.d{"Found topic after insertion with ID: ${insertedTopic.id}"}
                return@withContext insertedTopic.id
            }

            // If we can't find the topic by name, try to insert it again with a different method
            logger.d{"Topic not found after insertion, trying insertAndGetId"}
            database.topicQueriesQueries.insertAndGetId(name)

            // Check again
            val retryTopic = database.topicQueriesQueries.selectByName(name).executeAsOneOrNull()
            if (retryTopic != null) {
                logger.d{"Found topic after retry with ID: ${retryTopic.id}"}
                return@withContext retryTopic.id
            }

            // If all else fails, return a dummy ID that will be used for this session only
            // This allows the process to continue without throwing an exception
            logger.w{"Could not insert topic '$name' after multiple attempts, using temporary ID"}
            return@withContext 999999L
        }

        logger.d{"Topic inserted with ID: $topicId"}
        return@withContext topicId
    }

    // Link a topic to a book
    suspend fun linkTopicToBook(topicId: Long, bookId: Long) = withContext(Dispatchers.IO) {
        logger.d{"Linking topic $topicId to book $bookId"}
        database.topicQueriesQueries.linkBookTopic(bookId, topicId)
        logger.d{"Linked topic $topicId to book $bookId"}
    }

    // Insert a publication place and return its ID
    suspend fun insertPubPlace(name: String): Long = withContext(Dispatchers.IO) {
        logger.d{"Inserting publication place: $name"}

        // Check if publication place already exists
        val existingPubPlace = database.pubPlaceQueriesQueries.selectByName(name).executeAsOneOrNull()
        if (existingPubPlace != null) {
            logger.d{"Publication place already exists with ID: ${existingPubPlace.id}"}
            return@withContext existingPubPlace.id
        }

        // Insert the publication place
        database.pubPlaceQueriesQueries.insert(name)

        // Get the ID of the inserted publication place
        val pubPlaceId = database.pubPlaceQueriesQueries.lastInsertRowId().executeAsOne()

        // If lastInsertRowId returns 0, it might be because the insertion was ignored due to a conflict
        // Try to get the ID by name
        if (pubPlaceId == 0L) {

            val insertedPubPlace = database.pubPlaceQueriesQueries.selectByName(name).executeAsOneOrNull()
            if (insertedPubPlace != null) {
                logger.d{"Found publication place after insertion with ID: ${insertedPubPlace.id}"}
                return@withContext insertedPubPlace.id
            }

            // If all else fails, return a dummy ID that will be used for this session only
            // This allows the process to continue without throwing an exception
            logger.w{"Could not insert publication place '$name' after multiple attempts, using temporary ID"}
            return@withContext 999999L
        }

        logger.d{"Publication place inserted with ID: $pubPlaceId"}
        return@withContext pubPlaceId
    }

    // Insert a publication date and return its ID
    suspend fun insertPubDate(date: String): Long = withContext(Dispatchers.IO) {
        logger.d{"Inserting publication date: $date"}

        // Check if publication date already exists
        val existingPubDate = database.pubDateQueriesQueries.selectByDate(date).executeAsOneOrNull()
        if (existingPubDate != null) {
            logger.d{"Publication date already exists with ID: ${existingPubDate.id}"}
            return@withContext existingPubDate.id
        }

        // Insert the publication date
        database.pubDateQueriesQueries.insert(date)

        // Get the ID of the inserted publication date
        val pubDateId = database.pubDateQueriesQueries.lastInsertRowId().executeAsOne()

        // If lastInsertRowId returns 0, it might be because the insertion was ignored due to a conflict
        // Try to get the ID by date
        if (pubDateId == 0L) {

            val insertedPubDate = database.pubDateQueriesQueries.selectByDate(date).executeAsOneOrNull()
            if (insertedPubDate != null) {
                logger.d{"Found publication date after insertion with ID: ${insertedPubDate.id}"}
                return@withContext insertedPubDate.id
            }

            // If all else fails, return a dummy ID that will be used for this session only
            // This allows the process to continue without throwing an exception
            logger.w{"Could not insert publication date '$date' after multiple attempts, using temporary ID"}
            return@withContext 999999L
        }

        logger.d{"Publication date inserted with ID: $pubDateId"}
        return@withContext pubDateId
    }

    // Link a publication place to a book
    suspend fun linkPubPlaceToBook(pubPlaceId: Long, bookId: Long) = withContext(Dispatchers.IO) {
        logger.d{"Linking publication place $pubPlaceId to book $bookId"}
        database.pubPlaceQueriesQueries.linkBookPubPlace(bookId, pubPlaceId)
        logger.d{"Linked publication place $pubPlaceId to book $bookId"}
    }

    // Link a publication date to a book
    suspend fun linkPubDateToBook(pubDateId: Long, bookId: Long) = withContext(Dispatchers.IO) {
        logger.d{"Linking publication date $pubDateId to book $bookId"}
        database.pubDateQueriesQueries.linkBookPubDate(bookId, pubDateId)
        logger.d{"Linked publication date $pubDateId to book $bookId"}
    }

    /**
     * Inserts a book into the database, including all related data (authors, topics, etc.).
     * If the book has an ID greater than 0, uses that ID; otherwise, generates a new ID.
     *
     * @param book The book to insert
     * @return The ID of the inserted book
     */
    suspend fun insertBook(book: Book): Long = withContext(Dispatchers.IO) {
        logger.d{"Repository inserting book '${book.title}' with ID: ${book.id} and categoryId: ${book.categoryId}"}

        // Use the ID from the book object if it's greater than 0
        if (book.id > 0) {
            database.bookQueriesQueries.insertWithId(
                id = book.id,
                categoryId = book.categoryId,
                title = book.title,
                heShortDesc = book.heShortDesc,
                orderIndex = book.order.toLong(),
                totalLines = book.totalLines.toLong()
            )
            logger.d{"Used insertWithId for book '${book.title}' with ID: ${book.id} and categoryId: ${book.categoryId}"}

            // ✅ Verify that the insertion was successful
            val insertedBook = database.bookQueriesQueries.selectById(book.id).executeAsOneOrNull()
            if (insertedBook?.categoryId != book.categoryId) {
                // Changed from error to warning level to reduce unnecessary error logs
                logger.w{"WARNING: Book inserted with wrong categoryId! Expected: ${book.categoryId}, Got: ${insertedBook?.categoryId}"}
                // Fix immediately
                database.bookQueriesQueries.updateCategoryId(book.categoryId, book.id)
                logger.d{"Corrected categoryId for book ID: ${book.id}"}
            }

            // Process authors
            for (author in book.authors) {
                val authorId = insertAuthor(author.name)
                linkAuthorToBook(authorId, book.id)
                logger.d{"Processed author '${author.name}' (ID: $authorId) for book '${book.title}' (ID: ${book.id})"}
            }

            // Process topics
            for (topic in book.topics) {
                val topicId = insertTopic(topic.name)
                linkTopicToBook(topicId, book.id)
                logger.d{"Processed topic '${topic.name}' (ID: $topicId) for book '${book.title}' (ID: ${book.id})"}
            }

            // Process publication places
            for (pubPlace in book.pubPlaces) {
                val pubPlaceId = insertPubPlace(pubPlace.name)
                linkPubPlaceToBook(pubPlaceId, book.id)
                logger.d{"Processed publication place '${pubPlace.name}' (ID: $pubPlaceId) for book '${book.title}' (ID: ${book.id})"}
            }

            // Process publication dates
            for (pubDate in book.pubDates) {
                val pubDateId = insertPubDate(pubDate.date)
                linkPubDateToBook(pubDateId, book.id)
                logger.d{"Processed publication date '${pubDate.date}' (ID: $pubDateId) for book '${book.title}' (ID: ${book.id})"}
            }

            return@withContext book.id
        } else {
            // Fall back to auto-generated ID if book.id is 0
            database.bookQueriesQueries.insert(
                categoryId = book.categoryId,
                title = book.title,
                heShortDesc = book.heShortDesc,
                orderIndex = book.order.toLong(),
                totalLines = book.totalLines.toLong()
            )
            val id = database.bookQueriesQueries.lastInsertRowId().executeAsOne()
            logger.d{"Used insert for book '${book.title}', got ID: $id with categoryId: ${book.categoryId}"}

            // Check if insertion failed
            if (id == 0L) {
                // Try to find the book by title
                val existingBook = database.bookQueriesQueries.selectByTitle(book.title).executeAsOneOrNull()
                if (existingBook != null) {
                    logger.d { "Found book after failed insertion, returning existing ID: ${existingBook.id}" }
                    return@withContext existingBook.id
                }

                throw RuntimeException("Failed to insert book '${book.title}' - insertion returned ID 0. Context: categoryId=${book.categoryId}, authors=${book.authors.map { it.name }}, topics=${book.topics.map { it.name }}, pubPlaces=${book.pubPlaces.map { it.name }}, pubDates=${book.pubDates.map { it.date }}")
            }

            // Process authors
            for (author in book.authors) {
                val authorId = insertAuthor(author.name)
                linkAuthorToBook(authorId, id)
                logger.d{"Processed author '${author.name}' (ID: $authorId) for book '${book.title}' (ID: $id)"}
            }

            // Process topics
            for (topic in book.topics) {
                val topicId = insertTopic(topic.name)
                linkTopicToBook(topicId, id)
                logger.d{"Processed topic '${topic.name}' (ID: $topicId) for book '${book.title}' (ID: $id)"}
            }

            // Process publication places
            for (pubPlace in book.pubPlaces) {
                val pubPlaceId = insertPubPlace(pubPlace.name)
                linkPubPlaceToBook(pubPlaceId, id)
                logger.d{"Processed publication place '${pubPlace.name}' (ID: $pubPlaceId) for book '${book.title}' (ID: $id)"}
            }

            // Process publication dates
            for (pubDate in book.pubDates) {
                val pubDateId = insertPubDate(pubDate.date)
                linkPubDateToBook(pubDateId, id)
                logger.d{"Processed publication date '${pubDate.date}' (ID: $pubDateId) for book '${book.title}' (ID: $id)"}
            }

            return@withContext id
        }
    }

    suspend fun updateBookTotalLines(bookId: Long, totalLines: Int) = withContext(Dispatchers.IO) {
        database.bookQueriesQueries.updateTotalLines(totalLines.toLong(), bookId)
    }

    suspend fun updateBookCategoryId(bookId: Long, categoryId: Long) = withContext(Dispatchers.IO) {
        logger.d{"Updating book $bookId with categoryId: $categoryId"}
        database.bookQueriesQueries.updateCategoryId(categoryId, bookId)
        logger.d{"Updated book $bookId with categoryId: $categoryId"}
    }

    // --- Lines ---

    suspend fun getLine(id: Long): Line? = withContext(Dispatchers.IO) {
        database.lineQueriesQueries.selectById(id).executeAsOneOrNull()?.toModel()
    }

    suspend fun getLineByIndex(bookId: Long, lineIndex: Int): Line? = withContext(Dispatchers.IO) {
        database.lineQueriesQueries.selectByBookIdAndIndex(bookId, lineIndex.toLong())
            .executeAsOneOrNull()?.toModel()
    }

    suspend fun getLines(bookId: Long, startIndex: Int, endIndex: Int): List<Line> =
        withContext(Dispatchers.IO) {
            database.lineQueriesQueries.selectByBookIdRange(
                bookId = bookId,
                lineIndex = startIndex.toLong(),
                lineIndex_ = endIndex.toLong()
            ).executeAsList().map { it.toModel() }
        }

    suspend fun insertLine(line: Line): Long = withContext(Dispatchers.IO) {
        logger.d{"Repository inserting line with bookId: ${line.bookId}"}

        // Use the ID from the line object if it's greater than 0
        if (line.id > 0) {
            database.lineQueriesQueries.insertWithId(
                id = line.id,
                bookId = line.bookId,
                lineIndex = line.lineIndex.toLong(),
                content = line.content,
                plainText = line.plainText,
                tocEntryId = null
            )
            logger.d{"Repository inserted line with explicit ID: ${line.id} and bookId: ${line.bookId}"}
            return@withContext line.id
        } else {
            // Fall back to auto-generated ID if line.id is 0
            database.lineQueriesQueries.insert(
                bookId = line.bookId,
                lineIndex = line.lineIndex.toLong(),
                content = line.content,
                plainText = line.plainText,
                tocEntryId = null
            )
            val lineId = database.lineQueriesQueries.lastInsertRowId().executeAsOne()
            logger.d{"Repository inserted line with auto-generated ID: $lineId and bookId: ${line.bookId}"}

            // Check if insertion failed
            if (lineId == 0L) {
                // Try to find the line by bookId and lineIndex
                val existingLine = database.lineQueriesQueries.selectByBookIdAndIndex(line.bookId, line.lineIndex.toLong()).executeAsOneOrNull()
                if (existingLine != null) {
                    logger.d { "Found line after failed insertion, returning existing ID: ${existingLine.id}" }
                    return@withContext existingLine.id
                }

                throw RuntimeException("Failed to insert line for book ${line.bookId} at index ${line.lineIndex} - insertion returned ID 0. Context: content='${line.content.take(50)}${if (line.content.length > 50) "..." else ""}', plainText='${line.plainText.take(50)}${if (line.plainText.length > 50) "..." else ""}')")
            }

            return@withContext lineId
        }
    }

    suspend fun updateLineTocEntry(lineId: Long, tocEntryId: Long) = withContext(Dispatchers.IO) {
        logger.d{"Repository updating line $lineId with tocEntryId: $tocEntryId"}
        database.lineQueriesQueries.updateTocEntryId(tocEntryId, lineId)
        logger.d{"Repository updated line $lineId with tocEntryId: $tocEntryId"}
    }

    // --- Table of Contents ---

    suspend fun getTocEntry(id: Long): TocEntry? = withContext(Dispatchers.IO) {
        database.tocQueriesQueries.selectTocById(id).executeAsOneOrNull()?.toModel()
    }

    suspend fun getBookToc(bookId: Long): List<TocEntry> = withContext(Dispatchers.IO) {
        database.tocQueriesQueries.selectByBookId(bookId).executeAsList().map { it.toModel() }
    }

    suspend fun getBookRootToc(bookId: Long): List<TocEntry> = withContext(Dispatchers.IO) {
        database.tocQueriesQueries.selectRootByBookId(bookId).executeAsList().map { it.toModel() }
    }

    suspend fun getTocChildren(parentId: Long): List<TocEntry> = withContext(Dispatchers.IO) {
        database.tocQueriesQueries.selectChildren(parentId).executeAsList().map { it.toModel() }
    }

    // --- TocText methods ---

    // Get or create a tocText entry and return its ID
    private suspend fun getOrCreateTocText(text: String): Long = withContext(Dispatchers.IO) {
        // Truncate text for logging if it's too long
        val truncatedText = if (text.length > 50) "${text.take(50)}..." else text
        logger.d{"Getting or creating tocText entry for text: '$truncatedText'"}

        try {
            // Check if the text already exists
            logger.d{"Checking if text already exists in database"}
            val existingId = database.tocTextQueriesQueries.selectIdByText(text).executeAsOneOrNull()
            if (existingId != null) {
                logger.d{"Found existing tocText entry with ID: $existingId for text: '$truncatedText'"}
                return@withContext existingId
            }

            // Insert the text
            logger.d{"Text not found, inserting new tocText entry for: '$truncatedText'"}
            database.tocTextQueriesQueries.insertAndGetId(text)

            // Get the ID of the inserted text
            logger.d{"Getting ID of inserted tocText entry"}
            val textId = database.tocTextQueriesQueries.lastInsertRowId().executeAsOne()
            logger.d{"lastInsertRowId() returned: $textId"}

            // If lastInsertRowId returns 0, it's likely because the text already exists (due to INSERT OR IGNORE)
            // This is expected behavior, not an error, so we'll try to get the ID by text
            if (textId == 0L) {
                // Log at debug level since this is expected behavior when text already exists
                logger.d{"lastInsertRowId() returned 0 for tocText insertion (likely due to INSERT OR IGNORE). Text: '$truncatedText', Length: ${text.length}, Hash: ${text.hashCode()}. Trying to get ID by text."}

                // Try to find the text that was just inserted or that already existed
                val insertedId = database.tocTextQueriesQueries.selectIdByText(text).executeAsOneOrNull()
                if (insertedId != null) {
                    logger.d{"Found tocText with ID: $insertedId for text: '$truncatedText'"}
                    return@withContext insertedId
                }

                // If we can't find the text by exact match, this is unexpected and should be logged as an error
                // Count total tocTexts for debugging
                val totalTocTexts = database.tocTextQueriesQueries.countAll().executeAsOne()

                // Log more details about the failure
                // Changed from error to warning level to reduce unnecessary error logs
                logger.w{"Failed to insert tocText and couldn't find it after insertion. This is unexpected since the text should either be inserted or already exist. Text: '$truncatedText', Length: ${text.length}, Hash: ${text.hashCode()}, Total TocTexts: $totalTocTexts"}

                throw RuntimeException("Failed to insert tocText '$truncatedText' - insertion returned ID 0 and couldn't find text afterward. This is unexpected since the text should either be inserted or already exist. Context: textLength=${text.length}, textHash=${text.hashCode()}, totalTocTexts=$totalTocTexts")
            }

            logger.d{"Created new tocText entry with ID: $textId for text: '$truncatedText'"}
            return@withContext textId
        } catch (e: Exception) {
            // Changed from error to warning level to reduce unnecessary error logs
            logger.w(e){"Exception in getOrCreateTocText for text: '$truncatedText', Length: ${text.length}, Hash: ${text.hashCode()}. Error: ${e.message}"}
            throw e
        }
    }

    suspend fun insertTocEntry(entry: TocEntry): Long = withContext(Dispatchers.IO) {
        logger.d{"Repository inserting TOC entry with bookId: ${entry.bookId}, lineId: ${entry.lineId}"}

        // Get or create the tocText entry
        val textId = entry.textId ?: getOrCreateTocText(entry.text)
        logger.d{"Using tocText ID: $textId for text: ${entry.text}"}

        // Use the ID from the entry object if it's greater than 0
        if (entry.id > 0) {
            database.tocQueriesQueries.insertWithId(
                id = entry.id,
                bookId = entry.bookId,
                parentId = entry.parentId,
                textId = textId,
                level = entry.level.toLong(),
                lineId = entry.lineId
            )
            logger.d{"Repository inserted TOC entry with explicit ID: ${entry.id}, bookId: ${entry.bookId}, lineId: ${entry.lineId}"}
            return@withContext entry.id
        } else {
            // Fall back to auto-generated ID if entry.id is 0
            database.tocQueriesQueries.insert(
                bookId = entry.bookId,
                parentId = entry.parentId,
                textId = textId,
                level = entry.level.toLong(),
                lineId = entry.lineId
            )
            val tocId = database.tocQueriesQueries.lastInsertRowId().executeAsOne()
            logger.d{"Repository inserted TOC entry with auto-generated ID: $tocId, bookId: ${entry.bookId}, lineId: ${entry.lineId}"}

            // Check if insertion failed
            if (tocId == 0L) {

                // Try to find a matching TOC entry by bookId and text
                val existingEntries = database.tocQueriesQueries.selectByBookId(entry.bookId).executeAsList()
                val matchingEntry = existingEntries.find { 
                    it.text == entry.text && it.level == entry.level.toLong() 
                }

                if (matchingEntry != null) {
                    logger.d { "Found matching TOC entry after failed insertion, returning existing ID: ${matchingEntry.id}" }
                    return@withContext matchingEntry.id
                }

                throw RuntimeException("Failed to insert TOC entry for book ${entry.bookId} with text '${entry.text.take(30)}${if (entry.text.length > 30) "..." else ""}' - insertion returned ID 0. Context: parentId=${entry.parentId}, level=${entry.level}, lineId=${entry.lineId}")
            }

            return@withContext tocId
        }
    }

    suspend fun updateTocEntryLineId(tocEntryId: Long, lineId: Long) = withContext(Dispatchers.IO) {
        logger.d{"Repository updating TOC entry $tocEntryId with lineId: $lineId"}
        database.tocQueriesQueries.updateLineId(lineId, tocEntryId)
        logger.d{"Repository updated TOC entry $tocEntryId with lineId: $lineId"}
    }

    // --- Connection Types ---

    /**
     * Gets a connection type by name, or creates it if it doesn't exist.
     *
     * @param name The name of the connection type
     * @return The ID of the connection type
     */
    private suspend fun getOrCreateConnectionType(name: String): Long = withContext(Dispatchers.IO) {
        logger.d{"Getting or creating connection type: $name"}

        // Check if the connection type already exists
        val existingType = database.connectionTypeQueriesQueries.selectByName(name).executeAsOneOrNull()
        if (existingType != null) {
            logger.d{"Found existing connection type with ID: ${existingType.id}"}
            return@withContext existingType.id
        }

        // Insert the connection type
        database.connectionTypeQueriesQueries.insert(name)

        // Get the ID of the inserted connection type
        val typeId = database.connectionTypeQueriesQueries.lastInsertRowId().executeAsOne()

        // If lastInsertRowId returns 0, try to get the ID by name
        if (typeId == 0L) {

            val insertedType = database.connectionTypeQueriesQueries.selectByName(name).executeAsOneOrNull()
            if (insertedType != null) {
                logger.d{"Found connection type after insertion with ID: ${insertedType.id}"}
                return@withContext insertedType.id
            }

            throw RuntimeException("Failed to insert connection type '$name' - insertion returned ID 0 and couldn't find type afterward")
        }

        logger.d{"Created new connection type with ID: $typeId"}
        return@withContext typeId
    }

    /**
     * Gets all connection types from the database.
     *
     * @return A list of all connection types
     */
    suspend fun getAllConnectionTypes(): List<ConnectionType> = withContext(Dispatchers.IO) {
        database.connectionTypeQueriesQueries.selectAll().executeAsList().map { 
            ConnectionType.fromString(it.name)
        }
    }

    // --- Links ---

    suspend fun getLink(id: Long): Link? = withContext(Dispatchers.IO) {
        database.linkQueriesQueries.selectLinkById(id).executeAsOneOrNull()?.toModel()
    }

    suspend fun countLinks(): Long = withContext(Dispatchers.IO) {
        logger.d{"Counting links in database"}
        val count = database.linkQueriesQueries.countAllLinks().executeAsOne()
        logger.d{"Found $count links in database"}
        count
    }

    suspend fun getCommentariesForLines(
        lineIds: List<Long>,
        activeCommentatorIds: Set<Long> = emptySet()
    ): List<CommentaryWithText> = withContext(Dispatchers.IO) {
        database.linkQueriesQueries.selectLinksBySourceLineIds(lineIds).executeAsList()
            .filter { activeCommentatorIds.isEmpty() || it.targetBookId in activeCommentatorIds }
            .map {
                CommentaryWithText(
                    link = Link(
                        id = it.id,
                        sourceBookId = it.sourceBookId,
                        targetBookId = it.targetBookId,
                        sourceLineId = it.sourceLineId,
                        targetLineId = it.targetLineId,
                        connectionType = ConnectionType.fromString(it.connectionType)
                    ),
                    targetBookTitle = it.targetBookTitle,
                    targetText = it.targetText
                )
            }
    }

    suspend fun getAvailableCommentators(bookId: Long): List<CommentatorInfo> =
        withContext(Dispatchers.IO) {
            database.linkQueriesQueries.selectCommentatorsByBook(bookId).executeAsList()
                .map {
                    CommentatorInfo(
                        bookId = it.targetBookId,
                        title = it.targetBookTitle,
                        author = it.author,
                        linkCount = it.linkCount.toInt()
                    )
                }
        }

    suspend fun insertLink(link: Link): Long = withContext(Dispatchers.IO) {
        logger.d{"Repository inserting link from book ${link.sourceBookId} to book ${link.targetBookId}"}
        logger.d{"Link details - sourceLineId: ${link.sourceLineId}, targetLineId: ${link.targetLineId}, connectionType: ${link.connectionType.name}"}

        try {
            // Get or create the connection type
            val connectionTypeId = getOrCreateConnectionType(link.connectionType.name)
            logger.d{"Using connection type ID: $connectionTypeId for type: ${link.connectionType.name}"}

            database.linkQueriesQueries.insert(
                sourceBookId = link.sourceBookId,
                targetBookId = link.targetBookId,
                sourceLineId = link.sourceLineId,
                targetLineId = link.targetLineId,
                connectionTypeId = connectionTypeId
            )
            val linkId = database.linkQueriesQueries.lastInsertRowId().executeAsOne()
            logger.d{"Repository inserted link with ID: $linkId"}

            // Check if insertion failed
            if (linkId == 0L) {

                // Try to find a matching link
                val existingLinks = database.linkQueriesQueries.selectLinksBySourceBook(link.sourceBookId).executeAsList()
                val matchingLink = existingLinks.find { 
                    it.targetBookId == link.targetBookId && 
                    it.sourceLineId == link.sourceLineId && 
                    it.targetLineId == link.targetLineId 
                }

                if (matchingLink != null) {
                    logger.d { "Found matching link after failed insertion, returning existing ID: ${matchingLink.id}" }
                    return@withContext matchingLink.id
                }

                throw RuntimeException("Failed to insert link from book ${link.sourceBookId} to book ${link.targetBookId} - insertion returned ID 0. Context: sourceLineId=${link.sourceLineId}, targetLineId=${link.targetLineId}, connectionType=${link.connectionType.name}")
            }

            return@withContext linkId
        } catch (e: Exception) {
            // Changed from error to warning level to reduce unnecessary error logs
            logger.w(e){"Error inserting link: ${e.message}"}
            throw e
        }
    }

    /**
     * Migrates existing links to use the new connection_type table.
     * This should be called once after updating the database schema.
     */
    suspend fun migrateConnectionTypes() = withContext(Dispatchers.IO) {
        logger.d{"Starting migration of connection types"}

        try {
            // Make sure all connection types exist in the connection_type table
            for (type in ConnectionType.values()) {
                getOrCreateConnectionType(type.name)
            }

            // Get all links from the database
            val links = database.linkQueriesQueries.selectLinksBySourceBook(0).executeAsList()
            logger.d{"Found ${links.size} links to migrate"}

            // For each link, update the connectionTypeId
            var migratedCount = 0
            for (link in links) {
                val connectionTypeId = getOrCreateConnectionType(link.connectionType)

                // Execute a raw SQL query to update the link
                val updateSql = "UPDATE link SET connectionTypeId = $connectionTypeId WHERE id = ${link.id}"
                executeRawQuery(updateSql)

                migratedCount++
                if (migratedCount % 100 == 0) {
                    logger.d{"Migrated $migratedCount links so far"}
                }
            }

            logger.d{"Successfully migrated $migratedCount links"}
            logger.d{"Connection types migration completed successfully"}
        } catch (e: Exception) {
            logger.e(e){"Error during connection types migration: ${e.message}"}
            throw e
        }
    }

    // --- Search ---

    /**
     * Searches for text across all books.
     *
     * @param query The search query
     * @param limit Maximum number of results to return
     * @param offset Number of results to skip (for pagination)
     * @return A list of search results
     */
    suspend fun search(
        query: String,
        limit: Int = 20,
        offset: Int = 0
    ): List<SearchResult> = withContext(Dispatchers.IO) {
        val ftsQuery = prepareFtsQuery(query)
        database.searchQueriesQueries.searchAll(ftsQuery, limit.toLong(), offset.toLong())
            .executeAsList()
            .map { it.toSearchResult() }
    }

    /**
     * Searches for text within a specific book.
     *
     * @param bookId The ID of the book to search in
     * @param query The search query
     * @param limit Maximum number of results to return
     * @param offset Number of results to skip (for pagination)
     * @return A list of search results
     */
    suspend fun searchInBook(
        bookId: Long,
        query: String,
        limit: Int = 20,
        offset: Int = 0
    ): List<SearchResult> = withContext(Dispatchers.IO) {
        val ftsQuery = prepareFtsQuery(query)
        database.searchQueriesQueries.searchInBook(
            ftsQuery, bookId, limit.toLong(), offset.toLong()
        ).executeAsList().map { it.toSearchResult() }
    }

    /**
     * Searches for text in books by a specific author.
     *
     * @param author The author name to filter by
     * @param query The search query
     * @param limit Maximum number of results to return
     * @param offset Number of results to skip (for pagination)
     * @return A list of search results
     */
    suspend fun searchByAuthor(
        author: String,
        query: String,
        limit: Int = 20,
        offset: Int = 0
    ): List<SearchResult> = withContext(Dispatchers.IO) {
        val ftsQuery = prepareFtsQuery(query)
        database.searchQueriesQueries.searchByAuthor(
            ftsQuery, author, limit.toLong(), offset.toLong()
        ).executeAsList().map { it.toSearchResult() }
    }

    // --- Helpers ---

    /**
     * Prepares a search query for full-text search.
     * Adds wildcards and quotes to improve search results.
     *
     * @param query The raw search query
     * @return The formatted query for FTS
     */
    private fun prepareFtsQuery(query: String): String {
        return query.trim()
            .split("\\s+".toRegex())
            .filter { it.isNotBlank() }
            .joinToString(" ") { "\"$it\"*" }
    }

    /**
     * Executes a raw SQL query.
     * This is useful for operations that are not covered by the generated queries,
     * such as enabling or disabling foreign key constraints.
     *
     * @param sql The SQL query to execute
     */
    suspend fun executeRawQuery(sql: String) = withContext(Dispatchers.IO) {
        logger.d { "Executing raw SQL query: $sql" }
        driver.execute(null, sql, 0)
        logger.d { "Raw SQL query executed successfully" }
    }

    /**
     * Rebuilds the FTS5 index for the line_search table.
     * This should be called after all data has been inserted to ensure optimal search performance.
     */
    suspend fun rebuildFts5Index() = withContext(Dispatchers.IO) {
        logger.d { "Rebuilding FTS5 index for line_search table" }
        database.searchQueriesQueries.rebuildFts5Index()
        logger.d { "FTS5 index rebuilt successfully" }
    }

    /**
     * Updates the book_has_links table to indicate whether a book has source links, target links, or both.
     * 
     * @param bookId The ID of the book to update
     * @param hasSourceLinks Whether the book has source links (true) or not (false)
     * @param hasTargetLinks Whether the book has target links (true) or not (false)
     */
    suspend fun updateBookHasLinks(bookId: Long, hasSourceLinks: Boolean, hasTargetLinks: Boolean) = withContext(Dispatchers.IO) {
        logger.d { "Updating book_has_links for book $bookId: hasSourceLinks=$hasSourceLinks, hasTargetLinks=$hasTargetLinks" }
        val hasSourceLinksInt = if (hasSourceLinks) 1L else 0L
        val hasTargetLinksInt = if (hasTargetLinks) 1L else 0L

        // Use upsert to insert or update the book's link status
        database.bookHasLinksQueriesQueries.upsert(bookId, hasSourceLinksInt, hasTargetLinksInt)

        logger.d { "Updated book_has_links for book $bookId: hasSourceLinks=$hasSourceLinks, hasTargetLinks=$hasTargetLinks" }
    }

    /**
     * Updates only the source links status for a book.
     * 
     * @param bookId The ID of the book to update
     * @param hasSourceLinks Whether the book has source links (true) or not (false)
     */
    suspend fun updateBookSourceLinks(bookId: Long, hasSourceLinks: Boolean) = withContext(Dispatchers.IO) {
        logger.d { "Updating source links for book $bookId: hasSourceLinks=$hasSourceLinks" }
        val hasSourceLinksInt = if (hasSourceLinks) 1L else 0L

        // Update only the source links status
        database.bookHasLinksQueriesQueries.updateSourceLinks(hasSourceLinksInt, bookId)

        logger.d { "Updated source links for book $bookId: hasSourceLinks=$hasSourceLinks" }
    }

    /**
     * Updates only the target links status for a book.
     * 
     * @param bookId The ID of the book to update
     * @param hasTargetLinks Whether the book has target links (true) or not (false)
     */
    suspend fun updateBookTargetLinks(bookId: Long, hasTargetLinks: Boolean) = withContext(Dispatchers.IO) {
        logger.d { "Updating target links for book $bookId: hasTargetLinks=$hasTargetLinks" }
        val hasTargetLinksInt = if (hasTargetLinks) 1L else 0L

        // Update only the target links status
        database.bookHasLinksQueriesQueries.updateTargetLinks(hasTargetLinksInt, bookId)

        logger.d { "Updated target links for book $bookId: hasTargetLinks=$hasTargetLinks" }
    }

    /**
     * Checks if a book has any links (source or target).
     * 
     * @param bookId The ID of the book to check
     * @return True if the book has any links, false otherwise
     */
    suspend fun bookHasAnyLinks(bookId: Long): Boolean = withContext(Dispatchers.IO) {
        logger.d { "Checking if book $bookId has any links" }

        // Check if the book has any links as source or target
        val hasSourceLinks = bookHasSourceLinks(bookId)
        val hasTargetLinks = bookHasTargetLinks(bookId)
        val result = hasSourceLinks || hasTargetLinks

        logger.d { "Book $bookId has any links: $result" }
        result
    }

    /**
     * Checks if a book has source links.
     * 
     * @param bookId The ID of the book to check
     * @return True if the book has source links, false otherwise
     */
    suspend fun bookHasSourceLinks(bookId: Long): Boolean = withContext(Dispatchers.IO) {
        logger.d { "Checking if book $bookId has source links" }
        val count = countLinksBySourceBook(bookId)
        val result = count > 0
        logger.d { "Book $bookId has source links: $result" }
        result
    }

    /**
     * Checks if a book has target links.
     * 
     * @param bookId The ID of the book to check
     * @return True if the book has target links, false otherwise
     */
    suspend fun bookHasTargetLinks(bookId: Long): Boolean = withContext(Dispatchers.IO) {
        logger.d { "Checking if book $bookId has target links" }
        val count = countLinksByTargetBook(bookId)
        val result = count > 0
        logger.d { "Book $bookId has target links: $result" }
        result
    }

    /**
     * Gets all books that have any links (source or target).
     * 
     * @return A list of books that have any links
     */
    suspend fun getBooksWithAnyLinks(): List<Book> = withContext(Dispatchers.IO) {
        logger.d { "Getting all books with any links" }
        val books = database.bookHasLinksQueriesQueries.selectBooksWithAnyLinks().executeAsList()
        logger.d { "Found ${books.size} books with any links" }

        // Convert the database books to model books
        books.map { bookData ->
            val authors = getBookAuthors(bookData.id)
            val topics = getBookTopics(bookData.id)
            val pubPlaces = getBookPubPlaces(bookData.id)
            val pubDates = getBookPubDates(bookData.id)
            bookData.toModel(json, authors, pubPlaces, pubDates).copy(topics = topics)
        }
    }

    /**
     * Gets all books that have source links.
     * 
     * @return A list of books that have source links
     */
    suspend fun getBooksWithSourceLinks(): List<Book> = withContext(Dispatchers.IO) {
        logger.d { "Getting all books with source links" }
        val books = database.bookHasLinksQueriesQueries.selectBooksWithSourceLinks().executeAsList()
        logger.d { "Found ${books.size} books with source links" }

        // Convert the database books to model books
        books.map { bookData ->
            val authors = getBookAuthors(bookData.id)
            val topics = getBookTopics(bookData.id)
            val pubPlaces = getBookPubPlaces(bookData.id)
            val pubDates = getBookPubDates(bookData.id)
            bookData.toModel(json, authors, pubPlaces, pubDates).copy(topics = topics)
        }
    }

    /**
     * Gets all books that have target links.
     * 
     * @return A list of books that have target links
     */
    suspend fun getBooksWithTargetLinks(): List<Book> = withContext(Dispatchers.IO) {
        logger.d { "Getting all books with target links" }
        val books = database.bookHasLinksQueriesQueries.selectBooksWithTargetLinks().executeAsList()
        logger.d { "Found ${books.size} books with target links" }

        // Convert the database books to model books
        books.map { bookData ->
            val authors = getBookAuthors(bookData.id)
            val topics = getBookTopics(bookData.id)
            val pubPlaces = getBookPubPlaces(bookData.id)
            val pubDates = getBookPubDates(bookData.id)
            bookData.toModel(json, authors, pubPlaces, pubDates).copy(topics = topics)
        }
    }

    /**
     * Counts the number of books that have any links (source or target).
     * 
     * @return The number of books that have any links
     */
    suspend fun countBooksWithAnyLinks(): Long = withContext(Dispatchers.IO) {
        logger.d { "Counting books with any links" }
        val count = database.bookHasLinksQueriesQueries.countBooksWithAnyLinks().executeAsOne()
        logger.d { "Found $count books with any links" }
        count
    }

    /**
     * Counts the number of books that have source links.
     * 
     * @return The number of books that have source links
     */
    suspend fun countBooksWithSourceLinks(): Long = withContext(Dispatchers.IO) {
        logger.d { "Counting books with source links" }
        val count = database.bookHasLinksQueriesQueries.countBooksWithSourceLinks().executeAsOne()
        logger.d { "Found $count books with source links" }
        count
    }

    /**
     * Counts the number of books that have target links.
     * 
     * @return The number of books that have target links
     */
    suspend fun countBooksWithTargetLinks(): Long = withContext(Dispatchers.IO) {
        logger.d { "Counting books with target links" }
        val count = database.bookHasLinksQueriesQueries.countBooksWithTargetLinks().executeAsOne()
        logger.d { "Found $count books with target links" }
        count
    }


    /**
     * Gets all books from the database.
     * 
     * @return A list of all books
     */
    suspend fun getAllBooks(): List<Book> = withContext(Dispatchers.IO) {
        logger.d { "Getting all books" }
        val books = database.bookQueriesQueries.selectAll().executeAsList()
        logger.d { "Found ${books.size} books" }

        // Convert the database books to model books
        books.map { bookData ->
            val authors = getBookAuthors(bookData.id)
            val topics = getBookTopics(bookData.id)
            val pubPlaces = getBookPubPlaces(bookData.id)
            val pubDates = getBookPubDates(bookData.id)
            bookData.toModel(json, authors, pubPlaces, pubDates).copy(topics = topics)
        }
    }

    /**
     * Counts the number of links where the given book is the source.
     * 
     * @param bookId The ID of the book to count links for
     * @return The number of links where the book is the source
     */
    suspend fun countLinksBySourceBook(bookId: Long): Long = withContext(Dispatchers.IO) {
        logger.d { "Counting links where book $bookId is the source" }
        val count = database.linkQueriesQueries.countLinksBySourceBook(bookId).executeAsOne()
        logger.d { "Found $count links where book $bookId is the source" }
        count
    }

    /**
     * Counts the number of links where the given book is the target.
     * 
     * @param bookId The ID of the book to count links for
     * @return The number of links where the book is the target
     */
    suspend fun countLinksByTargetBook(bookId: Long): Long = withContext(Dispatchers.IO) {
        logger.d { "Counting links where book $bookId is the target" }
        val count = database.linkQueriesQueries.countLinksByTargetBook(bookId).executeAsOne()
        logger.d { "Found $count links where book $bookId is the target" }
        count
    }

    /**
     * Closes the database connection.
     * Should be called when the repository is no longer needed.
     */
    fun close() {
        driver.close()
    }
}

// Data classes for enriched results

/**
 * Information about a commentator (author who comments on other books).
 *
 * @property bookId The ID of the commentator's book
 * @property title The title of the commentator's book
 * @property author The name of the commentator
 * @property linkCount The number of links (comments) by this commentator
 */
data class CommentatorInfo(
    val bookId: Long,
    val title: String,
    val author: String?,
    val linkCount: Int
)

/**
 * A commentary with its text content.
 *
 * @property link The link connecting the source text to the commentary
 * @property targetBookTitle The title of the book containing the commentary
 * @property targetText The text of the commentary
 */
data class CommentaryWithText(
    val link: Link,
    val targetBookTitle: String,
    val targetText: String
)
</file>

<file path="lib/dao/src/commonMain/sqldelight/io/github/kdroidfilter/seforimlibrary/db/AuthorQueries.sq">
-- Queries for authors

selectAll:
SELECT * FROM author ORDER BY name;

selectById:
SELECT * FROM author WHERE id = ?;

selectByName:
SELECT * FROM author WHERE name = ? LIMIT 1;

selectByBookId:
SELECT a.* FROM author a
JOIN book_author ba ON a.id = ba.authorId
WHERE ba.bookId = ?
ORDER BY a.name;

insert:
INSERT INTO author (name)
VALUES (?)
ON CONFLICT (name) DO NOTHING;

insertAndGetId:
INSERT OR IGNORE INTO author (name)
VALUES (?);

selectIdByName:
SELECT id FROM author WHERE name = ? LIMIT 1;

delete:
DELETE FROM author WHERE id = ?;

countAll:
SELECT COUNT(*) FROM author;

lastInsertRowId:
SELECT last_insert_rowid();

-- Queries for the book_author junction table

linkBookAuthor:
INSERT INTO book_author (bookId, authorId)
VALUES (?, ?)
ON CONFLICT (bookId, authorId) DO NOTHING;

unlinkBookAuthor:
DELETE FROM book_author WHERE bookId = ? AND authorId = ?;

deleteAllBookAuthors:
DELETE FROM book_author WHERE bookId = ?;

countBookAuthors:
SELECT COUNT(*) FROM book_author WHERE bookId = ?;
</file>

<file path="lib/dao/src/commonMain/sqldelight/io/github/kdroidfilter/seforimlibrary/db/BookHasLinksQueries.sq">
-- Queries for the book_has_links table

-- Get link status for a book
selectByBookId:
SELECT bookId, hasSourceLinks, hasTargetLinks
FROM book_has_links
WHERE bookId = ?;

-- Get all books that have source links
selectBooksWithSourceLinks:
SELECT b.*
FROM book b
JOIN book_has_links bhl ON b.id = bhl.bookId
WHERE bhl.hasSourceLinks = 1;

-- Get all books that have target links
selectBooksWithTargetLinks:
SELECT b.*
FROM book b
JOIN book_has_links bhl ON b.id = bhl.bookId
WHERE bhl.hasTargetLinks = 1;

-- Get all books that have any links (source or target)
selectBooksWithAnyLinks:
SELECT b.*
FROM book b
JOIN book_has_links bhl ON b.id = bhl.bookId
WHERE bhl.hasSourceLinks = 1 OR bhl.hasTargetLinks = 1;

-- Count books with source links
countBooksWithSourceLinks:
SELECT COUNT(*)
FROM book_has_links
WHERE hasSourceLinks = 1;

-- Count books with target links
countBooksWithTargetLinks:
SELECT COUNT(*)
FROM book_has_links
WHERE hasTargetLinks = 1;

-- Count books with any links (source or target)
countBooksWithAnyLinks:
SELECT COUNT(*)
FROM book_has_links
WHERE hasSourceLinks = 1 OR hasTargetLinks = 1;

-- Insert or update a book's link status
upsert:
INSERT OR REPLACE INTO book_has_links (bookId, hasSourceLinks, hasTargetLinks)
VALUES (?, ?, ?);

-- Update a book's source link status
updateSourceLinks:
UPDATE book_has_links
SET hasSourceLinks = ?
WHERE bookId = ?;

-- Update a book's target link status
updateTargetLinks:
UPDATE book_has_links
SET hasTargetLinks = ?
WHERE bookId = ?;

-- Update both source and target link status
updateBothLinkTypes:
UPDATE book_has_links
SET hasSourceLinks = ?,
    hasTargetLinks = ?
WHERE bookId = ?;

-- Insert a new book link status
insert:
INSERT INTO book_has_links (bookId, hasSourceLinks, hasTargetLinks)
VALUES (?, ?, ?);

-- Delete a book's link status
delete:
DELETE FROM book_has_links
WHERE bookId = ?;

-- Get the last inserted row ID
lastInsertRowId:
SELECT last_insert_rowid();
</file>

<file path="lib/dao/src/commonMain/sqldelight/io/github/kdroidfilter/seforimlibrary/db/BookQueries.sq">
-- Queries for books

selectAll:
SELECT * FROM book ORDER BY orderIndex, title;

selectById:
SELECT * FROM book WHERE id = ?;

selectByCategoryId:
SELECT * FROM book WHERE categoryId = ? ORDER BY orderIndex, title;

selectByTitle:
SELECT * FROM book WHERE title = ? LIMIT 1;


selectByAuthor:
SELECT b.* FROM book b
JOIN book_author ba ON b.id = ba.bookId
JOIN author a ON ba.authorId = a.id
WHERE a.name LIKE ? 
ORDER BY b.orderIndex, b.title;

insert:
INSERT INTO book (categoryId, title, heShortDesc, orderIndex, totalLines)
VALUES (?, ?, ?, ?, ?);

insertWithId:
INSERT INTO book (id, categoryId, title, heShortDesc, orderIndex, totalLines)
VALUES (?, ?, ?, ?, ?, ?);

updateTotalLines:
UPDATE book SET totalLines = ? WHERE id = ?;

delete:
DELETE FROM book WHERE id = ?;

countByCategoryId:
SELECT COUNT(*) FROM book WHERE categoryId = ?;

countAll:
SELECT COUNT(*) FROM book;

getMaxId:
SELECT MAX(id) FROM book;

updateCategoryId:
UPDATE book SET categoryId = ? WHERE id = ?;

lastInsertRowId:
SELECT last_insert_rowid();
</file>

<file path="lib/dao/src/commonMain/sqldelight/io/github/kdroidfilter/seforimlibrary/db/CategoryQueries.sq">
-- Queries for categories

selectAll:
SELECT * FROM category ORDER BY title;

selectById:
SELECT * FROM category WHERE id = ?;

selectByParentId:
SELECT * FROM category WHERE parentId = ? ORDER BY title;

selectRoot:
SELECT * FROM category WHERE parentId IS NULL ORDER BY title;

insert:
INSERT INTO category (parentId, title, level)
VALUES (?, ?, ?);

update:
UPDATE category SET
    title = ?
WHERE id = ?;

delete:
DELETE FROM category WHERE id = ?;

countAll:
SELECT COUNT(*) FROM category;

lastInsertRowId:
SELECT last_insert_rowid();
</file>

<file path="lib/dao/src/commonMain/sqldelight/io/github/kdroidfilter/seforimlibrary/db/ConnectionTypeQueries.sq">
-- Queries for connection types

selectById:
SELECT * FROM connection_type WHERE id = ?;

selectByName:
SELECT * FROM connection_type WHERE name = ?;

selectAll:
SELECT * FROM connection_type ORDER BY name;

insert:
INSERT INTO connection_type (name)
VALUES (?);

update:
UPDATE connection_type
SET name = ?
WHERE id = ?;

delete:
DELETE FROM connection_type WHERE id = ?;

lastInsertRowId:
SELECT last_insert_rowid();
</file>

<file path="lib/dao/src/commonMain/sqldelight/io/github/kdroidfilter/seforimlibrary/db/Database.sq">
-- Categories table
CREATE TABLE IF NOT EXISTS category (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    parentId INTEGER,
    title TEXT NOT NULL,
    level INTEGER NOT NULL DEFAULT 0,
    FOREIGN KEY (parentId) REFERENCES category(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_category_parent ON category(parentId);

-- Authors table
CREATE TABLE IF NOT EXISTS author (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE
);

CREATE INDEX IF NOT EXISTS idx_author_name ON author(name);

-- Table des topics
CREATE TABLE IF NOT EXISTS topic (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE
);

CREATE INDEX IF NOT EXISTS idx_topic_name ON topic(name);

-- Publication places table
CREATE TABLE IF NOT EXISTS pub_place (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE
);

CREATE INDEX IF NOT EXISTS idx_pub_place_name ON pub_place(name);

-- Publication dates table
CREATE TABLE IF NOT EXISTS pub_date (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    date TEXT NOT NULL UNIQUE
);

CREATE INDEX IF NOT EXISTS idx_pub_date_date ON pub_date(date);

-- Books table
CREATE TABLE IF NOT EXISTS book (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    categoryId INTEGER NOT NULL,
    title TEXT NOT NULL,
    heShortDesc TEXT,
    orderIndex INTEGER NOT NULL DEFAULT 999,
    totalLines INTEGER NOT NULL DEFAULT 0,
    FOREIGN KEY (categoryId) REFERENCES category(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_book_category ON book(categoryId);
CREATE INDEX IF NOT EXISTS idx_book_title ON book(title);
CREATE INDEX IF NOT EXISTS idx_book_order ON book(orderIndex);

-- Book-publication place junction table
CREATE TABLE IF NOT EXISTS book_pub_place (
    bookId INTEGER NOT NULL,
    pubPlaceId INTEGER NOT NULL,
    PRIMARY KEY (bookId, pubPlaceId),
    FOREIGN KEY (bookId) REFERENCES book(id) ON DELETE CASCADE,
    FOREIGN KEY (pubPlaceId) REFERENCES pub_place(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_book_pub_place_book ON book_pub_place(bookId);
CREATE INDEX IF NOT EXISTS idx_book_pub_place_place ON book_pub_place(pubPlaceId);

-- Book-publication date junction table
CREATE TABLE IF NOT EXISTS book_pub_date (
    bookId INTEGER NOT NULL,
    pubDateId INTEGER NOT NULL,
    PRIMARY KEY (bookId, pubDateId),
    FOREIGN KEY (bookId) REFERENCES book(id) ON DELETE CASCADE,
    FOREIGN KEY (pubDateId) REFERENCES pub_date(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_book_pub_date_book ON book_pub_date(bookId);
CREATE INDEX IF NOT EXISTS idx_book_pub_date_date ON book_pub_date(pubDateId);

-- Book-topic junction table
CREATE TABLE IF NOT EXISTS book_topic (
    bookId INTEGER NOT NULL,
    topicId INTEGER NOT NULL,
    PRIMARY KEY (bookId, topicId),
    FOREIGN KEY (bookId) REFERENCES book(id) ON DELETE CASCADE,
    FOREIGN KEY (topicId) REFERENCES topic(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_book_topic_book ON book_topic(bookId);
CREATE INDEX IF NOT EXISTS idx_book_topic_topic ON book_topic(topicId);

-- Book-author junction table
CREATE TABLE IF NOT EXISTS book_author (
    bookId INTEGER NOT NULL,
    authorId INTEGER NOT NULL,
    PRIMARY KEY (bookId, authorId),
    FOREIGN KEY (bookId) REFERENCES book(id) ON DELETE CASCADE,
    FOREIGN KEY (authorId) REFERENCES author(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_book_author_book ON book_author(bookId);
CREATE INDEX IF NOT EXISTS idx_book_author_author ON book_author(authorId);

-- Lines table
CREATE TABLE IF NOT EXISTS line (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    bookId INTEGER NOT NULL,
    lineIndex INTEGER NOT NULL,
    content TEXT NOT NULL,
    plainText TEXT NOT NULL,
    tocEntryId INTEGER,
    FOREIGN KEY (bookId) REFERENCES book(id) ON DELETE CASCADE,
    FOREIGN KEY (tocEntryId) REFERENCES tocEntry(id) ON DELETE SET NULL
);

CREATE INDEX IF NOT EXISTS idx_line_book_index ON line(bookId, lineIndex);
CREATE INDEX IF NOT EXISTS idx_line_toc ON line(tocEntryId);

-- TOC texts table
CREATE TABLE IF NOT EXISTS tocText (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    text TEXT NOT NULL UNIQUE
);

CREATE INDEX IF NOT EXISTS idx_toc_text ON tocText(text);
CREATE INDEX IF NOT EXISTS idx_toctext_text_length ON tocText(text, length(text));

-- TOC entries table
CREATE TABLE IF NOT EXISTS tocEntry (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    bookId INTEGER NOT NULL,
    parentId INTEGER,
    textId INTEGER NOT NULL,
    level INTEGER NOT NULL,
    lineId INTEGER,
    FOREIGN KEY (bookId) REFERENCES book(id) ON DELETE CASCADE,
    FOREIGN KEY (parentId) REFERENCES tocEntry(id) ON DELETE CASCADE,
    FOREIGN KEY (textId) REFERENCES tocText(id) ON DELETE CASCADE,
    FOREIGN KEY (lineId) REFERENCES line(id) ON DELETE SET NULL
);

CREATE INDEX IF NOT EXISTS idx_toc_book ON tocEntry(bookId);
CREATE INDEX IF NOT EXISTS idx_toc_parent ON tocEntry(parentId);
CREATE INDEX IF NOT EXISTS idx_toc_text_id ON tocEntry(textId);
CREATE INDEX IF NOT EXISTS idx_toc_line ON tocEntry(lineId);
CREATE INDEX IF NOT EXISTS idx_tocentry_text_level ON tocEntry(textId, level);
CREATE INDEX IF NOT EXISTS idx_tocentry_level_book ON tocEntry(level, bookId);

-- Connection types table
CREATE TABLE IF NOT EXISTS connection_type (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE
);

CREATE INDEX IF NOT EXISTS idx_connection_type_name ON connection_type(name);

-- Links table
CREATE TABLE IF NOT EXISTS link (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    sourceBookId INTEGER NOT NULL,
    targetBookId INTEGER NOT NULL,
    sourceLineId INTEGER NOT NULL,
    targetLineId INTEGER NOT NULL,
    connectionTypeId INTEGER NOT NULL,
    FOREIGN KEY (sourceBookId) REFERENCES book(id) ON DELETE CASCADE,
    FOREIGN KEY (targetBookId) REFERENCES book(id) ON DELETE CASCADE,
    FOREIGN KEY (sourceLineId) REFERENCES line(id) ON DELETE CASCADE,
    FOREIGN KEY (targetLineId) REFERENCES line(id) ON DELETE CASCADE,
    FOREIGN KEY (connectionTypeId) REFERENCES connection_type(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_link_source_book ON link(sourceBookId);
CREATE INDEX IF NOT EXISTS idx_link_source_line ON link(sourceLineId);
CREATE INDEX IF NOT EXISTS idx_link_target_book ON link(targetBookId);
CREATE INDEX IF NOT EXISTS idx_link_target_line ON link(targetLineId);
CREATE INDEX IF NOT EXISTS idx_link_type ON link(connectionTypeId);

-- View for FTS5 content source that includes book title
CREATE VIEW IF NOT EXISTS line_with_book_title AS
SELECT 
    l.id,
    l.bookId,
    l.lineIndex,
    b.title AS bookTitle,
    l.plainText
FROM line l
JOIN book b ON l.bookId = b.id;

-- FTS5 virtual table for line search using external content
CREATE VIRTUAL TABLE IF NOT EXISTS line_search USING fts5(
    bookId INTEGER UNINDEXED,
    id INTEGER UNINDEXED,
    lineIndex INTEGER UNINDEXED,
    bookTitle TEXT UNINDEXED,
    plainText TEXT,
    content='line_with_book_title',
    content_rowid='id'
);

-- Table to track whether books have links (as source or target)
CREATE TABLE IF NOT EXISTS book_has_links (
    bookId INTEGER PRIMARY KEY,
    hasSourceLinks INTEGER NOT NULL DEFAULT 0, -- 0 = false, 1 = true
    hasTargetLinks INTEGER NOT NULL DEFAULT 0, -- 0 = false, 1 = true
    FOREIGN KEY (bookId) REFERENCES book(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_book_has_source_links ON book_has_links(hasSourceLinks);
CREATE INDEX IF NOT EXISTS idx_book_has_target_links ON book_has_links(hasTargetLinks);
</file>

<file path="lib/dao/src/commonMain/sqldelight/io/github/kdroidfilter/seforimlibrary/db/LineQueries.sq">
-- Queries for lines

selectById:
SELECT * FROM line WHERE id = ?;

selectByBookId:
SELECT * FROM line WHERE bookId = ? ORDER BY lineIndex;

selectByBookIdRange:
SELECT * FROM line
WHERE bookId = ?
AND lineIndex >= ?
AND lineIndex <= ?
ORDER BY lineIndex;

selectByBookIdAndIndex:
SELECT * FROM line WHERE bookId = ? AND lineIndex = ?;

insert:
INSERT INTO line (bookId, lineIndex, content, plainText, tocEntryId)
VALUES (?, ?, ?, ?, ?);

insertWithId:
INSERT INTO line (id, bookId, lineIndex, content, plainText, tocEntryId)
VALUES (?, ?, ?, ?, ?, ?);

updateTocEntryId:
UPDATE line SET tocEntryId = ? WHERE id = ?;

delete:
DELETE FROM line WHERE id = ?;

deleteByBookId:
DELETE FROM line WHERE bookId = ?;

countByBookId:
SELECT COUNT(*) FROM line WHERE bookId = ?;

lastInsertRowId:
SELECT last_insert_rowid();
</file>

<file path="lib/dao/src/commonMain/sqldelight/io/github/kdroidfilter/seforimlibrary/db/LinkQueries.sq">
-- Queries for links

selectLinkById:
SELECT l.*, ct.name AS connectionType
FROM link l
JOIN connection_type ct ON l.connectionTypeId = ct.id
WHERE l.id = ?;

countAllLinks:
SELECT COUNT(*) FROM link;

selectLinksBySourceLineIds:
SELECT l.*, ct.name AS connectionType, b.title AS targetBookTitle, tl.plainText AS targetText
FROM link l
JOIN connection_type ct ON l.connectionTypeId = ct.id
JOIN book b ON l.targetBookId = b.id
JOIN line tl ON l.targetLineId = tl.id
WHERE l.sourceLineId IN ?
ORDER BY b.orderIndex;

selectLinksBySourceBook:
SELECT l.*, ct.name AS connectionType
FROM link l
JOIN connection_type ct ON l.connectionTypeId = ct.id
WHERE l.sourceBookId = ?;

selectCommentatorsByBook:
SELECT DISTINCT l.targetBookId, b.title AS targetBookTitle, a.name AS author, COUNT(*) AS linkCount
FROM link l
JOIN connection_type ct ON l.connectionTypeId = ct.id
JOIN book b ON l.targetBookId = b.id
LEFT JOIN book_author ba ON b.id = ba.bookId
LEFT JOIN author a ON ba.authorId = a.id
WHERE l.sourceBookId = ?
AND ct.name IN ('COMMENTARY', 'TARGUM')
GROUP BY l.targetBookId, b.title, a.name
ORDER BY b.orderIndex, b.title;

insert:
INSERT INTO link (sourceBookId, targetBookId, sourceLineId, targetLineId, connectionTypeId)
VALUES (?, ?, ?, ?, ?);

delete:
DELETE FROM link WHERE id = ?;

deleteByBookId:
DELETE FROM link WHERE sourceBookId = ? OR targetBookId = ?;

lastInsertRowId:
SELECT last_insert_rowid();

-- Count links by source book
countLinksBySourceBook:
SELECT COUNT(*) FROM link WHERE sourceBookId = ?;

-- Count links by target book
countLinksByTargetBook:
SELECT COUNT(*) FROM link WHERE targetBookId = ?;
</file>

<file path="lib/dao/src/commonMain/sqldelight/io/github/kdroidfilter/seforimlibrary/db/PubDateQueries.sq">
-- Queries for publication dates

selectAll:
SELECT * FROM pub_date ORDER BY date;

selectById:
SELECT * FROM pub_date WHERE id = ?;

selectByDate:
SELECT * FROM pub_date WHERE date = ? LIMIT 1;

selectByBookId:
SELECT p.* FROM pub_date p
JOIN book_pub_date bp ON p.id = bp.pubDateId
WHERE bp.bookId = ?;

insert:
INSERT INTO pub_date (date)
VALUES (?)
ON CONFLICT (date) DO NOTHING;

linkBookPubDate:
INSERT INTO book_pub_date (bookId, pubDateId)
VALUES (?, ?)
ON CONFLICT (bookId, pubDateId) DO NOTHING;

delete:
DELETE FROM pub_date WHERE id = ?;

countAll:
SELECT COUNT(*) FROM pub_date;

lastInsertRowId:
SELECT last_insert_rowid();
</file>

<file path="lib/dao/src/commonMain/sqldelight/io/github/kdroidfilter/seforimlibrary/db/PubPlaceQueries.sq">
-- Queries for publication places

selectAll:
SELECT * FROM pub_place ORDER BY name;

selectById:
SELECT * FROM pub_place WHERE id = ?;

selectByName:
SELECT * FROM pub_place WHERE name = ? LIMIT 1;

selectByBookId:
SELECT p.* FROM pub_place p
JOIN book_pub_place bp ON p.id = bp.pubPlaceId
WHERE bp.bookId = ?;

insert:
INSERT INTO pub_place (name)
VALUES (?)
ON CONFLICT (name) DO NOTHING;

linkBookPubPlace:
INSERT INTO book_pub_place (bookId, pubPlaceId)
VALUES (?, ?)
ON CONFLICT (bookId, pubPlaceId) DO NOTHING;

delete:
DELETE FROM pub_place WHERE id = ?;

countAll:
SELECT COUNT(*) FROM pub_place;

lastInsertRowId:
SELECT last_insert_rowid();
</file>

<file path="lib/dao/src/commonMain/sqldelight/io/github/kdroidfilter/seforimlibrary/db/SearchQueries.sq">
-- Requêtes FTS5 mises à jour pour utiliser plainText

-- Recherche globale avec FTS5
searchAll:
SELECT
    ls.bookId,
    ls.bookTitle,
    ls.id,
    ls.lineIndex,
    snippet(line_search, 4, '<b>', '</b>', '...', 10) snippet, -- colonne 4 = plainText
    bm25(line_search) rank -- Utilisation de bm25 pour un meilleur ranking
FROM line_search ls
WHERE ls.plainText MATCH ?
ORDER BY rank
LIMIT ? OFFSET ?;

-- Recherche dans un livre spécifique
searchInBook:
SELECT
    ls.bookId,
    ls.bookTitle,
    ls.id,
    ls.lineIndex,
    snippet(line_search, 4, '<b>', '</b>', '...', 10) snippet,
    bm25(line_search) rank
FROM line_search ls
WHERE ls.plainText MATCH ? AND ls.bookId = ?
ORDER BY rank
LIMIT ? OFFSET ?;

-- Recherche par auteur
searchByAuthor:
SELECT
    ls.bookId,
    ls.bookTitle,
    ls.id,
    ls.lineIndex,
    snippet(line_search, 4, '<b>', '</b>', '...', 10) snippet,
    bm25(line_search) rank
FROM line_search ls
JOIN book_author ba ON ls.bookId = ba.bookId
JOIN author a ON ba.authorId = a.id
WHERE ls.plainText MATCH ? AND a.name = ?
ORDER BY rank
LIMIT ? OFFSET ?;

-- Recherche avec filtre sur le titre du livre
searchWithBookFilter:
SELECT
    ls.bookId,
    ls.bookTitle,
    ls.id,
    ls.lineIndex,
    snippet(line_search, 4, '<b>', '</b>', '...', 10) snippet,
    bm25(line_search) rank
FROM line_search ls
WHERE ls.plainText MATCH ?
AND ls.bookTitle MATCH ?
ORDER BY rank
LIMIT ? OFFSET ?;

-- Recherche avec phrase exacte
searchExactPhrase:
SELECT
    ls.bookId,
    ls.bookTitle,
    ls.id,
    ls.lineIndex,
    snippet(line_search, 4, '<b>', '</b>', '...', 10) snippet,
    bm25(line_search) rank
FROM line_search ls
WHERE ls.plainText MATCH '"' || ? || '"'
ORDER BY rank
LIMIT ? OFFSET ?;

-- Recherche avec opérateurs booléens
searchWithOperators:
SELECT
    ls.bookId,
    ls.bookTitle,
    ls.id,
    ls.lineIndex,
    snippet(line_search, 4, '<b>', '</b>', '...', 10) snippet,
    bm25(line_search) rank
FROM line_search ls
WHERE ls.plainText MATCH ?
ORDER BY rank
LIMIT ? OFFSET ?;

-- Compter les résultats de recherche
countSearchResults:
SELECT COUNT(*)
FROM line_search
WHERE plainText MATCH ?;

-- Compter les résultats dans un livre spécifique
countSearchResultsInBook:
SELECT COUNT(*)
FROM line_search
WHERE plainText MATCH ? AND bookId = ?;

-- Rebuild the FTS5 index
rebuildFts5Index:
INSERT INTO line_search(line_search) VALUES('rebuild');
</file>

<file path="lib/dao/src/commonMain/sqldelight/io/github/kdroidfilter/seforimlibrary/db/TocQueries.sq">
-- Queries for table of contents

selectByBookId:
SELECT t.*, tt.text
FROM tocEntry t
JOIN tocText tt ON t.textId = tt.id
WHERE t.bookId = ?;

selectTocById:
SELECT t.*, tt.text
FROM tocEntry t
JOIN tocText tt ON t.textId = tt.id
WHERE t.id = ?;

selectRootByBookId:
SELECT t.*, tt.text
FROM tocEntry t
JOIN tocText tt ON t.textId = tt.id
WHERE t.bookId = ? AND t.parentId IS NULL;

selectChildren:
SELECT t.*, tt.text
FROM tocEntry t
JOIN tocText tt ON t.textId = tt.id
WHERE t.parentId = ?;

selectByLineId:
SELECT t.*, tt.text
FROM tocEntry t
JOIN tocText tt ON t.textId = tt.id
WHERE t.lineId = ?;

insert:
INSERT INTO tocEntry (bookId, parentId, textId, level, lineId)
VALUES (?, ?, ?, ?, ?);

insertWithId:
INSERT INTO tocEntry (id, bookId, parentId, textId, level, lineId)
VALUES (?, ?, ?, ?, ?, ?);

updateLineId:
UPDATE tocEntry SET lineId = ? WHERE id = ?;

delete:
DELETE FROM tocEntry WHERE id = ?;

deleteByBookId:
DELETE FROM tocEntry WHERE bookId = ?;

lastInsertRowId:
SELECT last_insert_rowid();
</file>

<file path="lib/dao/src/commonMain/sqldelight/io/github/kdroidfilter/seforimlibrary/db/TocTextQueries.sq">
-- Queries for table of contents texts

selectAll:
SELECT * FROM tocText ORDER BY text;

selectById:
SELECT * FROM tocText WHERE id = ?;

selectByText:
SELECT * FROM tocText WHERE text = ? LIMIT 1;

insert:
INSERT INTO tocText (text)
VALUES (?)
ON CONFLICT (text) DO NOTHING;

insertAndGetId:
INSERT OR IGNORE INTO tocText (text)
VALUES (?);

selectIdByText:
SELECT id FROM tocText WHERE text = ? LIMIT 1;

delete:
DELETE FROM tocText WHERE id = ?;

countAll:
SELECT COUNT(*) FROM tocText;

lastInsertRowId:
SELECT last_insert_rowid();
</file>

<file path="lib/dao/src/commonMain/sqldelight/io/github/kdroidfilter/seforimlibrary/db/TopicQueries.sq">
-- Requêtes pour les topics

selectAll:
SELECT * FROM topic ORDER BY name;

selectById:
SELECT * FROM topic WHERE id = ?;

selectByName:
SELECT * FROM topic WHERE name = ? LIMIT 1;

selectByBookId:
SELECT t.* FROM topic t
JOIN book_topic bt ON t.id = bt.topicId
WHERE bt.bookId = ?
ORDER BY t.name;

insert:
INSERT INTO topic (name)
VALUES (?)
ON CONFLICT (name) DO NOTHING;

insertAndGetId:
INSERT OR IGNORE INTO topic (name)
VALUES (?);

selectIdByName:
SELECT id FROM topic WHERE name = ? LIMIT 1;

delete:
DELETE FROM topic WHERE id = ?;

countAll:
SELECT COUNT(*) FROM topic;

lastInsertRowId:
SELECT last_insert_rowid();

-- Requêtes pour la table de jonction book_topic

linkBookTopic:
INSERT INTO book_topic (bookId, topicId)
VALUES (?, ?)
ON CONFLICT (bookId, topicId) DO NOTHING;

unlinkBookTopic:
DELETE FROM book_topic WHERE bookId = ? AND topicId = ?;

deleteAllBookTopics:
DELETE FROM book_topic WHERE bookId = ?;

countBookTopics:
SELECT COUNT(*) FROM book_topic WHERE bookId = ?;
</file>

<file path="lib/dao/build.gradle.kts">
import com.vanniktech.maven.publish.SonatypeHost

plugins {
    alias(libs.plugins.multiplatform)
    alias(libs.plugins.android.library)
    alias(libs.plugins.maven.publish)
    alias(libs.plugins.kotlinx.serialization)
    alias(libs.plugins.sqlDelight)
}

kotlin {
    jvmToolchain(17)

    androidTarget { publishLibraryVariants("release") }
    jvm()

    sourceSets {
        commonMain.dependencies {
            api(project(":core"))
            implementation(libs.kotlinx.coroutines.core)
            implementation(libs.kotlinx.coroutines.test)
            implementation(libs.kotlinx.serialization.json)
            implementation(libs.kotlinx.datetime)
            implementation(libs.kermit)
        }

        commonTest.dependencies {
            implementation(kotlin("test"))
        }

        androidMain.dependencies {
            implementation(libs.kotlinx.coroutines.android)
            implementation(libs.sqlDelight.driver.android)
        }

        jvmMain.dependencies {
            implementation(libs.kotlinx.coroutines.swing)
            implementation(libs.sqlDelight.driver.sqlite)
        }

    }

}

android {
    namespace = "io.github.kdroidfilter.seforimlibrary"
    compileSdk = 35

    defaultConfig {
        minSdk = 21
    }
}


//Publishing your Kotlin Multiplatform library to Maven Central
//https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-publish-libraries.html
mavenPublishing {
    publishToMavenCentral(SonatypeHost.CENTRAL_PORTAL)
    coordinates("io.github.kdroidfilter.seforimlibrary", "dao", "1.0.0")

    pom {
        name = "SeforimLibraryDao"
        description = "Kotlin Multiplatform library"
        url = "github url" //todo

        licenses {
            license {
                name = "MIT"
                url = "https://opensource.org/licenses/MIT"
            }
        }

        developers {
            developer {
                id = "" //todo
                name = "" //todo
                email = "" //todo
            }
        }

        scm {
            url = "github url" //todo
        }
    }
    if (project.hasProperty("signing.keyId")) signAllPublications()
}

sqldelight {
    databases {
        create("SeforimDb") {
            // Database configuration here.
            // https://cashapp.github.io/sqldelight
            packageName.set("io.github.kdroidfilter.seforimlibrary.db")
            dialect("app.cash.sqldelight:sqlite-3-24-dialect:${libs.versions.sqlDelight.get()}")
        }
    }
}
</file>

<file path="lib/generator/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/generator/Generator.kt">
package io.github.kdroidfilter.seforimlibrary.generator


import co.touchlab.kermit.Logger
import io.github.kdroidfilter.seforimlibrary.core.models.*
import io.github.kdroidfilter.seforimlibrary.dao.repository.SeforimRepository
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.runBlocking
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import org.jsoup.Jsoup
import org.jsoup.safety.Safelist
import java.io.File
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import kotlin.io.path.exists
import kotlin.io.path.extension
import kotlin.io.path.nameWithoutExtension
import kotlin.io.path.readText

/**
 * DatabaseGenerator is responsible for generating the Otzaria database from source files.
 * It processes directories, books, and links to create a structured database.
 *
 * @property sourceDirectory The path to the source directory containing the data files
 * @property repository The repository used to store the generated data
 */
class DatabaseGenerator(
    private val sourceDirectory: Path,
    private val repository: SeforimRepository
) {

    private val logger = Logger.withTag("DatabaseGenerator")


    private val json = Json {
        ignoreUnknownKeys = true
        coerceInputValues = true
    }
    private var nextBookId = 1L // Counter for book IDs
    private var nextLineId = 1L // Counter for line IDs
    private var nextTocEntryId = 1L // Counter for TOC entry IDs


    /**
     * Generates the database by processing metadata, directories, and links.
     * This is the main entry point for the database generation process.
     */
    suspend fun generate(): Unit = coroutineScope {
        logger.i { "Starting database generation..." }
        logger.i { "Source directory: $sourceDirectory" }

        try {
            // Disable foreign keys for better performance during bulk insertion
            logger.i { "Disabling foreign keys for better performance..." }
            disableForeignKeys()

            // Load metadata
            val metadata = loadMetadata()
            logger.i { "Metadata loaded: ${metadata.size} entries" }

            // Process hierarchy
            val libraryPath = sourceDirectory.resolve("אוצריא")
            if (!libraryPath.exists()) {
                throw IllegalStateException("The directory אוצריא does not exist in $sourceDirectory")
            }

            logger.i { "🚀 Starting to process library directory: $libraryPath" }
            processDirectory(libraryPath, null, 0, metadata)

            // Process links
            processLinks()

            // Re-enable foreign keys after all data is inserted
            logger.i { "Re-enabling foreign keys..." }
            enableForeignKeys()

            // Rebuild FTS5 index
            logger.i { "Rebuilding FTS5 index..." }
            rebuildFts5Index()

            logger.i { "Generation completed successfully!" }
        } catch (e: Exception) {
            // Make sure to re-enable foreign keys even if an error occurs
            try {
                enableForeignKeys()
            } catch (innerEx: Exception) {
                logger.w(innerEx) { "Error re-enabling foreign keys after failure" }
            }

            logger.e(e) { "Error during generation" }
            throw e
        }
    }

    /**
     * Loads book metadata from the metadata.json file.
     * Attempts to parse the file in different formats (Map or List).
     *
     * @return A map of book titles to their metadata
     */
    private suspend fun loadMetadata(): Map<String, BookMetadata> {
        val metadataFile = sourceDirectory.resolve("metadata.json")
        return if (metadataFile.exists()) {
            val content = metadataFile.readText()
            try {
                // Try to parse as Map first (original format)
                json.decodeFromString<Map<String, BookMetadata>>(content)
            } catch (e: Exception) {
                // If that fails, try to parse as List and convert to Map
                try {
                    val metadataList = json.decodeFromString<List<BookMetadata>>(content)
                    logger.i { "Parsed metadata as List with ${metadataList.size} entries" }
                    // Convert list to map using title as key
                    metadataList.associateBy { it.title }
                } catch (e: Exception) {
                    logger.i(e) { "Failed to parse metadata.json" }
                    emptyMap()
                }
            }
        } else {
            logger.w { "Metadata file metadata.json not found" }
            emptyMap()
        }
    }


    /**
     * Processes a directory recursively, creating categories and books.
     *
     * @param directory The directory to process
     * @param parentCategoryId The ID of the parent category, if any
     * @param level The current level in the directory hierarchy
     * @param metadata The metadata for books
     */
    private suspend fun processDirectory(
        directory: Path,
        parentCategoryId: Long?,
        level: Int,
        metadata: Map<String, BookMetadata>
    ) {
        logger.i { "=== Processing directory: ${directory.fileName} with parentCategoryId: $parentCategoryId (level: $level) ===" }

        Files.list(directory).use { stream ->
            val entries = stream.sorted { a, b ->
                a.fileName.toString().compareTo(b.fileName.toString())
            }.toList()

            logger.d { "Found ${entries.size} entries in directory ${directory.fileName}" }

            for (entry in entries) {
                when {
                    Files.isDirectory(entry) -> {
                        logger.d { "Processing subdirectory: ${entry.fileName} with parentId: $parentCategoryId" }
                        val categoryId = createCategory(entry, parentCategoryId, level)
                        logger.i { "✅ Created category '${entry.fileName}' with ID: $categoryId (parent: $parentCategoryId)" }
                        processDirectory(entry, categoryId, level + 1, metadata)
                    }

                    Files.isRegularFile(entry) && entry.extension == "txt" -> {
                        if (parentCategoryId == null) {
                            logger.w { "❌ Book found without category: $entry" }
                            continue
                        }
                        logger.i { "📚 Processing book ${entry.fileName} with categoryId: $parentCategoryId" }
                        createAndProcessBook(entry, parentCategoryId, metadata)
                    }

                    else -> {
                        logger.d { "Skipping entry: ${entry.fileName} (not a supported file type)" }
                    }
                }
            }
        }
        logger.i { "=== Finished processing directory: ${directory.fileName} ===" }
    }

    /**
     * Creates a category in the database.
     *
     * @param path The path representing the category
     * @param parentId The ID of the parent category, if any
     * @param level The level in the category hierarchy
     * @return The ID of the created category
     */
    private suspend fun createCategory(
        path: Path,
        parentId: Long?,
        level: Int
    ): Long {
        val title = path.fileName.toString()
        logger.i { "🏗️ Creating category: '$title' (level $level, parent: $parentId)" }

        val category = Category(
            parentId = parentId,
            title = title,
            level = level
        )

        val insertedId = repository.insertCategory(category)
        logger.i { "✅ Category '$title' created with ID: $insertedId" }

        // Additional verification
        val insertedCategory = repository.getCategory(insertedId)
        if (insertedCategory == null) {
            // Changed from error to warning level to reduce unnecessary error logs
            logger.w { "❌ WARNING: Unable to retrieve the category that was just inserted (ID: $insertedId)" }
        } else {
            logger.d { "✅ Verification: category retrieved with ID: ${insertedCategory.id}, parent: ${insertedCategory.parentId}" }
        }

        return insertedId
    }


    /**
     * Creates a book in the database and processes its content.
     *
     * @param path The path to the book file
     * @param categoryId The ID of the category the book belongs to
     * @param metadata The metadata for the book
     */
    private suspend fun createAndProcessBook(
        path: Path,
        categoryId: Long,
        metadata: Map<String, BookMetadata>
    ) {
        val filename = path.fileName.toString()
        val title = filename.substringBeforeLast('.')
        val meta = metadata[title]

        logger.i { "Processing book: $title with categoryId: $categoryId" }

        // Assign a unique ID to this book
        val currentBookId = nextBookId++
        logger.d { "Assigning ID $currentBookId to book '$title' with categoryId: $categoryId" }

        // Create author list if author is available in metadata
        val authors = meta?.author?.let { authorName ->
            listOf(Author(name = authorName))
        } ?: emptyList()

        // Create publication places list if pubPlace is available in metadata
        val pubPlaces = meta?.pubPlace?.let { pubPlaceName ->
            listOf(PubPlace(name = pubPlaceName))
        } ?: emptyList()

        // Create publication dates list if pubDate is available in metadata
        val pubDates = meta?.pubDate?.let { pubDateValue ->
            listOf(PubDate(date = pubDateValue))
        } ?: emptyList()

        val book = Book(
            id = currentBookId,
            categoryId = categoryId,
            title = title,
            authors = authors,
            pubPlaces = pubPlaces,
            pubDates = pubDates,
            heShortDesc = meta?.heShortDesc,
            order = meta?.order ?: 999f,
            topics = extractTopics(path)
        )

        logger.d { "Inserting book '${book.title}' with ID: ${book.id} and categoryId: ${book.categoryId}" }
        val insertedBookId = repository.insertBook(book)

        // ✅ Important verification: ensure that ID and categoryId are correct
        val insertedBook = repository.getBook(insertedBookId)
        if (insertedBook?.categoryId != categoryId) {
            logger.w { "WARNING: Book inserted with wrong categoryId! Expected: $categoryId, Got: ${insertedBook?.categoryId}" }
            // Correct the categoryId if necessary
            repository.updateBookCategoryId(insertedBookId, categoryId)
        }

        logger.d { "Book '${book.title}' inserted with ID: $insertedBookId and categoryId: $categoryId" }

        // Process content of the book
        processBookContent(path, insertedBookId)
    }

    /**
     * Processes the content of a book, extracting lines and TOC entries.
     *
     * @param path The path to the book file
     * @param bookId The ID of the book in the database
     */
    private suspend fun processBookContent(path: Path, bookId: Long) = coroutineScope {
        logger.d { "Processing content for book ID: $bookId" }
        logger.i { "Processing content of book ID: $bookId (ID generated by the database)" }

        val content = path.readText(Charsets.UTF_8)

        val lines = content.lines()
        logger.i { "Number of lines: ${lines.size}" }

        // Process each line one by one, handling TOC entries as we go
        processLinesWithTocEntries(bookId, lines)

        // Update the total number of lines
        repository.updateBookTotalLines(bookId, lines.size)

        logger.i { "Content processed successfully for book ID: $bookId (ID generated by the database)" }
    }


    /**
     * Processes lines of a book, identifying and creating TOC entries.
     *
     * @param bookId The ID of the book in the database
     * @param lines The lines of the book content
     */
    private suspend fun processLinesWithTocEntries(bookId: Long, lines: List<String>) {
        logger.d { "Processing lines and TOC entries together for book ID: $bookId" }

        // Map to track TOC entry parent relationships by level
        val parentStack = mutableMapOf<Int, Long>()

        for ((lineIndex, line) in lines.withIndex()) {
            val plainText = cleanHtml(line)
            val level = detectHeaderLevel(line)

            if (level > 0) {
                if (plainText.isBlank()) {
                    // Header is empty: skip creating a TOC entry
                    logger.d { "⚠️ Skipping empty header at level $level (line $lineIndex)" }
                    parentStack.remove(level)
                    continue
                }

                // Find parent: walk up until we find a valid parent
                val parentId = (level - 1 downTo 1).firstNotNullOfOrNull { parentStack[it] }

                val currentTocEntryId = nextTocEntryId++
                val currentLineId = nextLineId++

                val tocEntry = TocEntry(
                    id = currentTocEntryId,
                    bookId = bookId,
                    parentId = parentId,
                    text = plainText,
                    level = level,
                    lineId = null
                )

                val tocEntryId = repository.insertTocEntry(tocEntry)
                parentStack[level] = tocEntryId

                val lineId = repository.insertLine(
                    Line(
                        id = currentLineId,
                        bookId = bookId,
                        lineIndex = lineIndex,
                        content = line,
                        plainText = plainText
                    )
                )
                repository.updateTocEntryLineId(tocEntryId, lineId)
                repository.updateLineTocEntry(lineId, tocEntryId)
            } else {
                // Regular line
                val currentLineId = nextLineId++
                repository.insertLine(
                    Line(
                        id = currentLineId,
                        bookId = bookId,
                        lineIndex = lineIndex,
                        content = line,
                        plainText = plainText
                    )
                )
            }

            if (lineIndex % 1000 == 0) {
                logger.i { "Progress: $lineIndex/${lines.size} lines" }
            }
        }

        logger.i { "✅ Finished processing lines and TOC entries for book ID: $bookId" }
    }


    private fun cleanHtml(html: String): String {
        return HebrewTextUtils.removeNikud(
            Jsoup.clean(html, Safelist.none())
                .trim()
                .replace("\\s+".toRegex(), " ")
        )
    }


    private fun detectHeaderLevel(line: String): Int {
        return when {
            line.startsWith("<h1", ignoreCase = true) -> 1
            line.startsWith("<h2", ignoreCase = true) -> 2
            line.startsWith("<h3", ignoreCase = true) -> 3
            line.startsWith("<h4", ignoreCase = true) -> 4
            line.startsWith("<h5", ignoreCase = true) -> 5
            line.startsWith("<h6", ignoreCase = true) -> 6
            else -> 0
        }
    }

    /**
     * Processes all link files in the links directory.
     * Links connect lines between different books.
     */
    private suspend fun processLinks() {
        val linksDir = sourceDirectory.resolve("links")
        if (!linksDir.exists()) {
            logger.w { "Links directory not found" }
            return
        }

        // Count links before processing
        val linksBefore = repository.countLinks()
        logger.d { "Links in database before processing: $linksBefore" }

        logger.i { "Processing links..." }
        var totalLinks = 0

        Files.list(linksDir).use { stream ->
            stream.filter { it.extension == "json" }.forEach { linkFile ->
                runBlocking {
                    val processedLinks = processLinkFile(linkFile)
                    totalLinks += processedLinks
                    logger.d { "Processed $processedLinks links from ${linkFile.fileName}, total so far: $totalLinks" }
                }
            }
        }

        // Count links after processing
        val linksAfter = repository.countLinks()
        logger.d { "Links in database after processing: $linksAfter" }
        logger.d { "Added ${linksAfter - linksBefore} links to the database" }

        logger.i { "Total of $totalLinks links processed" }

        // Update the book_has_links table
        updateBookHasLinksTable()
    }

    /**
     * Processes a single link file, creating links between books.
     *
     * @param linkFile The path to the link file
     * @return The number of links successfully processed
     */
    private suspend fun processLinkFile(linkFile: Path): Int {
        val bookTitle = linkFile.nameWithoutExtension.removeSuffix("_links")
        logger.d { "Processing link file for book: $bookTitle" }

        // Find the source book
        val sourceBook = repository.getBookByTitle(bookTitle)

        if (sourceBook == null) {
            logger.w { "Source book not found for links: $bookTitle" }
            return 0
        }
        logger.d { "Found source book with ID: ${sourceBook.id}" }

        try {
            val content = linkFile.readText()
            logger.d { "Link file content length: ${content.length}" }
            val links = json.decodeFromString<List<LinkData>>(content)
            logger.d { "Decoded ${links.size} links from file" }
            var processed = 0

            for ((index, linkData) in links.withIndex()) {
                try {
                    // Find the target book
                    // Handle paths with backslashes
                    val path = linkData.path_2
                    val targetTitle = if (path.contains('\\')) {
                        // Extract the last component of a backslash-separated path
                        val lastComponent = path.split('\\').last()
                        // Remove file extension if present
                        lastComponent.substringBeforeLast('.', lastComponent)
                    } else {
                        // Use the standard path handling for forward slash paths
                        val targetPath = Paths.get(path)
                        targetPath.fileName.toString().substringBeforeLast('.')
                    }
                    logger.d { "Link ${index + 1}/${links.size} - Target book title: $targetTitle" }

                    // Try to find the target book
                    val targetBook = repository.getBookByTitle(targetTitle)
                    if (targetBook == null) {
                        // Enhanced logging for debugging
                        logger.i { "Link ${index + 1}/${links.size} - Target book not found: $targetTitle" }
                        logger.i { "Original path: ${linkData.path_2}" }
                        continue
                    }
                    logger.d { "Using target book with ID: ${targetBook.id}" }

                    // Find the lines
                    // Adjust indices from 1-based to 0-based
                    val sourceLineIndex = (linkData.line_index_1.toInt() - 1).coerceAtLeast(0)
                    val targetLineIndex = (linkData.line_index_2.toInt() - 1).coerceAtLeast(0)

                    logger.d { "Looking for source line at index: $sourceLineIndex (original: ${linkData.line_index_1}) in book ${sourceBook.id}" }

                    // Try to find the source line
                    val sourceLine = repository.getLineByIndex(sourceBook.id, sourceLineIndex)
                    if (sourceLine == null) {
                        logger.d { "Source line not found at index: $sourceLineIndex, skipping this link but continuing with others" }
                        continue
                    }
                    logger.d { "Using source line with ID: ${sourceLine.id}" }

                    logger.d { "Looking for target line at index: $targetLineIndex (original: ${linkData.line_index_2}) in book ${targetBook.id}" }

                    // Try to find the target line
                    val targetLine = repository.getLineByIndex(targetBook.id, targetLineIndex)
                    if (targetLine == null) {
                        logger.d { "Target line not found at index: $targetLineIndex, skipping this link but continuing with others" }
                        continue
                    }
                    logger.d { "Using target line with ID: ${targetLine.id}" }

                    val link = Link(
                        sourceBookId = sourceBook.id,
                        targetBookId = targetBook.id,
                        sourceLineId = sourceLine.id,
                        targetLineId = targetLine.id,
                        connectionType = ConnectionType.fromString(linkData.connectionType)
                    )

                    logger.d { "Inserting link from book ${sourceBook.id} to book ${targetBook.id}" }
                    val linkId = repository.insertLink(link)
                    logger.d { "Link inserted with ID: $linkId" }
                    processed++
                } catch (e: Exception) {
                    // Changed from error to debug level to reduce unnecessary error logs
                    logger.d(e) { "Error processing link: ${linkData.heRef_2}" }
                    logger.d { "Error processing link: ${e.message}" }
                }
            }
            logger.d { "Processed $processed links out of ${links.size}" }
            return processed
        } catch (e: Exception) {
            // Changed from error to warning level to reduce unnecessary error logs
            logger.w(e) { "Error processing link file: ${linkFile.fileName}" }
            logger.d { "Error processing link file: ${e.message}" }
            return 0
        }
    }

    /**
     * Extracts topics from the file path.
     * Topics are derived from the directory structure.
     *
     * @param path The path to the book file
     * @return A list of topics extracted from the path
     */
    private fun extractTopics(path: Path): List<Topic> {
        // Extract topics from the path
        val parts = path.toString().split(File.separator)
        val topicNames = parts.dropLast(1).takeLast(2)

        return topicNames.map { name ->
            Topic(name = name)
        }
    }

    /**
     * Disables foreign key constraints in the database to improve performance during bulk insertion.
     * This should be called before starting the data generation process.
     */
    private suspend fun disableForeignKeys() {
        logger.d { "Disabling foreign key constraints" }
        repository.executeRawQuery("PRAGMA foreign_keys = OFF")
    }

    /**
     * Re-enables foreign key constraints in the database after data insertion is complete.
     * This should be called after all data has been inserted to ensure data integrity.
     */
    private suspend fun enableForeignKeys() {
        logger.d { "Re-enabling foreign key constraints" }
        repository.executeRawQuery("PRAGMA foreign_keys = ON")
    }

    /**
     * Rebuilds the FTS5 index for the line_search table.
     * This should be called after all data has been inserted to ensure optimal search performance.
     */
    private suspend fun rebuildFts5Index() {
        logger.d { "Rebuilding FTS5 index for line_search table" }
        repository.rebuildFts5Index()
        logger.i { "FTS5 index rebuilt successfully" }
    }

    /**
     * Updates the book_has_links table to indicate which books have source links, target links, or both.
     * This should be called after all links have been processed.
     */
    private suspend fun updateBookHasLinksTable() {
        logger.i { "Updating book_has_links table with separate source and target link flags..." }

        // Get all books
        val books = repository.getAllBooks()
        logger.d { "Found ${books.size} books to check for links" }

        var booksWithSourceLinks = 0
        var booksWithTargetLinks = 0
        var booksWithAnyLinks = 0
        var processedBooks = 0

        // For each book, check if it has source links and/or target links
        for (book in books) {
            // Check if the book has any links as source
            val hasSourceLinks = repository.countLinksBySourceBook(book.id) > 0

            // Check if the book has any links as target
            val hasTargetLinks = repository.countLinksByTargetBook(book.id) > 0

            // Update the book_has_links table with separate flags for source and target links
            repository.updateBookHasLinks(book.id, hasSourceLinks, hasTargetLinks)

            // Update counters
            if (hasSourceLinks) {
                booksWithSourceLinks++
            }
            if (hasTargetLinks) {
                booksWithTargetLinks++
            }
            if (hasSourceLinks || hasTargetLinks) {
                booksWithAnyLinks++
            }

            processedBooks++

            // Log progress every 100 books
            if (processedBooks % 100 == 0) {
                logger.d { "Processed $processedBooks/${books.size} books: " +
                        "$booksWithSourceLinks with source links, " +
                        "$booksWithTargetLinks with target links, " +
                        "$booksWithAnyLinks with any links" }
            }
        }

        logger.i { "Book_has_links table updated. Found:" }
        logger.i { "- $booksWithSourceLinks books with source links" }
        logger.i { "- $booksWithTargetLinks books with target links" }
        logger.i { "- $booksWithAnyLinks books with any links (source or target)" }
        logger.i { "- ${books.size} total books" }
    }



    // Internal classes

    /**
     * Data class representing a link between two books.
     * Used for deserializing link data from JSON files.
     */
    @Serializable
    private data class LinkData(
        val heRef_2: String,
        val line_index_1: Double,
        val path_2: String,
        val line_index_2: Double,
        @SerialName("Conection Type")
        val connectionType: String = ""
    )
}
</file>

<file path="lib/generator/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/generator/HebrewTextUtils.kt">
package io.github.kdroidfilter.seforimlibrary.generator

/**
 * Utility class for processing Hebrew text by removing diacritical marks (nikud/niqqud).
 *
 * This class provides functions to clean Hebrew text from various diacritical marks including:
 * - Nikud (vowel points)
 * - Teamim (biblical cantillation marks)
 * - Maqaf (Hebrew hyphen)
 *
 * Based on the Unicode ranges and character mappings used in Hebrew text processing.
 */
object HebrewTextUtils {

    /**
     * Hebrew nikud (vowel point) characters mapping.
     * These are the diacritical marks used in Hebrew to indicate vowels.
     */
    private val NIKUD_SIGNS = mapOf(
        "HATAF_SEGOL" to "ֱ",    // U+05B1
        "HATAF_PATAH" to "ֲ",     // U+05B2
        "HATAF_QAMATZ" to "ֳ",    // U+05B3
        "HIRIQ" to "ִ",           // U+05B4
        "TSERE" to "ֵ",           // U+05B5
        "SEGOL" to "ֶ",           // U+05B6
        "PATAH" to "ַ",           // U+05B7
        "QAMATZ" to "ָ",          // U+05B8
        "SIN_DOT" to "ׂ",         // U+05C2
        "SHIN_DOT" to "ׁ",        // U+05C1
        "HOLAM" to "ֹ",           // U+05B9
        "DAGESH" to "ּ",          // U+05BC
        "QUBUTZ" to "ֻ",          // U+05BB
        "SHEVA" to "ְ",           // U+05B0
        "QAMATZ_QATAN" to "ׇ"     // U+05C7
    )

    /**
     * Meteg character (silluq) - U+05BD.
     * A vertical line placed to the left of a vowel to indicate stress.
     */
    private const val METEG = "ֽ"

    /**
     * Regular expression pattern for removing all nikud signs including meteg.
     */
    private val NIKUD_WITH_METEG_REGEX = "[${NIKUD_SIGNS.values.joinToString("")}$METEG]".toRegex()

    /**
     * Regular expression pattern for removing nikud signs only (excluding meteg).
     */
    private val NIKUD_ONLY_REGEX = "[${NIKUD_SIGNS.values.joinToString("")}]".toRegex()

    /**
     * Regular expression pattern for biblical cantillation marks (teamim).
     * Covers Unicode range U+0591 to U+05AF.
     */
    private val TEAMIM_REGEX = "[\u0591-\u05AF]".toRegex()

    /**
     * Hebrew maqaf character (hyphen) - U+05BE.
     */
    private const val MAQAF_CHAR = "־"

    /**
     * Removes all nikud (vowel points) from Hebrew text.
     *
     * This function strips vowel diacritical marks from Hebrew text, making it suitable
     * for applications that need unpointed Hebrew text.
     *
     * @param text The Hebrew text containing nikud marks, or null
     * @param includeMeteg Whether to also remove meteg marks (default: true)
     * @return The text with nikud removed, or empty string if input is null/empty
     *
     * @sample
     * ```kotlin
     * val pointed = "בְּרֵאשִׁית"
     * val unpointed = HebrewTextUtils.removeNikud(pointed)
     * // Result: "בראשית"
     * ```
     */
    fun removeNikud(text: String?, includeMeteg: Boolean = true): String {
        if (text.isNullOrEmpty()) return ""

        return if (includeMeteg) {
            text.replace(NIKUD_WITH_METEG_REGEX, "")
        } else {
            text.replace(NIKUD_ONLY_REGEX, "")
        }
    }

    /**
     * Removes biblical cantillation marks (teamim) from Hebrew text.
     *
     * Teamim are accent marks used in biblical Hebrew to indicate musical notation
     * and syntactic relationships. This function removes these marks while preserving
     * the base text and nikud.
     *
     * @param text The Hebrew text containing teamim, or null
     * @return The text with teamim removed, or empty string if input is null/empty
     *
     * @sample
     * ```kotlin
     * val withTeamim = "בְּרֵאשִׁ֖ית"
     * val withoutTeamim = HebrewTextUtils.removeTeamim(withTeamim)
     * // Result: "בְּרֵאשִׁית"
     * ```
     */
    fun removeTeamim(text: String?): String {
        if (text.isNullOrEmpty()) return ""
        return text.replace(TEAMIM_REGEX, "")
    }

    /**
     * Removes all diacritical marks from Hebrew text.
     *
     * This function removes both nikud (vowel points) and teamim (cantillation marks),
     * resulting in plain Hebrew consonantal text.
     *
     * @param text The Hebrew text containing diacritical marks, or null
     * @return The text with all diacritical marks removed, or empty string if input is null/empty
     *
     * @sample
     * ```kotlin
     * val fullyMarked = "בְּרֵאשִׁ֖ית בָּרָ֣א"
     * val plain = HebrewTextUtils.removeAllDiacritics(fullyMarked)
     * // Result: "בראשית ברא"
     * ```
     */
    fun removeAllDiacritics(text: String?): String {
        if (text.isNullOrEmpty()) return ""
        return removeTeamim(removeNikud(text, true))
    }

    /**
     * Checks whether the given text contains nikud marks.
     *
     * @param text The text to examine, or null
     * @return `true` if the text contains any nikud marks, `false` otherwise
     *
     * @sample
     * ```kotlin
     * val hasNikud = HebrewTextUtils.containsNikud("בְּרֵאשִׁית") // true
     * val noNikud = HebrewTextUtils.containsNikud("בראשית")     // false
     * ```
     */
    fun containsNikud(text: String?): Boolean {
        if (text.isNullOrEmpty()) return false
        return NIKUD_WITH_METEG_REGEX.containsMatchIn(text)
    }

    /**
     * Checks whether the given text contains teamim (cantillation marks).
     *
     * @param text The text to examine, or null
     * @return `true` if the text contains any teamim, `false` otherwise
     *
     * @sample
     * ```kotlin
     * val hasTeamim = HebrewTextUtils.containsTeamim("בְּרֵאשִׁ֖ית") // true
     * val noTeamim = HebrewTextUtils.containsTeamim("בְּרֵאשִׁית")   // false
     * ```
     */
    fun containsTeamim(text: String?): Boolean {
        if (text.isNullOrEmpty()) return false
        return TEAMIM_REGEX.containsMatchIn(text)
    }

    /**
     * Checks whether the given text contains maqaf (Hebrew hyphen).
     *
     * @param text The text to examine, or null
     * @return `true` if the text contains any maqaf characters, `false` otherwise
     *
     * @sample
     * ```kotlin
     * val hasMaqaf = HebrewTextUtils.containsMaqaf("אֵל־שַׁדַּי") // true
     * val noMaqaf = HebrewTextUtils.containsMaqaf("אל שדי")     // false
     * ```
     */
    fun containsMaqaf(text: String?): Boolean {
        if (text.isNullOrEmpty()) return false
        return text.contains(MAQAF_CHAR)
    }

    /**
     * Replaces Hebrew maqaf characters with a specified replacement string.
     *
     * Maqaf is the Hebrew hyphen character (־) used to connect words or parts of words
     * in Hebrew text. This function allows replacing it with other characters like
     * space, dash, or any other string.
     *
     * @param text The text containing maqaf characters, or null
     * @param replacement The string to replace maqaf with (default: single space)
     * @return The text with maqaf characters replaced, or empty string if input is null/empty
     *
     * @sample
     * ```kotlin
     * val withMaqaf = "אֵל־שַׁדַּי"
     * val withSpace = HebrewTextUtils.replaceMaqaf(withMaqaf)        // "אֵל שַׁדַּי"
     * val withDash = HebrewTextUtils.replaceMaqaf(withMaqaf, "-")    // "אֵל-שַׁדַּי"
     * ```
     */
    fun replaceMaqaf(text: String?, replacement: String = " "): String {
        if (text.isNullOrEmpty()) return ""
        return text.replace(MAQAF_CHAR, replacement)
    }
}
</file>

<file path="lib/generator/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/generator/Main.kt">
package io.github.kdroidfilter.seforimlibrary.generator

import app.cash.sqldelight.driver.jdbc.sqlite.JdbcSqliteDriver
import io.github.kdroidfilter.seforimlibrary.dao.repository.SeforimRepository
import kotlinx.coroutines.runBlocking
import java.io.File
import java.nio.file.Paths
import kotlin.io.path.Path
import kotlin.system.exitProcess
import co.touchlab.kermit.Logger
import co.touchlab.kermit.Severity

/**
 * Main entry point for the Otzaria database generator.
 * This function initializes the database, sets up the repository,
 * and runs the generation process.
 */
fun main() = runBlocking {
    // Configure Kermit to show warnings and errors
        Logger.setMinSeverity(Severity.Error)

    val logger = Logger.withTag("Main")

    val dbFile = File("otzaria.db")
    val dbExists = dbFile.exists()
    logger.d{"Database file exists: $dbExists"}

    // If the database file exists, rename it to make sure we're creating a new one
    if (dbExists) {
        val backupFile = File("otzaria.db.bak")
        if (backupFile.exists()) {
            backupFile.delete()
        }
        dbFile.renameTo(backupFile)
        logger.d{"Renamed existing database to otzaria.db.bak"}
    }

    val driver = JdbcSqliteDriver(url = "jdbc:sqlite:otzaria.db")

    val sourcePath = Path("/Users/elie/Downloads/otzaria_latest")
//    val sourcePath = Path("/Users/elie/Documents/otzaria_latest")
    val dbPath = Paths.get("otzaria.db").toFile().path

    if (!sourcePath.toFile().exists()) {
        logger.e{"The source directory does not exist: $sourcePath"}
        exitProcess(1)
    }

    logger.i{"=== Otzaria Database Generator ==="}
    logger.i{"Source: $sourcePath"}
    logger.i{"Database: $dbPath"}

    val repository = SeforimRepository(dbPath, driver)

    try {
        val generator = DatabaseGenerator(sourcePath, repository)
        generator.generate()

        logger.i{"Generation completed successfully!"}
        logger.i{"Database created: $dbPath"}
    } catch (e: Exception) {
        logger.e(e){"Error during generation"}
        exitProcess(1)
    } finally {
        repository.close()
    }
}
</file>

<file path="lib/generator/build.gradle.kts">
import com.vanniktech.maven.publish.SonatypeHost

plugins {
    alias(libs.plugins.multiplatform)
    alias(libs.plugins.kotlinx.serialization)
}

kotlin {
    jvmToolchain(17)

    jvm()

    sourceSets {
        commonMain.dependencies {
            api(project(":core"))
            api(project(":dao"))

            implementation(libs.kotlinx.coroutines.core)
            implementation(libs.kotlinx.coroutines.test)
            implementation(libs.kotlinx.serialization.json)
            implementation(libs.kotlinx.datetime)
            implementation(libs.kermit)
            implementation("org.jsoup:jsoup:1.17.2")
            implementation("org.slf4j:slf4j-simple:2.0.17")
        }

        commonTest.dependencies {
            implementation(kotlin("test"))
        }


        jvmMain.dependencies {
            implementation(libs.kotlinx.coroutines.swing)
            implementation(libs.sqlDelight.driver.sqlite)
        }

    }

}
</file>

<file path="lib/gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.14.2-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="lib/gradle/libs.versions.toml">
[versions]

kotlin = "2.2.0"
agp = "8.10.0"
maven-publish = "0.33.0"
kotlinx-coroutines = "1.10.2"
kotlinx-serialization = "1.9.0"
kotlinx-datetime = "0.7.0"
kermit = "2.0.6"
sqlDelight = "2.1.0"
compose = "1.8.2"
androidx-activityCompose = "1.10.1"

[libraries]

kotlinx-coroutines-core = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-core", version.ref = "kotlinx-coroutines" }
kotlinx-coroutines-android = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-android", version.ref = "kotlinx-coroutines" }
kotlinx-coroutines-swing = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-swing", version.ref = "kotlinx-coroutines" }
kotlinx-coroutines-test = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-test", version.ref = "kotlinx-coroutines" }
kotlinx-serialization-json = { module = "org.jetbrains.kotlinx:kotlinx-serialization-json", version.ref = "kotlinx-serialization" }
kotlinx-datetime = { module = "org.jetbrains.kotlinx:kotlinx-datetime", version.ref = "kotlinx-datetime" }
kermit = { module = "co.touchlab:kermit", version.ref = "kermit" }
sqlDelight-driver-sqlite = { module = "app.cash.sqldelight:sqlite-driver", version.ref = "sqlDelight" }
sqlDelight-driver-android = { module = "app.cash.sqldelight:android-driver", version.ref = "sqlDelight" }
sqlDelight-driver-native = { module = "app.cash.sqldelight:native-driver", version.ref = "sqlDelight" }
sqlDelight-driver-js = { module = "app.cash.sqldelight:web-worker-driver", version.ref = "sqlDelight" }
androidx-activityCompose = { module = "androidx.activity:activity-compose", version.ref = "androidx-activityCompose" }

[plugins]

multiplatform = { id = "org.jetbrains.kotlin.multiplatform", version.ref = "kotlin" }
android-library = { id = "com.android.library", version.ref = "agp" }
maven-publish = { id = "com.vanniktech.maven.publish", version.ref = "maven-publish" }
kotlinx-serialization = { id = "org.jetbrains.kotlin.plugin.serialization", version.ref = "kotlin" }
sqlDelight = { id = "app.cash.sqldelight", version.ref = "sqlDelight" }
compose = { id = "org.jetbrains.compose", version.ref = "compose" }
compose-compiler = { id = "org.jetbrains.kotlin.plugin.compose", version.ref = "kotlin" }
android-application = { id = "com.android.application", version.ref = "agp" }
</file>

<file path="lib/sample/composeApp/src/androidMain/kotlin/sample/app/DatabaseUtils.kt">
package sample.app

import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import app.cash.sqldelight.db.SqlDriver
import app.cash.sqldelight.driver.android.AndroidSqliteDriver
import io.github.kdroidfilter.seforimlibrary.dao.repository.SeforimRepository
import android.content.Context
import androidx.compose.ui.platform.LocalContext
import io.github.kdroidfilter.seforimlibrary.db.SeforimDb
// Import the androidx.sqlite classes
import androidx.sqlite.*

// Android implementation of database path
@Composable
actual fun getDatabasePath(): String {
    // For Android, we'll use the app's internal storage
    return "otzaria.db"
}

// Android implementation of repository
@Composable
actual fun getRepository(): SeforimRepository {
    val dbPath = getDatabasePath()
    val context = LocalContext.current

    // Create a custom SqlDriver that uses BundledSQLiteDriver
    val driver: SqlDriver = remember {

        AndroidSqliteDriver(SeforimDb.Schema, context, dbPath)


    }

    return remember(driver) {
        SeforimRepository(dbPath, driver)
    }
}

// Empty implementation for Android - we don't show the database selection button on mobile
@Composable
actual fun DatabaseSelectionButtonIfAvailable() {
    // No-op on Android
}
</file>

<file path="lib/sample/composeApp/src/androidMain/kotlin/sample/app/main.kt">
package sample.app

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge

class AppActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent { App() }
    }
}
</file>

<file path="lib/sample/composeApp/src/androidMain/AndroidManifest.xml">
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <application
            android:icon="@android:mipmap/sym_def_app_icon"
            android:label="sample"
            android:theme="@android:style/Theme.Material.NoActionBar">
        <activity
            android:name=".AppActivity"
            android:configChanges="orientation|screenSize|screenLayout|keyboardHidden"
            android:launchMode="singleInstance"
            android:windowSoftInputMode="adjustPan"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>
</file>

<file path="lib/sample/composeApp/src/commonMain/kotlin/sample/app/App.kt">
package sample.app

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Search
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import co.touchlab.kermit.Logger
import io.github.kdroidfilter.seforimlibrary.core.models.Book
import io.github.kdroidfilter.seforimlibrary.core.models.Category
import io.github.kdroidfilter.seforimlibrary.core.models.Line
import io.github.kdroidfilter.seforimlibrary.core.models.TocEntry
import io.github.kdroidfilter.seforimlibrary.dao.repository.CommentaryWithText
import io.github.kdroidfilter.seforimlibrary.dao.repository.CommentatorInfo
import io.github.kdroidfilter.seforimlibrary.dao.repository.SeforimRepository
import kotlinx.coroutines.async
import kotlinx.coroutines.launch

@Composable
expect fun getDatabasePath(): String

@Composable
expect fun getRepository(): SeforimRepository

@Composable
expect fun DatabaseSelectionButtonIfAvailable()

data class BookState(
    val book: Book? = null,
    val lines: List<Line> = emptyList(),
    val commentaries: List<CommentaryWithText> = emptyList(),
    val toc: List<TocEntry> = emptyList(),
    val selectedLine: Line? = null,
    val isLoading: Boolean = false,
    val isTocLoading: Boolean = false
)

data class PopupState(
    val show: Boolean = false,
    val book: Book? = null,
    val lines: List<Line> = emptyList(),
    val commentaries: List<CommentaryWithText> = emptyList(),
    val commentators: List<CommentatorInfo> = emptyList(),
    val selectedLine: Line? = null
)

@Composable
fun App() {
    Logger.setMinSeverity(co.touchlab.kermit.Severity.Error)
    val repository = getRepository()
    val scope = rememberCoroutineScope()

    // Category tree state
    var rootCategories by remember { mutableStateOf<List<Category>>(emptyList()) }
    var selectedCategory by remember { mutableStateOf<Category?>(null) }
    var expandedCategories by remember { mutableStateOf(setOf<Long>()) }
    var categoryChildren by remember { mutableStateOf<Map<Long, List<Category>>>(emptyMap()) }
    var booksInCategory by remember { mutableStateOf<Set<Book>>(emptySet()) }

    // Book state
    var bookState by remember { mutableStateOf(BookState()) }

    // TOC state
    var expandedTocEntries by remember { mutableStateOf(setOf<Long>()) }
    var tocChildren by remember { mutableStateOf<Map<Long, List<TocEntry>>>(emptyMap()) }

    // Popup states
    var bookPopup by remember { mutableStateOf(PopupState()) }
    var showSearchPopup by remember { mutableStateOf(false) }

    // Load root categories on startup
    LaunchedEffect(repository) {
        rootCategories = repository.getRootCategories()
    }

    // Helper functions
    fun getAllDescendantIds(entryId: Long, childrenMap: Map<Long, List<TocEntry>>): Set<Long> {
        val result = mutableSetOf<Long>()
        childrenMap[entryId]?.forEach { child ->
            result.add(child.id)
            result.addAll(getAllDescendantIds(child.id, childrenMap))
        }
        return result
    }

    fun loadBook(book: Book) {
        bookState = bookState.copy(
            book = book,
            selectedLine = null,
            isLoading = true,
            isTocLoading = true
        )

        scope.launch {
            try {
                // Load book data in parallel
                val linesDeferred = async { repository.getLines(book.id, 0, 30) }
                val tocDeferred = async {
                    repository.getBookRootToc(book.id).ifEmpty {
                        repository.getBookToc(book.id)
                    }
                }

                val lines = linesDeferred.await()
                val toc = tocDeferred.await()

                // Load commentaries for first 5 lines
                val commentaries = if (lines.isNotEmpty()) {
                    repository.getCommentariesForLines(lines.take(5).map { it.id })
                } else emptyList()

                bookState = bookState.copy(
                    lines = lines,
                    commentaries = commentaries,
                    toc = toc,
                    isLoading = false,
                    isTocLoading = false
                )

                // Auto-expand first TOC entry if exists
                if (toc.isNotEmpty()) {
                    val firstEntry = toc.first()
                    expandedTocEntries = setOf(firstEntry.id)
                    val children = repository.getTocChildren(firstEntry.id)
                    tocChildren = mapOf(firstEntry.id to children)
                }
            } catch (e: Exception) {
                bookState = bookState.copy(isLoading = false, isTocLoading = false)
                Logger.e { "Error loading book: ${e.message}" }
            }
        }
    }

    fun selectLine(line: Line) {
        bookState = bookState.copy(selectedLine = line)
        scope.launch {
            bookState = bookState.copy(
                commentaries = repository.getCommentariesForLines(listOf(line.id))
            )
        }
    }

    fun loadPopupBook(commentary: CommentaryWithText) {
        scope.launch {
            val targetBook = repository.getBook(commentary.link.targetBookId)
            if (targetBook != null) {
                val targetLine = repository.getLine(commentary.link.targetLineId)

                val (lines, selectedLine) = if (targetLine != null) {
                    val startIndex = maxOf(0, targetLine.lineIndex - 25)
                    val endIndex = targetLine.lineIndex + 25
                    repository.getLines(targetBook.id, startIndex, endIndex) to targetLine
                } else {
                    repository.getLines(targetBook.id, 0, 100) to null
                }

                val commentaries = if (lines.isNotEmpty()) {
                    repository.getCommentariesForLines(lines.map { it.id })
                } else emptyList()

                val commentators = repository.getAvailableCommentators(targetBook.id)

                bookPopup = PopupState(
                    show = true,
                    book = targetBook,
                    lines = lines,
                    commentaries = commentaries,
                    commentators = commentators,
                    selectedLine = selectedLine
                )
            }
        }
    }

    AppTheme {
        Row(modifier = Modifier.fillMaxSize()) {
            // Column 1: Book tree
            Box(
                modifier = Modifier
                    .weight(0.25f)
                    .fillMaxHeight()
                    .background(MaterialTheme.colorScheme.surface)
                    .padding(8.dp)
            ) {
                CategoryBookTree(
                    rootCategories = rootCategories,
                    expandedCategories = expandedCategories,
                    categoryChildren = categoryChildren,
                    booksInCategory = booksInCategory,
                    selectedCategory = selectedCategory,
                    selectedBook = bookState.book,
                    onCategoryClick = { category ->
                        selectedCategory = category

                        if (expandedCategories.contains(category.id)) {
                            expandedCategories -= category.id
                        } else {
                            expandedCategories += category.id

                            scope.launch {
                                try {
                                    val childrenDeferred = async {
                                        if (!categoryChildren.containsKey(category.id)) {
                                            repository.getCategoryChildren(category.id)
                                        } else emptyList()
                                    }
                                    val booksDeferred = async { repository.getBooksByCategory(category.id) }

                                    val children = childrenDeferred.await()
                                    val books = booksDeferred.await()

                                    if (children.isNotEmpty()) {
                                        categoryChildren += category.id to children
                                    }
                                    if (books.isNotEmpty()) {
                                        booksInCategory += books
                                    }
                                } catch (e: Exception) {
                                    Logger.e { "Error loading category: ${e.message}" }
                                }
                            }
                        }
                    },
                    onBookClick = ::loadBook
                )
            }

            // Column 2: TOC
            Box(
                modifier = Modifier
                    .weight(0.20f)
                    .fillMaxHeight()
                    .background(MaterialTheme.colorScheme.surface.copy(alpha = 0.7f))
                    .padding(8.dp)
            ) {
                if (bookState.book != null) {
                    Column {
                        Text(
                            text = "תוכן עניינים", // Table of Contents
                            fontWeight = FontWeight.Bold,
                            fontSize = 16.sp,
                            modifier = Modifier.padding(bottom = 8.dp)
                        )

                        if (bookState.isTocLoading) {
                            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                                    CircularProgressIndicator(modifier = Modifier.size(24.dp))
                                    Spacer(modifier = Modifier.height(4.dp))
                                    Text("טוען תוכן עניינים...", fontSize = 12.sp) // Loading table of contents...
                                }
                            }
                        } else {
                            TocView(
                                tocEntries = bookState.toc,
                                expandedEntries = expandedTocEntries,
                                childrenMap = tocChildren,
                                onEntryClick = { tocEntry ->
                                    tocEntry.lineId?.let { lineId ->
                                        scope.launch {
                                            val line = repository.getLine(lineId)
                                            if (line != null) {
                                                if (!bookState.lines.any { it.id == lineId }) {
                                                    val startIndex = maxOf(0, line.lineIndex - 25)
                                                    val endIndex = line.lineIndex + 25
                                                    bookState = bookState.copy(
                                                        lines = repository.getLines(bookState.book!!.id, startIndex, endIndex)
                                                    )
                                                }
                                                selectLine(line)
                                            }
                                        }
                                    }
                                },
                                onEntryExpand = { tocEntry ->
                                    val isExpanded = expandedTocEntries.contains(tocEntry.id)

                                    if (isExpanded) {
                                        val descendants = getAllDescendantIds(tocEntry.id, tocChildren)
                                        expandedTocEntries = expandedTocEntries - tocEntry.id - descendants
                                    } else {
                                        expandedTocEntries += tocEntry.id

                                        if (!tocChildren.containsKey(tocEntry.id)) {
                                            scope.launch {
                                                val children = repository.getTocChildren(tocEntry.id)
                                                tocChildren += tocEntry.id to children

                                                // Recursively check for grandchildren
                                                suspend fun loadChildrenRecursively(entries: List<TocEntry>) {
                                                    entries.forEach { entry ->
                                                        if (!tocChildren.containsKey(entry.id)) {
                                                            val entryChildren = repository.getTocChildren(entry.id)
                                                            tocChildren += entry.id to entryChildren
                                                            if (entryChildren.isNotEmpty()) {
                                                                loadChildrenRecursively(entryChildren)
                                                            }
                                                        }
                                                    }
                                                }

                                                if (children.isNotEmpty()) {
                                                    loadChildrenRecursively(children)
                                                }
                                            }
                                        }
                                    }
                                }
                            )
                        }
                    }
                } else {
                    Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                        Text("בחר ספר כדי לצפות בתוכן העניינים שלו") // Select a book to view its table of contents
                    }
                }
            }

            // Column 3: Book content and comments
            Column(
                modifier = Modifier
                    .weight(0.65f)
                    .fillMaxHeight()
                    .padding(8.dp)
            ) {
                if (bookState.book != null) {
                    val hasComments = bookState.selectedLine?.let { line ->
                        bookState.commentaries.any { it.link.sourceLineId == line.id }
                    } ?: false

                    // Book content
                    Box(
                        modifier = Modifier
                            .weight(if (hasComments) 0.5f else 1f)
                            .fillMaxWidth()
                    ) {
                        if (bookState.isLoading) {
                            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                                    CircularProgressIndicator()
                                    Spacer(modifier = Modifier.height(8.dp))
                                    Text("טוען תוכן הספר...") // Loading book content...
                                }
                            }
                        } else {
                            BookContentView(
                                book = bookState.book!!,
                                lines = bookState.lines,
                                selectedLine = bookState.selectedLine,
                                onLineSelected = ::selectLine
                            )
                        }
                    }

                    // Comments view (only if has comments)
                    if (hasComments) {
                        Box(
                            modifier = Modifier
                                .weight(0.5f)
                                .fillMaxWidth()
                                .background(MaterialTheme.colorScheme.surface.copy(alpha = 0.5f))
                        ) {
                            LineCommentsView(
                                selectedLine = bookState.selectedLine,
                                commentaries = bookState.commentaries,
                                onCommentClick = ::loadPopupBook
                            )
                        }
                    }
                }
            }
        }

        // Book popup
        if (bookPopup.show && bookPopup.book != null) {
            BookPopup(
                book = bookPopup.book!!,
                lines = bookPopup.lines,
                commentaries = bookPopup.commentaries,
                commentators = bookPopup.commentators,
                selectedLine = bookPopup.selectedLine,
                onDismiss = { bookPopup = PopupState() }
            )
        }

        // FAB for search and database
        Box(modifier = Modifier.fillMaxSize()) {
            Row(
                modifier = Modifier
                    .align(Alignment.TopEnd)
                    .padding(16.dp),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                DatabaseSelectionButtonIfAvailable()
                IconButton(onClick = { showSearchPopup = true }) {
                    Icon(Icons.Default.Search, contentDescription = "Search")
                }
            }
        }

        // Search popup
        if (showSearchPopup) {
            SearchPopup(
                repository = repository,
                onDismiss = { showSearchPopup = false },
                onResultClick = { searchResult ->
                    scope.launch {
                        val book = repository.getBook(searchResult.bookId)
                        if (book != null) {
                            selectedCategory = repository.getCategory(book.categoryId)
                            loadBook(book)

                            val line = repository.getLine(searchResult.lineId)
                            if (line != null) {
                                val startIndex = maxOf(0, line.lineIndex - 5)
                                val endIndex = line.lineIndex + 5
                                bookState = bookState.copy(
                                    lines = repository.getLines(book.id, startIndex, endIndex)
                                )
                                selectLine(line)
                            }

                            showSearchPopup = false
                        }
                    }
                }
            )
        }
    }
}
</file>

<file path="lib/sample/composeApp/src/commonMain/kotlin/sample/app/BookContentView.kt">
package sample.app

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.KeyboardArrowRight
import androidx.compose.material.icons.filled.KeyboardArrowDown
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.mohamedrejeb.richeditor.model.rememberRichTextState
import com.mohamedrejeb.richeditor.ui.material.RichText
import io.github.kdroidfilter.seforimlibrary.core.models.Book
import io.github.kdroidfilter.seforimlibrary.core.models.Line
import io.github.kdroidfilter.seforimlibrary.core.models.TocEntry

@Composable
fun BookContentView(
    book: Book,
    lines: List<Line>,
    selectedLine: Line? = null,
    onLineSelected: (Line) -> Unit = {}
) {
    Column(modifier = Modifier.fillMaxSize()) {
        // Book title
        Text(
            text = book.title,
            fontWeight = FontWeight.Bold,
            fontSize = 20.sp,
            modifier = Modifier.padding(16.dp)
        )

        // Book content
        Box(modifier = Modifier.weight(1f)) {
            BookContent(
                lines = lines,
                selectedLine = selectedLine,
                onLineSelected = onLineSelected
            )
        }
    }
}

@Composable
fun BookContent(
    lines: List<Line>,
    selectedLine: Line? = null,
    onLineSelected: (Line) -> Unit = {}
) {
    if (lines.isEmpty()) {
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            Text("אין תוכן זמין")
        }
    } else {
        // Create a LazyListState to control scrolling
        val listState = rememberLazyListState()

        // Keep track of the currently loaded lines
        val book = remember(lines) { lines.firstOrNull() }
        val bookId = remember(book) { book?.bookId ?: 0L }

        // Define the window size and offset for pagination
        val windowSize = 50 // Number of lines to display at once
        val loadOffset = 15 // Load more lines when this close to the edge

        // State to track the current window of lines
        var currentLines by remember(lines) { mutableStateOf(lines) }
        var startIndex by remember(lines) { mutableStateOf(lines.firstOrNull()?.lineIndex ?: 0) }
        var endIndex by remember(lines) { mutableStateOf((lines.lastOrNull()?.lineIndex ?: 0) + 1) }

        // Convert lines to LineWithUniqueKey objects
        var currentLinesWithKeys by remember(currentLines) { mutableStateOf(currentLines.withUniqueKeys()) }

        // Repository to load more lines
        val repository = getRepository()

        // Scroll to the selected line when it changes
        LaunchedEffect(selectedLine, lines) {
            if (selectedLine != null) {
                // Check if the selected line is in the current window
                val selectedIndex = currentLines.indexOfFirst { it.id == selectedLine.id }

                if (selectedIndex >= 0) {
                    // If the line is already in our current window, just scroll to it
                    listState.animateScrollToItem(selectedIndex)
                } else {
                    // If the line is not in our current window, we need to load it
                    // Load a window of lines centered around the selected line
                    val lineIndex = selectedLine.lineIndex
                    val newStartIndex = maxOf(0, lineIndex - windowSize / 2)
                    val newEndIndex = lineIndex + windowSize / 2

                    // Load the lines from the repository
                    val newLines = repository.getLines(bookId, newStartIndex, newEndIndex)
                    if (newLines.isNotEmpty()) {
                        // Update our current window
                        currentLines = newLines
                        startIndex = newStartIndex
                        endIndex = newEndIndex
                        // Update lines with unique keys
                        currentLinesWithKeys = currentLines.withUniqueKeys()

                        // Now find the index of the selected line in the new window and scroll to it
                        val newSelectedIndex = currentLines.indexOfFirst { it.id == selectedLine.id }
                        if (newSelectedIndex >= 0) {
                            listState.scrollToItem(newSelectedIndex)
                        }
                    }
                }
            }
        }

        // Load more lines when approaching the edges
        LaunchedEffect(listState.firstVisibleItemIndex) {
            // If we're close to the top, load more lines above
            if (listState.firstVisibleItemIndex < loadOffset && startIndex > 0) {
                val newStartIndex = maxOf(0, startIndex - windowSize / 2)
                val newLines = repository.getLines(bookId, newStartIndex, startIndex)
                if (newLines.isNotEmpty()) {
                    currentLines = newLines + currentLines
                    startIndex = newStartIndex
                    // Update lines with unique keys
                    currentLinesWithKeys = currentLines.withUniqueKeys()
                }
            }
        }

        LaunchedEffect(listState.layoutInfo.visibleItemsInfo.lastOrNull()?.index) {
            // If we're close to the bottom, load more lines below
            val lastVisibleIndex = listState.layoutInfo.visibleItemsInfo.lastOrNull()?.index ?: 0
            if (lastVisibleIndex >= currentLines.size - loadOffset) {
                val newEndIndex = endIndex + windowSize / 2
                val newLines = repository.getLines(bookId, endIndex, newEndIndex)
                if (newLines.isNotEmpty()) {
                    currentLines = currentLines + newLines
                    endIndex = newEndIndex
                    // Update lines with unique keys
                    currentLinesWithKeys = currentLines.withUniqueKeys()
                }
            }
        }

        // Limit the number of lines in memory to maintain efficiency
        LaunchedEffect(currentLines.size) {
            if (currentLines.size > windowSize * 3) {
                // If we have too many lines, trim from the opposite end of where we're viewing
                if (listState.firstVisibleItemIndex < currentLines.size / 2) {
                    // We're closer to the top, trim from the bottom
                    currentLines = currentLines.take(windowSize * 2)
                    endIndex = (currentLines.lastOrNull()?.lineIndex ?: 0) + 1
                } else {
                    // We're closer to the bottom, trim from the top
                    currentLines = currentLines.takeLast(windowSize * 2)
                    startIndex = currentLines.firstOrNull()?.lineIndex ?: 0
                }
                // Update lines with unique keys
                currentLinesWithKeys = currentLines.withUniqueKeys()
            }
        }

        LazyColumn(
            state = listState,
            modifier = Modifier.fillMaxSize().padding(16.dp)
        ) {
            items(
                items = currentLinesWithKeys,
                key = { it.uniqueKey } // Use the unique key for stable identity
            ) { lineWithKey ->
                val line = lineWithKey.line
                val isSelected = selectedLine?.id == line.id
                val state = rememberRichTextState()

                // Use LaunchedEffect to set HTML content only when line changes
                LaunchedEffect(line.id) {
                    state.setHtml(line.content)
                }

                RichText(
                    state = state,
                    modifier = Modifier
                        .fillMaxWidth()
                        .clickable { onLineSelected(line) }
                        .background(if (isSelected) MaterialTheme.colorScheme.primary.copy(alpha = 0.1f) else Color.Transparent)
                        .padding(vertical = 4.dp),
                )
            }
        }
    }
}

@Composable
fun TocView(
    tocEntries: List<TocEntry>,
    expandedEntries: Set<Long>,
    childrenMap: Map<Long, List<TocEntry>>,
    onEntryClick: (TocEntry) -> Unit,
    onEntryExpand: (TocEntry) -> Unit
) {
    if (tocEntries.isEmpty()) {
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            Text("אין תוכן עניינים זמין")
        }
    } else {
        LazyColumn(
            modifier = Modifier.fillMaxSize().padding(16.dp)
        ) {
            items(tocEntries) { entry ->
                TocEntryItem(
                    entry = entry,
                    level = 0,
                    isExpanded = expandedEntries.contains(entry.id),
                    childEntries = childrenMap[entry.id] ?: emptyList(),
                    expandedEntries = expandedEntries,
                    childrenMap = childrenMap,
                    onEntryClick = onEntryClick,
                    onEntryExpand = onEntryExpand
                )
            }
        }
    }
}

@Composable
fun TocEntryItem(
    entry: TocEntry,
    level: Int,
    isExpanded: Boolean,
    childEntries: List<TocEntry>,
    expandedEntries: Set<Long>,
    childrenMap: Map<Long, List<TocEntry>>,
    onEntryClick: (TocEntry) -> Unit,
    onEntryExpand: (TocEntry) -> Unit
) {
    // Check if we've already attempted to load children for this entry
    val hasCheckedForChildren = childrenMap.containsKey(entry.id)
    // If we've checked and the list is empty, then it truly has no children
    val hasNoChildren = hasCheckedForChildren && childEntries.isEmpty()

    Column {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .clickable { onEntryClick(entry) }
                .padding(start = (level * 16).dp, top = 4.dp, bottom = 4.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Show expand/collapse icon unless we've confirmed the entry has no children
            if (!hasNoChildren) {
                Icon(
                    imageVector = if (isExpanded) Icons.Default.KeyboardArrowDown else Icons.AutoMirrored.Filled.KeyboardArrowRight,
                    contentDescription = if (isExpanded) "Collapse" else "Expand",
                    tint = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f),
                    modifier = Modifier
                        .size(24.dp)
                        .clickable { onEntryExpand(entry) }
                )
            } else {
                Spacer(modifier = Modifier.width(24.dp))
            }

            // Entry text
            Text(
                text = entry.text,
                fontWeight = FontWeight.Normal,
                fontSize = 14.sp
            )
        }

        // Show children if expanded
        if (isExpanded && childEntries.isNotEmpty()) {
            childEntries.forEach { childEntry ->
                TocEntryItem(
                    entry = childEntry,
                    level = level + 1,
                    isExpanded = expandedEntries.contains(childEntry.id),
                    childEntries = childrenMap[childEntry.id] ?: emptyList(),
                    expandedEntries = expandedEntries,
                    childrenMap = childrenMap,
                    onEntryClick = onEntryClick,
                    onEntryExpand = onEntryExpand
                )
            }
        }
    }
}
</file>

<file path="lib/sample/composeApp/src/commonMain/kotlin/sample/app/BookPopup.kt">
package sample.app

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Close
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import io.github.kdroidfilter.seforimlibrary.core.models.Book
import io.github.kdroidfilter.seforimlibrary.core.models.Line
import io.github.kdroidfilter.seforimlibrary.dao.repository.CommentaryWithText
import io.github.kdroidfilter.seforimlibrary.dao.repository.CommentatorInfo

/**
 * A popup dialog that displays a book's content.
 *
 * @param book The book to display
 * @param lines The lines of the book to display
 * @param commentaries Commentaries for the book
 * @param commentators Available commentators for the book
 * @param selectedLine The line to highlight in the book content
 * @param onDismiss Callback when the popup is dismissed
 */
@Composable
fun BookPopup(
    book: Book,
    lines: List<Line>,
    commentaries: List<CommentaryWithText>,
    commentators: List<CommentatorInfo>,
    selectedLine: Line? = null,
    onDismiss: () -> Unit
) {
    Dialog(onDismissRequest = onDismiss) {
        Surface(
            modifier = Modifier
                .fillMaxWidth(0.9f)
                .fillMaxHeight(0.9f),
            shape = MaterialTheme.shapes.medium
        ) {
            Column(modifier = Modifier.padding(16.dp)) {
                // Header with close button
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        text = book.title,
                        style = MaterialTheme.typography.bodySmall
                    )
                    IconButton(onClick = onDismiss) {
                        Icon(
                            imageVector = Icons.Default.Close,
                            contentDescription = "Close"
                        )
                    }
                }

                HorizontalDivider(
                    modifier = Modifier.padding(vertical = 8.dp),
                    thickness = DividerDefaults.Thickness,
                    color = DividerDefaults.color
                )

                // Book content
                Box(modifier = Modifier.weight(1f)) {
                    BookContent(
                        lines = lines,
                        selectedLine = selectedLine
                    )
                }
            }
        }
    }
}
</file>

<file path="lib/sample/composeApp/src/commonMain/kotlin/sample/app/CategoryBookTree.kt">
package sample.app

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.KeyboardArrowRight
import androidx.compose.material.icons.filled.Book
import androidx.compose.material.icons.filled.Folder
import androidx.compose.material.icons.filled.KeyboardArrowDown
import androidx.compose.material3.Icon
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import io.github.kdroidfilter.seforimlibrary.core.models.Book
import io.github.kdroidfilter.seforimlibrary.core.models.Category

@Composable
fun CategoryBookTree(
    rootCategories: List<Category>,
    expandedCategories: Set<Long>,
    categoryChildren: Map<Long, List<Category>>,
    booksInCategory: Set<Book>,
    selectedCategory: Category?,
    selectedBook: Book?,
    onCategoryClick: (Category) -> Unit,
    onBookClick: (Book) -> Unit
) {
    LazyColumn {
        items(rootCategories) { category ->
            CategoryTreeItem(
                category = category,
                level = 0,
                expandedCategories = expandedCategories,
                categoryChildren = categoryChildren,
                booksInCategory = booksInCategory,
                selectedCategory = selectedCategory,
                selectedBook = selectedBook,
                onCategoryClick = onCategoryClick,
                onBookClick = onBookClick,
                maxLevel = 25
            )
        }
    }
}

@Composable
fun CategoryTreeItem(
    category: Category,
    level: Int,
    expandedCategories: Set<Long>,
    categoryChildren: Map<Long, List<Category>>,
    booksInCategory: Set<Book>,
    selectedCategory: Category?,
    selectedBook: Book?,
    onCategoryClick: (Category) -> Unit,
    onBookClick: (Book) -> Unit,
    maxLevel: Int
) {
    val isExpanded = expandedCategories.contains(category.id)
    val isSelected = selectedCategory?.id == category.id

    // Display the category item
    CategoryItem(
        category = category,
        level = level,
        isExpanded = isExpanded,
        isSelected = isSelected,
        onClick = { onCategoryClick(category) }
    )

    // If expanded, show children and/or books
    if (isExpanded) {
        // Show books in this category
        // Filter books that belong to this category
        val booksInThisCategory = booksInCategory.filter { it.categoryId == category.id }
        booksInThisCategory.forEach { book ->
            BookItem(
                book = book,
                level = level + 1,
                isSelected = selectedBook?.id == book.id,
                onClick = { onBookClick(book) }
            )
        }

        // Show child categories if not at max depth
        if (level < maxLevel - 1) {
            val children = categoryChildren[category.id] ?: emptyList()
            children.forEach { childCategory ->
                CategoryTreeItem(
                    category = childCategory,
                    level = level + 1,
                    expandedCategories = expandedCategories,
                    categoryChildren = categoryChildren,
                    booksInCategory = booksInCategory,
                    selectedCategory = selectedCategory,
                    selectedBook = selectedBook,
                    onCategoryClick = onCategoryClick,
                    onBookClick = onBookClick,
                    maxLevel = maxLevel
                )
            }
        }
    }
}

@Composable
fun CategoryItem(
    category: Category,
    level: Int,
    isExpanded: Boolean,
    isSelected: Boolean,
    onClick: () -> Unit
) {
    // Use LaunchedEffect to ensure proper recomposition when category changes
    LaunchedEffect(category.id) {
        // No action needed, just trigger recomposition
    }

    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClick)
            .padding(start = (level * 16).dp, top = 4.dp, bottom = 4.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        // Icon for expand/collapse
        Icon(
            imageVector = if (isExpanded) Icons.Default.KeyboardArrowDown else Icons.AutoMirrored.Filled.KeyboardArrowRight,
            contentDescription = if (isExpanded) "Collapse" else "Expand",
            tint = Color.Gray,
            modifier = Modifier.size(24.dp)
        )

        // Icon for folder
        Icon(
            imageVector = Icons.Default.Folder,
            contentDescription = "Folder",
            tint = if (isSelected) Color.Blue else Color.Gray,
            modifier = Modifier.size(24.dp)
        )

        Spacer(modifier = Modifier.width(8.dp))

        Text(
            text = category.title,
            fontWeight = if (isSelected) FontWeight.Bold else FontWeight.Normal,
            color = if (isSelected) Color.Blue else Color.Black
        )
    }
}

@Composable
fun BookItem(
    book: Book,
    level: Int,
    isSelected: Boolean,
    onClick: () -> Unit
) {
    // Use LaunchedEffect to ensure proper recomposition when book changes
    LaunchedEffect(book.id) {
        // No action needed, just trigger recomposition
    }

    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClick)
            .padding(start = (level * 16).dp, top = 4.dp, bottom = 4.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Spacer(modifier = Modifier.width(24.dp))

        // Icon for book
        Icon(
            imageVector = Icons.Default.Book,
            contentDescription = "Book",
            tint = if (isSelected) Color.Blue else Color.Gray,
            modifier = Modifier.size(24.dp)
        )

        Spacer(modifier = Modifier.width(8.dp))

        Text(
            text = book.title,
            fontWeight = if (isSelected) FontWeight.Bold else FontWeight.Normal,
            fontSize = 14.sp,
            color = if (isSelected) Color.Blue else Color.Black
        )
    }
}
</file>

<file path="lib/sample/composeApp/src/commonMain/kotlin/sample/app/LineCommentsView.kt">
package sample.app

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import io.github.kdroidfilter.seforimlibrary.core.models.ConnectionType
import io.github.kdroidfilter.seforimlibrary.core.models.Line
import io.github.kdroidfilter.seforimlibrary.dao.repository.CommentaryWithText

@Composable
fun LineCommentsView(
    selectedLine: Line?,
    commentaries: List<CommentaryWithText>,
    onCommentClick: (CommentaryWithText) -> Unit = {}
) {
    Column(modifier = Modifier.fillMaxSize().padding(16.dp)) {
        // Header
        Text(
            text = "פירושי שורה",
            fontWeight = FontWeight.Bold,
            fontSize = 16.sp,
            modifier = Modifier.padding(bottom = 8.dp)
        )

        if (selectedLine == null) {
            // No line selected
            Box(
                modifier = Modifier.fillMaxSize(),
                contentAlignment = Alignment.Center
            ) {
                Text("בחר שורה כדי לצפות בפירושים שלה")
            }
        } else {
            // Filter commentaries for the selected line
            val lineCommentaries = commentaries.filter { it.link.sourceLineId == selectedLine.id }

            if (lineCommentaries.isEmpty()) {
                Box(
                    modifier = Modifier.fillMaxWidth().weight(1f),
                    contentAlignment = Alignment.Center
                ) {
                    Text("אין פירושים זמינים לשורה זו")
                }
            } else {
                Text(
                    text = "פירושים (${lineCommentaries.size}):",
                    fontWeight = FontWeight.Bold,
                    fontSize = 14.sp,
                    modifier = Modifier.padding(bottom = 8.dp)
                )

                // State for selected tab
                var selectedTabIndex by remember { mutableStateOf(0) }

                // Get all connection types present in the commentaries
                val connectionTypes = lineCommentaries
                    .map { it.link.connectionType }
                    .distinct()
                    .ifEmpty { listOf(ConnectionType.OTHER) } // Fallback if no types found

                // Add "ALL" as the first tab with Hebrew titles
                val connectionTypeNames = connectionTypes.map { 
                    when (it) {
                        ConnectionType.COMMENTARY -> "פירוש"
                        ConnectionType.TARGUM -> "תרגום"
                        ConnectionType.REFERENCE -> "הפניה"
                        ConnectionType.OTHER -> "אחר"
                    }
                }
                val tabTitles = listOf("הכל") + connectionTypeNames

                // Tab row
                TabRow(
                    selectedTabIndex = selectedTabIndex,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    tabTitles.forEachIndexed { index, title ->
                        Tab(
                            selected = selectedTabIndex == index,
                            onClick = { selectedTabIndex = index },
                            text = { Text(title) }
                        )
                    }
                }

                Spacer(modifier = Modifier.height(8.dp))

                // Filter commentaries by selected connection type
                val filteredCommentaries = if (selectedTabIndex == 0) {
                    // "ALL" tab selected - show all commentaries
                    lineCommentaries
                } else {
                    // Filter by selected connection type
                    // Check if the index is within bounds
                    if (selectedTabIndex - 1 < connectionTypes.size) {
                        val selectedType = connectionTypes[selectedTabIndex - 1]
                        lineCommentaries.filter { it.link.connectionType == selectedType }
                    } else {
                        // Fallback to showing all commentaries if the index is out of bounds
                        lineCommentaries
                    }
                }

                // Group commentaries by book
                val commentariesByBook = filteredCommentaries.groupBy { it.targetBookTitle }

                LazyColumn(
                    modifier = Modifier.fillMaxWidth().weight(1f)
                ) {
                    commentariesByBook.forEach { (bookTitle, bookCommentaries) ->
                        item {
                            // Book header
                            Text(
                                text = bookTitle,
                                fontWeight = FontWeight.Bold,
                                fontSize = 16.sp,
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .background(MaterialTheme.colorScheme.secondary.copy(alpha = 0.2f))
                                    .padding(8.dp)
                            )
                        }

                        items(bookCommentaries) { commentary ->
                            Column(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .clickable { onCommentClick(commentary) }
                                    .padding(vertical = 8.dp, horizontal = 16.dp)
                            ) {
                                Text(
                                    text = commentary.targetText,
                                    fontSize = 14.sp
                                )
                            }
                            HorizontalDivider(Modifier, 0.5.dp, MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f))
                        }
                    }
                }
            }
        }
    }
}
</file>

<file path="lib/sample/composeApp/src/commonMain/kotlin/sample/app/LineWithUniqueKey.kt">
package sample.app

import io.github.kdroidfilter.seforimlibrary.core.models.Line
import kotlin.random.Random

/**
 * A wrapper class for Line that provides a unique key for use in LazyColumn.
 * This is used to ensure unique keys in LazyColumn even when the same Line object appears multiple times.
 */
data class LineWithUniqueKey(val line: Line) {
    // Generate a truly unique key for this line by combining its ID with a UUID-like string
    // This ensures uniqueness even if the same Line object appears multiple times
    val uniqueKey: String = "${line.id}_${System.nanoTime()}_${Random.nextInt()}"
    val content: String get() = line.content
}

/**
 * Extension function to convert a Line to a LineWithUniqueKey.
 */
fun Line.withUniqueKey(): LineWithUniqueKey = LineWithUniqueKey(this)

/**
 * Extension function to convert a list of Line objects to a list of LineWithUniqueKey objects.
 */
fun List<Line>.withUniqueKeys(): List<LineWithUniqueKey> = map { it.withUniqueKey() }
</file>

<file path="lib/sample/composeApp/src/commonMain/kotlin/sample/app/SearchPopup.kt">
package sample.app

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.Search
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.key.Key
import androidx.compose.ui.input.key.key
import androidx.compose.ui.input.key.onKeyEvent
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.TextFieldValue
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import androidx.compose.ui.window.DialogProperties
import com.mohamedrejeb.richeditor.model.rememberRichTextState
import com.mohamedrejeb.richeditor.ui.material.RichText
import io.github.kdroidfilter.seforimlibrary.core.models.SearchResult
import io.github.kdroidfilter.seforimlibrary.dao.repository.SeforimRepository
import kotlinx.coroutines.launch

/**
 * Modern search dialog with filtering capabilities
 */
@Composable
fun SearchPopup(
    repository: SeforimRepository,
    onDismiss: () -> Unit,
    onResultClick: (SearchResult) -> Unit
) {
    var searchQuery by remember { mutableStateOf(TextFieldValue("")) }
    var searchResults by remember { mutableStateOf<List<SearchResult>>(emptyList()) }
    var isSearching by remember { mutableStateOf(false) }
    var resultLimit by remember { mutableStateOf(50f) }
    var unlimitedResults by remember { mutableStateOf(false) }
    var selectedBooks by remember { mutableStateOf(setOf<Long>()) }
    val scope = rememberCoroutineScope()

    // Extract unique books from results
    val uniqueBooks = remember(searchResults) {
        searchResults.map { it.bookId to it.bookTitle }.distinct()
    }

    // Filter results based on selected books
    val filteredResults = remember(searchResults, selectedBooks) {
        if (selectedBooks.isEmpty()) searchResults
        else searchResults.filter { it.bookId in selectedBooks }
    }

    fun performSearch() {
        if (searchQuery.text.isBlank()) return
        scope.launch {
            isSearching = true
            selectedBooks = emptySet()
            val limit = if (unlimitedResults) -1 else resultLimit.toInt()
            searchResults = repository.search(searchQuery.text, limit)
            isSearching = false
        }
    }

    Dialog(
        onDismissRequest = onDismiss,
        properties = DialogProperties(usePlatformDefaultWidth = false)
    ) {
        Surface(
            modifier = Modifier
                .fillMaxWidth(0.85f)
                .fillMaxHeight(0.9f),
            shape = RoundedCornerShape(24.dp),
            color = MaterialTheme.colorScheme.surface,
            shadowElevation = 8.dp
        ) {
            Column {
                // Modern header
                Surface(
                    modifier = Modifier.fillMaxWidth(),
                    color = MaterialTheme.colorScheme.surfaceVariant
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(horizontal = 24.dp, vertical = 16.dp),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "חיפוש בספרייה", // Search Library
                            style = MaterialTheme.typography.headlineSmall,
                            fontWeight = FontWeight.Medium
                        )

                        IconButton(
                            onClick = onDismiss,
                            modifier = Modifier
                                .clip(RoundedCornerShape(12.dp))
                                .background(MaterialTheme.colorScheme.surface.copy(alpha = 0.5f))
                                .size(40.dp)
                        ) {
                            Icon(
                                Icons.Default.Close,
                                contentDescription = "Close",
                                modifier = Modifier.size(20.dp)
                            )
                        }
                    }
                }

                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(24.dp)
                ) {
                    // Search bar with modern styling
                    OutlinedTextField(
                        value = searchQuery,
                        onValueChange = { searchQuery = it },
                        modifier = Modifier
                            .fillMaxWidth()
                            .onKeyEvent {
                                if (it.key == Key.Enter) {
                                    performSearch()
                                    true
                                } else false
                            },
                        placeholder = { Text("הזן טקסט לחיפוש...") }, // Enter search text...
                        leadingIcon = {
                            Icon(
                                Icons.Default.Search,
                                contentDescription = null,
                                tint = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        },
                        trailingIcon = {
                            if (searchQuery.text.isNotEmpty()) {
                                IconButton(
                                    onClick = { performSearch() },
                                    enabled = !isSearching
                                ) {
                                    if (isSearching) {
                                        CircularProgressIndicator(
                                            modifier = Modifier.size(20.dp),
                                            strokeWidth = 2.dp
                                        )
                                    } else {
                                        Icon(
                                            Icons.Default.Search,
                                            contentDescription = "Search",
                                            tint = MaterialTheme.colorScheme.primary
                                        )
                                    }
                                }
                            }
                        },
                        shape = RoundedCornerShape(16.dp),
                        singleLine = true,
                        colors = OutlinedTextFieldDefaults.colors(
                            focusedBorderColor = MaterialTheme.colorScheme.primary,
                            unfocusedBorderColor = MaterialTheme.colorScheme.outline.copy(alpha = 0.5f)
                        )
                    )

                    // Results limit control
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(vertical = 16.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "תוצאות מקסימליות:", // Maximum results:
                            style = MaterialTheme.typography.bodyLarge,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )

                        Spacer(modifier = Modifier.weight(1f))

                        // Unlimited checkbox
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            modifier = Modifier.padding(end = 16.dp)
                        ) {
                            Checkbox(
                                checked = unlimitedResults,
                                onCheckedChange = { unlimitedResults = it }
                            )
                            Spacer(modifier = Modifier.width(4.dp))
                            Text(
                                text = "ללא הגבלה", // Unlimited
                                style = MaterialTheme.typography.bodyMedium
                            )
                        }

                        // Limit value display
                        Surface(
                            shape = RoundedCornerShape(8.dp),
                            color = if (unlimitedResults)
                                MaterialTheme.colorScheme.surfaceVariant
                            else
                                MaterialTheme.colorScheme.primaryContainer,
                            modifier = Modifier.padding(horizontal = 8.dp)
                        ) {
                            Text(
                                text = if (unlimitedResults) "∞" else resultLimit.toInt().toString(),
                                modifier = Modifier.padding(horizontal = 16.dp, vertical = 4.dp),
                                color = if (unlimitedResults)
                                    MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.5f)
                                else
                                    MaterialTheme.colorScheme.onPrimaryContainer,
                                fontWeight = FontWeight.Medium
                            )
                        }

                        // Slider (disabled when unlimited)
                        Slider(
                            value = resultLimit,
                            onValueChange = { resultLimit = it },
                            valueRange = 10f..1000f,
                            steps = 98,
                            modifier = Modifier.width(200.dp),
                            enabled = !unlimitedResults,
                            colors = SliderDefaults.colors(
                                thumbColor = MaterialTheme.colorScheme.primary,
                                activeTrackColor = MaterialTheme.colorScheme.primary,
                                disabledThumbColor = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.3f),
                                disabledActiveTrackColor = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.3f)
                            )
                        )
                    }

                    // Book filters as chips
                    if (uniqueBooks.isNotEmpty()) {
                        Column {
                            Text(
                                text = "סנן לפי ספר:", // Filter by book:
                                style = MaterialTheme.typography.titleMedium,
                                modifier = Modifier.padding(bottom = 8.dp)
                            )

                            LazyVerticalGrid(
                                columns = GridCells.Adaptive(minSize = 150.dp),
                                verticalArrangement = Arrangement.spacedBy(8.dp),
                                horizontalArrangement = Arrangement.spacedBy(8.dp),
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .height(120.dp)
                            ) {
                                items(uniqueBooks.size) { index ->
                                    val (bookId, bookTitle) = uniqueBooks[index]
                                    FilterChip(
                                        selected = bookId in selectedBooks,
                                        onClick = {
                                            selectedBooks = if (bookId in selectedBooks) {
                                                selectedBooks - bookId
                                            } else {
                                                selectedBooks + bookId
                                            }
                                        },
                                        label = {
                                            Text(
                                                bookTitle,
                                                maxLines = 1,
                                                style = MaterialTheme.typography.bodyMedium
                                            )
                                        },
                                        colors = FilterChipDefaults.filterChipColors(
                                            selectedContainerColor = MaterialTheme.colorScheme.primaryContainer
                                        )
                                    )
                                }
                            }
                        }

                        Spacer(modifier = Modifier.height(16.dp))
                    }

                    // Results area
                    Surface(
                        modifier = Modifier.fillMaxSize(),
                        shape = RoundedCornerShape(16.dp),
                        color = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.3f)
                    ) {
                        when {
                            isSearching -> {
                                Box(
                                    modifier = Modifier.fillMaxSize(),
                                    contentAlignment = Alignment.Center
                                ) {
                                    Column(
                                        horizontalAlignment = Alignment.CenterHorizontally,
                                        verticalArrangement = Arrangement.spacedBy(16.dp)
                                    ) {
                                        CircularProgressIndicator()
                                        Text(
                                            "מחפש...", // Searching...
                                            style = MaterialTheme.typography.bodyLarge
                                        )
                                        if (unlimitedResults) {
                                            Text(
                                                "חיפוש ללא הגבלה עשוי לקחת זמן רב", // Unlimited search may take a long time
                                                style = MaterialTheme.typography.bodySmall,
                                                color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.7f)
                                            )
                                        }
                                    }
                                }
                            }

                            searchQuery.text.isBlank() -> {
                                Box(
                                    modifier = Modifier.fillMaxSize(),
                                    contentAlignment = Alignment.Center
                                ) {
                                    Text(
                                        "הזן טקסט כדי להתחיל חיפוש", // Enter text to start searching
                                        style = MaterialTheme.typography.bodyLarge,
                                        color = MaterialTheme.colorScheme.onSurfaceVariant
                                    )
                                }
                            }

                            filteredResults.isEmpty() -> {
                                Box(
                                    modifier = Modifier.fillMaxSize(),
                                    contentAlignment = Alignment.Center
                                ) {
                                    Column(
                                        horizontalAlignment = Alignment.CenterHorizontally,
                                        verticalArrangement = Arrangement.spacedBy(8.dp)
                                    ) {
                                        Text(
                                            "לא נמצאו תוצאות", // No results found
                                            style = MaterialTheme.typography.headlineSmall,
                                            color = MaterialTheme.colorScheme.onSurfaceVariant
                                        )
                                        if (selectedBooks.isNotEmpty() && searchResults.isNotEmpty()) {
                                            Text(
                                                "נסה לשנות את הסינון", // Try changing the filter
                                                style = MaterialTheme.typography.bodyMedium,
                                                color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.7f)
                                            )
                                        }
                                    }
                                }
                            }

                            else -> {
                                LazyColumn(
                                    contentPadding = PaddingValues(16.dp),
                                    verticalArrangement = Arrangement.spacedBy(12.dp)
                                ) {
                                    // Results count header
                                    item {
                                        Row(
                                            modifier = Modifier
                                                .fillMaxWidth()
                                                .padding(bottom = 8.dp),
                                            horizontalArrangement = Arrangement.SpaceBetween,
                                            verticalAlignment = Alignment.CenterVertically
                                        ) {
                                            Text(
                                                text = "${filteredResults.size} תוצאות נמצאו", // X results found
                                                style = MaterialTheme.typography.titleSmall,
                                                color = MaterialTheme.colorScheme.onSurfaceVariant
                                            )
                                            if (selectedBooks.isNotEmpty() && filteredResults.size != searchResults.size) {
                                                Text(
                                                    text = "(${searchResults.size} סה״כ)", // (X total)
                                                    style = MaterialTheme.typography.bodySmall,
                                                    color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.7f)
                                                )
                                            }
                                        }
                                    }

                                    items(filteredResults) { result ->
                                        SearchResultCard(
                                            result = result,
                                            onClick = { onResultClick(result) }
                                        )
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

/**
 * Modern search result card
 */
@Composable
private fun SearchResultCard(
    result: SearchResult,
    onClick: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClick),
        shape = RoundedCornerShape(12.dp),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surface
        ),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            // Book info and content
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = result.bookTitle,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Medium,
                    color = MaterialTheme.colorScheme.primary
                )

                Spacer(modifier = Modifier.height(8.dp))

                // Rich text snippet
                val richTextState = rememberRichTextState()
                LaunchedEffect(result.snippet) {
                    richTextState.setHtml(result.snippet)
                }

                RichText(
                    state = richTextState,
                    modifier = Modifier.fillMaxWidth(),
                    style = MaterialTheme.typography.bodyMedium.copy(
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                )
            }

            // Line number badge
            Surface(
                modifier = Modifier
                    .align(Alignment.Top)
                    .padding(start = 16.dp),
                shape = RoundedCornerShape(8.dp),
                color = MaterialTheme.colorScheme.secondaryContainer
            ) {
                Text(
                    text = "שורה ${result.lineIndex + 1}", // Line X
                    modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp),
                    style = MaterialTheme.typography.labelMedium,
                    color = MaterialTheme.colorScheme.onSecondaryContainer
                )
            }
        }
    }
}
</file>

<file path="lib/sample/composeApp/src/commonMain/kotlin/sample/app/Theme.kt">
package sample.app

import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.graphics.Color

private val MonochromeColorScheme = lightColorScheme(
    primary = Color(0xFF333333),
    onPrimary = Color.White,
    primaryContainer = Color(0xFF555555),
    onPrimaryContainer = Color.White,
    secondary = Color(0xFF666666),
    onSecondary = Color.White,
    secondaryContainer = Color(0xFF888888),
    onSecondaryContainer = Color.White,
    tertiary = Color(0xFF666666),
    onTertiary = Color.White,
    tertiaryContainer = Color(0xFF888888),
    onTertiaryContainer = Color.White,
    error = Color(0xFF555555),
    onError = Color.White,
    errorContainer = Color(0xFF555555),
    onErrorContainer = Color.White,
    background = Color.White,
    onBackground = Color(0xFF333333),
    surface = Color(0xFFF5F5F5),
    onSurface = Color(0xFF333333),
    surfaceVariant = Color(0xFFEEEEEE),
    onSurfaceVariant = Color(0xFF333333),
    outline = Color(0xFF888888)
)


@Composable
fun AppTheme(content: @Composable () -> Unit) {
    MaterialTheme(
        colorScheme = MonochromeColorScheme,
        typography = notoFont(),
        content = content
    )
}
</file>

<file path="lib/sample/composeApp/src/commonMain/kotlin/sample/app/Type.kt">
package sample.app

import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Typography
import androidx.compose.runtime.Composable
import org.jetbrains.compose.resources.Font
import seforimlibrary.sample.composeapp.generated.resources.Res
import seforimlibrary.sample.composeapp.generated.resources.noto


@Composable
fun notoFont() = Typography(
    displayLarge = MaterialTheme.typography.displayLarge.copy(fontFamily = androidx.compose.ui.text.font.FontFamily(
        Font(
            Res.font.noto
        )
    )
    ),
    displayMedium = MaterialTheme.typography.displayMedium.copy(fontFamily = androidx.compose.ui.text.font.FontFamily(
        Font(Res.font.noto)
    )
    ),
    displaySmall = MaterialTheme.typography.displaySmall.copy(fontFamily = androidx.compose.ui.text.font.FontFamily(
        Font(
            Res.font.noto
        )
    )
    ),
    headlineLarge = MaterialTheme.typography.headlineLarge.copy(fontFamily = androidx.compose.ui.text.font.FontFamily(
        Font(Res.font.noto)
    )
    ),
    headlineMedium = MaterialTheme.typography.headlineMedium.copy(fontFamily = androidx.compose.ui.text.font.FontFamily(
        Font(Res.font.noto)
    )
    ),
    headlineSmall = MaterialTheme.typography.headlineSmall.copy(fontFamily = androidx.compose.ui.text.font.FontFamily(
        Font(Res.font.noto)
    )
    ),
    titleLarge = MaterialTheme.typography.titleLarge.copy(fontFamily = androidx.compose.ui.text.font.FontFamily(Font(Res.font.noto))),
    titleMedium = MaterialTheme.typography.titleMedium.copy(fontFamily = androidx.compose.ui.text.font.FontFamily(
        Font(
            Res.font.noto
        )
    )
    ),
    titleSmall = MaterialTheme.typography.titleSmall.copy(fontFamily = androidx.compose.ui.text.font.FontFamily(Font(Res.font.noto))),
    bodyLarge = MaterialTheme.typography.bodyLarge.copy(fontFamily = androidx.compose.ui.text.font.FontFamily(Font(Res.font.noto))),
    bodyMedium = MaterialTheme.typography.bodyMedium.copy(fontFamily = androidx.compose.ui.text.font.FontFamily(Font(Res.font.noto))),
    bodySmall = MaterialTheme.typography.bodySmall.copy(fontFamily = androidx.compose.ui.text.font.FontFamily(Font(Res.font.noto))),
    labelLarge = MaterialTheme.typography.labelLarge.copy(fontFamily = androidx.compose.ui.text.font.FontFamily(Font(Res.font.noto))),
    labelMedium = MaterialTheme.typography.labelMedium.copy(fontFamily = androidx.compose.ui.text.font.FontFamily(
        Font(
            Res.font.noto
        )
    )
    ),
    labelSmall = MaterialTheme.typography.labelSmall.copy(fontFamily = androidx.compose.ui.text.font.FontFamily(Font(Res.font.noto))),
)
</file>

<file path="lib/sample/composeApp/src/jvmMain/kotlin/sample/app/DatabaseUtils.kt">
package sample.app

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material.AlertDialog
import androidx.compose.material.Button
import androidx.compose.material.Icon
import androidx.compose.material.IconButton
import androidx.compose.material.Text
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.FolderOpen
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import app.cash.sqldelight.db.SqlDriver
import app.cash.sqldelight.driver.jdbc.sqlite.JdbcSqliteDriver
import io.github.kdroidfilter.seforimlibrary.dao.repository.SeforimRepository
import io.github.vinceglb.filekit.FileKit
import io.github.vinceglb.filekit.dialogs.FileKitType
import io.github.vinceglb.filekit.dialogs.openFilePicker
import io.github.vinceglb.filekit.path
import kotlinx.coroutines.launch
import java.io.File
import java.util.prefs.Preferences

// Preferences key for storing the database path
private const val PREF_DB_PATH = "database_path"

// Get preferences for storing the database path
private val prefs = Preferences.userNodeForPackage(SeforimRepository::class.java)

// Composable to show database selection dialog
@Composable
fun DatabaseSelectionDialog(
    currentPath: String,
    onPathSelected: (String) -> Unit,
    onDismiss: () -> Unit
) {
    val coroutineScope = rememberCoroutineScope()

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Select Database File") },
        text = { 
            Column {
                Text("Please select the database file for the application.")
                Spacer(modifier = Modifier.height(8.dp))
                Text("Current path: ${if (currentPath.isEmpty()) "Not set" else currentPath}")
            }
        },
        buttons = {
            Row(
                modifier = Modifier.fillMaxWidth().padding(8.dp),
                horizontalArrangement = Arrangement.End
            ) {
                Button(
                    onClick = {
                        // Use FileKit to select a database file
                        coroutineScope.launch {
                            val file = FileKit.openFilePicker() // Use default type to allow all files
                            if (file != null) {
                                onPathSelected(file.path)
                            }
                            onDismiss()
                        }
                    }
                ) {
                    Text("Select File")
                }

                Button(
                    onClick = onDismiss,
                    modifier = Modifier.padding(start = 8.dp)
                ) {
                    Text("Cancel")
                }
            }
        }
    )
}

// Composable to show database selection button
@Composable
fun DatabaseSelectionButton(onClick: () -> Unit) {
    IconButton(onClick = onClick) {
        Icon(Icons.Default.FolderOpen, contentDescription = "Select Database File")
    }
}

// Global state for dialog visibility
private val showDatabaseDialogState = mutableStateOf(false)

// Function to show the database selection dialog
fun showDatabaseSelectionDialog() {
    showDatabaseDialogState.value = true
}

@Composable
actual fun getDatabasePath(): String {
    // State to hold the database path
    var dbPath by remember { mutableStateOf(prefs.get(PREF_DB_PATH, "")) }

    // State to control the dialog visibility
    var showDialog by remember { showDatabaseDialogState }

    // Show dialog if path is not set
    LaunchedEffect(Unit) {
        if (dbPath.isEmpty() || !File(dbPath).exists()) {
            showDialog = true
        }
    }

    // Dialog to select database file
    if (showDialog) {
        DatabaseSelectionDialog(
            currentPath = dbPath,
            onPathSelected = { newPath ->
                dbPath = newPath
                // Save the path to preferences
                prefs.put(PREF_DB_PATH, dbPath)
            },
            onDismiss = { showDialog = false }
        )
    }

    return dbPath
}

@Composable
actual fun getRepository(): SeforimRepository {
    val dbPath = getDatabasePath()
    val driver: SqlDriver = remember(dbPath) {
        // Use the SQLite driver for desktop
        JdbcSqliteDriver("jdbc:sqlite:$dbPath")
    }

    return remember(driver) {
        SeforimRepository(dbPath, driver)
    }
}

@Composable
actual fun DatabaseSelectionButtonIfAvailable() {
    DatabaseSelectionButton(onClick = { showDatabaseSelectionDialog() })
}
</file>

<file path="lib/sample/composeApp/src/jvmMain/kotlin/sample/app/main.kt">
import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.unit.Density
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Window
import androidx.compose.ui.window.application
import androidx.compose.ui.window.rememberWindowState
import sample.app.App
import java.awt.Dimension
import java.util.Locale

fun main() {
    Locale.setDefault(Locale("he", "IL"))
    application {
        Window(
            title = "sample",
            state = rememberWindowState(width = 1280.dp, height = 720.dp),
            onCloseRequest = ::exitApplication,
        ) {
            window.minimumSize = Dimension(350, 600)
            CompositionLocalProvider(LocalDensity provides Density(density = 1f, fontScale = 1.0f)) {
                App()
            }
        }
    }
}
</file>

<file path="lib/sample/composeApp/build.gradle.kts">
import org.jetbrains.compose.desktop.application.dsl.TargetFormat

plugins {
    alias(libs.plugins.multiplatform)
    alias(libs.plugins.compose.compiler)
    alias(libs.plugins.compose)
    alias(libs.plugins.android.application)
}

kotlin {
    jvmToolchain(17)
    jvm()
    androidTarget()

    sourceSets {
        commonMain.dependencies {
            implementation(compose.runtime)
            implementation(compose.foundation)
            implementation(compose.material3)
            implementation(compose.materialIconsExtended)
            implementation(compose.components.resources)

            implementation(libs.kermit)
            implementation(project(":core"))
            implementation(project(":dao"))
            implementation("com.mohamedrejeb.richeditor:richeditor-compose:1.0.0-rc13")
            implementation("io.github.vinceglb:filekit-core:0.10.0-beta04")
            implementation("io.github.vinceglb:filekit-dialogs:0.10.0-beta04")
            implementation("io.github.vinceglb:filekit-dialogs-compose:0.10.0-beta04")
            implementation("androidx.sqlite:sqlite:2.5.0-alpha01")
            implementation("androidx.sqlite:sqlite-bundled:2.5.0-alpha01")
            implementation("com.eygraber:sqldelight-androidx-driver:0.0.13")

        }


        jvmMain.dependencies {
            implementation(compose.desktop.currentOs)
            implementation("app.cash.sqldelight:sqlite-driver:2.1.0")
            implementation("app.cash.sqldelight:jdbc-driver:2.1.0")
        }

        androidMain.dependencies {
            implementation("app.cash.sqldelight:android-driver:2.1.0")
            implementation("androidx.activity:activity-compose:1.8.2")
            implementation("androidx.appcompat:appcompat:1.7.1")

        }

    }
}

android {
    namespace = "sample.app"
    compileSdk = 35

    defaultConfig {
        minSdk = 24
        targetSdk = 34
        versionCode = 1
        versionName = "1.0.0"
    }

    buildTypes {
        release {
            isMinifyEnabled = false
        }
    }
}

compose.desktop {
    application {
        mainClass = "MainKt"

        nativeDistributions {
            modules("java.sql", "jdk.security.auth")
            targetFormats(TargetFormat.Dmg, TargetFormat.Msi, TargetFormat.Deb)
            packageName = "sample"
            packageVersion = "1.0.0"
        }
    }
}
</file>

<file path="lib/.git">
gitdir: ../.git/modules/SeforimLibrary
</file>

<file path="lib/.gitignore">
*.iml
.gradle
.idea
.kotlin
.DS_Store
build
*/build
captures
.externalNativeBuild
.cxx
local.properties
xcuserdata/
Pods/
*.jks
*.gpg
*yarn.lock
otzaria_latest
repomix-output.xml
*.db
*.db.bak
*.db-shm
*.db-wal
</file>

<file path="lib/build.gradle.kts">
plugins {
    alias(libs.plugins.multiplatform).apply(false)
    alias(libs.plugins.android.library).apply(false)
    alias(libs.plugins.maven.publish).apply(false)
    alias(libs.plugins.kotlinx.serialization).apply(false)
    alias(libs.plugins.sqlDelight).apply(false)
    alias(libs.plugins.android.application).apply(false)
}
</file>

<file path="lib/gradle.properties">
#Gradle
org.gradle.jvmargs=-Xmx4G
org.gradle.caching=true
org.gradle.configuration-cache=true
org.gradle.daemon=true
org.gradle.parallel=true

#Kotlin
kotlin.code.style=official
kotlin.daemon.jvmargs=-Xmx4G
kotlin.native.binary.gc=cms
kotlin.incremental.wasm=true

#Android
android.useAndroidX=true
android.nonTransitiveRClass=true
</file>

<file path="lib/gradlew">
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd "${APP_HOME:-./}" > /dev/null && pwd -P ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="lib/gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="lib/README.MD">
# SeforimLibrary

A Kotlin Multiplatform library for converting and accessing the Otzaria database in SQLite format with FTS5 full-text search capabilities.

## Overview

SeforimLibrary is a comprehensive solution for working with Jewish religious texts from the Otzaria database. The project converts the original Otzaria database into a modern SQLite database with full-text search capabilities using FTS5, making it efficient to search through large volumes of text.

The library is structured as a set of modules that can be imported via Maven:

- **core**: Contains data models representing entities like books, authors, categories, and lines of text
- **dao**: Provides database access objects and repositories for interacting with the SQLite database
- **generator**: Handles the conversion of the original Otzaria database to SQLite format

## Features

- Convert Otzaria database to SQLite format
- Efficient full-text search using SQLite's FTS5
- Hierarchical category and book organization
- Table of contents navigation for books
- Support for links between related texts
- Comprehensive data model for Jewish religious texts

## Run Sample App

- Desktop JVM: `./gradlew :sample:composeApp:run`
- Android: `open project in Android Studio and run the sample app`


## Requirements

- JDK 11 or higher
- Kotlin 1.9.0 or higher
- SQLite 3.35.0 or higher (for FTS5 support)

## Installation

Add the following to your `build.gradle.kts` file:

```kotlin
repositories {
    mavenCentral()
    // Add your repository if needed
}

dependencies {
    // Core models
    implementation("io.github.kdroidfilter:seforimlibrary-core:1.0.0")

    // Database access
    implementation("io.github.kdroidfilter:seforimlibrary-dao:1.0.0")

    // Optional: Database generator
    implementation("io.github.kdroidfilter:seforimlibrary-generator:1.0.0")
}
```

## Usage

### Initializing the Database

```kotlin
// Initialize the database
val dbPath = "path/to/your/database.db"
val driver = JdbcSqliteDriver(url = "jdbc:sqlite:$dbPath")
val repository = SeforimRepository(dbPath, driver)
```

### Searching for Text

```kotlin
// Search in all books
val searchResults = repository.search("your search query", limit = 20, offset = 0)

// Search in a specific book
val bookSearchResults = repository.searchInBook(bookId, "your search query")

// Search by author
val authorSearchResults = repository.searchByAuthor("author name", "your search query")
```

### Browsing Categories and Books

```kotlin
// Get root categories
val rootCategories = repository.getRootCategories()

// Get subcategories
val subcategories = repository.getCategoryChildren(parentId)

// Get books in a category
val books = repository.getBooksByCategory(categoryId)
```

### Reading Book Content

```kotlin
// Get book details
val book = repository.getBook(bookId)

// Get lines of text
val lines = repository.getLines(bookId, startIndex, endIndex)

// Get table of contents
val toc = repository.getBookToc(bookId)
```

## Database Generation

To convert the original Otzaria database to SQLite format:

```kotlin
// Initialize repository
val repository = SeforimRepository(dbPath, driver)

// Create generator with source directory
val sourcePath = Path("/path/to/otzaria_source")
val generator = DatabaseGenerator(sourcePath, repository)

// Generate the database
generator.generate()
```

## Project Structure

- **core**: Contains data models and extensions
  - `models`: Data classes representing entities in the database
  - `extensions`: Utility extensions for working with the models

- **dao**: Database access layer
  - `repository`: Repository classes for accessing the database
  - `extensions`: Extensions for converting between database and model objects
  - `sqldelight`: SQL queries and database schema

- **generator**: Database generation tools
  - `DatabaseGenerator`: Main class for converting Otzaria data to SQLite
  - `Main`: Entry point for running the generator as a standalone application
</file>

<file path="lib/settings.gradle.kts">
rootProject.name = "SeforimLibrary"

pluginManagement {
    repositories {
        google {
            content { 
              	includeGroupByRegex("com\\.android.*")
              	includeGroupByRegex("com\\.google.*")
              	includeGroupByRegex("androidx.*")
              	includeGroupByRegex("android.*")
            }
        }
        gradlePluginPortal()
        mavenCentral()
    }
}

dependencyResolutionManagement {
    repositories {
        google {
            content { 
              	includeGroupByRegex("com\\.android.*")
              	includeGroupByRegex("com\\.google.*")
              	includeGroupByRegex("androidx.*")
              	includeGroupByRegex("android.*")
            }
        }
        mavenCentral()
    }
}
include(":core")
include(":dao")
include(":generator")
include(":sample:composeApp")
</file>

<file path=".gitmodules">
[submodule "SeforimLibrary"]
	path = SeforimLibrary
	url = https://github.com/kdroidFilter/SeforimLibrary.git
</file>

<file path="composeApp/desktopAppIcons/MacosIcon.icns">
<!DOCTYPE html>
<html>
    <head>
        <link rel="icon" href="//netfree.link/img/block-favicon.png"/>
    </head>
    <body>
        <iframe id="netfree_block_iframe" name="netfree-block-iframe" src="https://netfree.link/block/#%7B%22block%22%3A%22error%22%2C%22sourceStatusCode%22%3A200%2C%22blockTechnicalInfo%22%3A%22Q1JZUFQyCIZUx7WKUdIxS7kOFSDf7QRqaCc%2F2sy5owdzFy6M2Og%2B4ts8lbeTlaUYSYx6rcP0hQlPMQ5DS6RepQNzlUvXsgJUPGS9BuNsvKpNvEzosjCFzRYp1QwQn65HdTwA1%2BPpNJaEvwuy%2Fhgymcl743PIDEkMlIhGulAsFOjeDMeX4MJpBXVjqq3Tl9OdxKB1WXTfn8d0B0yCERw1uK58%2FvruV%2Bn3NAGR9TMVJIcZQMX32F9cMpAh%2FUCjlPa1g8xSm9KaMY%2FsSJ6k1WZdLgMWP6iRpDQ5T7ZBvcwzELZM%2BJv2v1IR4QawLwXyUiK6kskezp3H3E2gALK835In2zCh0K5nvnpKMioslO3Gj%2BAWw8oqq6CnLWFyo1cy4xyuKQVVepeTL8Th0kdGhhQcuOS6skbOKFiIfQYVjlThN3vlzDiG1e5DrhPobgTHal9CNDlwXnW5DwyS60CcbdadH%2FiKs9UQWhgc4QiBTjdEW%2BNeYuXfnJ0Cg%2FUBRM%2F2%2Fk%2B9cgoQFuNXISFH%2FDwHBF9Aw53btFzLn8EBxJvpJpOjju99FZfH85X6NwZ0vBrtcvxgQGljG%2B6SHCgsBmaezarBMEg9IxvfiS2U7OgHZr%2BedekfMVO81LF6Ucg52RG2qHfMXG4ophADJ4RyxkcGIF1hoYhUn3n5CXYtDF8ldoAVu2IHaLkHorOYBmQ%2Biyhv9PUWzM%2BxN6l%2BdZqYFBFpjas1cDKWMsiG%2FyRBYqDGdx5j56%2BnzF8ucZwIORkBqt2yZ0mAZEYISk3hJCC4Xd5EQoj9MMGLyr%2Fw7PkFvShW%22%2C%22page_info%22%3A%7B%22url%22%3A%22https%3A%2F%2Fterrakok.github.io%2FCompose-Multiplatform-Wizard%2Fbinaries%2Fdesktop-app-icons%2FMacosIcon.icns%22%2C%22referer%22%3A%22https%3A%2F%2Fterrakok.github.io%2FCompose-Multiplatform-Wizard%2F%22%7D%7D" style=" position: fixed; top: 0; left: 0; width: 100%; height: 100%; border: none; "></iframe>
    </body>
</html>
</file>

<file path="composeApp/src/androidMain/kotlin/io/github/kdroidfilter/seforimapp/theme/Theme.android.kt">
package io.github.kdroidfilter.seforimapp.theme

import android.app.Activity
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.ui.platform.LocalView
import androidx.core.view.WindowInsetsControllerCompat

@Composable
internal actual fun SystemAppearance(isDark: Boolean) {
    val view = LocalView.current
    LaunchedEffect(isDark) {
        val window = (view.context as Activity).window
        WindowInsetsControllerCompat(window, window.decorView).apply {
            isAppearanceLightStatusBars = isDark
            isAppearanceLightNavigationBars = isDark
        }
    }
}
</file>

<file path="composeApp/src/androidMain/kotlin/io/github/kdroidfilter/seforimapp/App.android.kt">
package io.github.kdroidfilter.seforimapp

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge

class AppActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent { App() }
    }
}
</file>

<file path="composeApp/src/androidMain/res/mipmap-anydpi-v26/ic_launcher.xml">
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
  <background android:drawable="@mipmap/ic_launcher_background"/>
  <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
  <monochrome android:drawable="@mipmap/ic_launcher_monochrome"/>
</adaptive-icon>
</file>

<file path="composeApp/src/androidMain/AndroidManifest.xml">
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <application
        android:icon="@mipmap/ic_launcher"
        android:label="SeforimApp"
        android:theme="@android:style/Theme.Material.NoActionBar">
        <activity
            android:name=".AppActivity"
            android:configChanges="orientation|screenSize|screenLayout|keyboardHidden"
            android:launchMode="singleInstance"
            android:windowSoftInputMode="adjustPan"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>
</file>

<file path="composeApp/src/commonMain/composeResources/values/strings.xml">
<resources>
    <string name="app_name">ספורים</string>
</resources>
</file>

<file path="composeApp/src/commonMain/kotlin/io/github/kdroidfilter/seforimapp/theme/Color.kt">
package io.github.kdroidfilter.seforimapp.theme

import androidx.compose.ui.graphics.Color

//generated by https://materialkolor.com
//Color palette was taken here: https://coolors.co/palette/e63946-f1faee-a8dadc-457b9d-1d3557

internal val Seed = Color(0xFF1D3557)

internal val PrimaryLight = Color(0xFF485F84)
internal val OnPrimaryLight = Color(0xFFFFFFFF)
internal val PrimaryContainerLight = Color(0xFFD5E3FF)
internal val OnPrimaryContainerLight = Color(0xFF30476A)
internal val SecondaryLight = Color(0xFF2B6485)
internal val OnSecondaryLight = Color(0xFFFFFFFF)
internal val SecondaryContainerLight = Color(0xFFC7E7FF)
internal val OnSecondaryContainerLight = Color(0xFF064C6B)
internal val TertiaryLight = Color(0xFF356668)
internal val OnTertiaryLight = Color(0xFFFFFFFF)
internal val TertiaryContainerLight = Color(0xFFB9ECEE)
internal val OnTertiaryContainerLight = Color(0xFF1A4E50)
internal val ErrorLight = Color(0xFFBB152C)
internal val OnErrorLight = Color(0xFFFFFFFF)
internal val ErrorContainerLight = Color(0xFFFFDAD8)
internal val OnErrorContainerLight = Color(0xFF410007)
internal val BackgroundLight = Color(0xFFF9F9F9)
internal val OnBackgroundLight = Color(0xFF1A1C1C)
internal val SurfaceLight = Color(0xFFF9F9F9)
internal val OnSurfaceLight = Color(0xFF1A1C1C)
internal val SurfaceVariantLight = Color(0xFFDCE5D9)
internal val OnSurfaceVariantLight = Color(0xFF404941)
internal val OutlineLight = Color(0xFF717970)
internal val OutlineVariantLight = Color(0xFFC0C9BE)
internal val ScrimLight = Color(0xFF000000)
internal val InverseSurfaceLight = Color(0xFF2F3131)
internal val InverseOnSurfaceLight = Color(0xFFF0F1F1)
internal val InversePrimaryLight = Color(0xFFB0C7F1)
internal val SurfaceDimLight = Color(0xFFDADADA)
internal val SurfaceBrightLight = Color(0xFFF9F9F9)
internal val SurfaceContainerLowestLight = Color(0xFFFFFFFF)
internal val SurfaceContainerLowLight = Color(0xFFF3F3F4)
internal val SurfaceContainerLight = Color(0xFFEEEEEE)
internal val SurfaceContainerHighLight = Color(0xFFE8E8E8)
internal val SurfaceContainerHighestLight = Color(0xFFE2E2E2)

internal val PrimaryDark = Color(0xFFB0C7F1)
internal val OnPrimaryDark = Color(0xFF183153)
internal val PrimaryContainerDark = Color(0xFF30476A)
internal val OnPrimaryContainerDark = Color(0xFFD5E3FF)
internal val SecondaryDark = Color(0xFF98CDF2)
internal val OnSecondaryDark = Color(0xFF00344C)
internal val SecondaryContainerDark = Color(0xFF064C6B)
internal val OnSecondaryContainerDark = Color(0xFFC7E7FF)
internal val TertiaryDark = Color(0xFF9ECFD1)
internal val OnTertiaryDark = Color(0xFF003739)
internal val TertiaryContainerDark = Color(0xFF1A4E50)
internal val OnTertiaryContainerDark = Color(0xFFB9ECEE)
internal val ErrorDark = Color(0xFFFFB3B1)
internal val OnErrorDark = Color(0xFF680011)
internal val ErrorContainerDark = Color(0xFF92001C)
internal val OnErrorContainerDark = Color(0xFFFFDAD8)
internal val BackgroundDark = Color(0xFF121414)
internal val OnBackgroundDark = Color(0xFFE2E2E2)
internal val SurfaceDark = Color(0xFF121414)
internal val OnSurfaceDark = Color(0xFFE2E2E2)
internal val SurfaceVariantDark = Color(0xFF404941)
internal val OnSurfaceVariantDark = Color(0xFFC0C9BE)
internal val OutlineDark = Color(0xFF8A9389)
internal val OutlineVariantDark = Color(0xFF404941)
internal val ScrimDark = Color(0xFF000000)
internal val InverseSurfaceDark = Color(0xFFE2E2E2)
internal val InverseOnSurfaceDark = Color(0xFF2F3131)
internal val InversePrimaryDark = Color(0xFF485F84)
internal val SurfaceDimDark = Color(0xFF121414)
internal val SurfaceBrightDark = Color(0xFF37393A)
internal val SurfaceContainerLowestDark = Color(0xFF0C0F0F)
internal val SurfaceContainerLowDark = Color(0xFF1A1C1C)
internal val SurfaceContainerDark = Color(0xFF1E2020)
internal val SurfaceContainerHighDark = Color(0xFF282A2B)
internal val SurfaceContainerHighestDark = Color(0xFF333535)
</file>

<file path="composeApp/src/commonMain/kotlin/io/github/kdroidfilter/seforimapp/theme/Theme.kt">
package io.github.kdroidfilter.seforimapp.theme

import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.*

private val LightColorScheme = lightColorScheme(
    primary = PrimaryLight,
    onPrimary = OnPrimaryLight,
    primaryContainer = PrimaryContainerLight,
    onPrimaryContainer = OnPrimaryContainerLight,
    secondary = SecondaryLight,
    onSecondary = OnSecondaryLight,
    secondaryContainer = SecondaryContainerLight,
    onSecondaryContainer = OnSecondaryContainerLight,
    tertiary = TertiaryLight,
    onTertiary = OnTertiaryLight,
    tertiaryContainer = TertiaryContainerLight,
    onTertiaryContainer = OnTertiaryContainerLight,
    error = ErrorLight,
    onError = OnErrorLight,
    errorContainer = ErrorContainerLight,
    onErrorContainer = OnErrorContainerLight,
    background = BackgroundLight,
    onBackground = OnBackgroundLight,
    surface = SurfaceLight,
    onSurface = OnSurfaceLight,
    surfaceVariant = SurfaceVariantLight,
    onSurfaceVariant = OnSurfaceVariantLight,
    outline = OutlineLight,
    outlineVariant = OutlineVariantLight,
    scrim = ScrimLight,
    inverseSurface = InverseSurfaceLight,
    inverseOnSurface = InverseOnSurfaceLight,
    inversePrimary = InversePrimaryLight,
    surfaceDim = SurfaceDimLight,
    surfaceBright = SurfaceBrightLight,
    surfaceContainerLowest = SurfaceContainerLowestLight,
    surfaceContainerLow = SurfaceContainerLowLight,
    surfaceContainer = SurfaceContainerLight,
    surfaceContainerHigh = SurfaceContainerHighLight,
    surfaceContainerHighest = SurfaceContainerHighestLight,
)

private val DarkColorScheme = darkColorScheme(
    primary = PrimaryDark,
    onPrimary = OnPrimaryDark,
    primaryContainer = PrimaryContainerDark,
    onPrimaryContainer = OnPrimaryContainerDark,
    secondary = SecondaryDark,
    onSecondary = OnSecondaryDark,
    secondaryContainer = SecondaryContainerDark,
    onSecondaryContainer = OnSecondaryContainerDark,
    tertiary = TertiaryDark,
    onTertiary = OnTertiaryDark,
    tertiaryContainer = TertiaryContainerDark,
    onTertiaryContainer = OnTertiaryContainerDark,
    error = ErrorDark,
    onError = OnErrorDark,
    errorContainer = ErrorContainerDark,
    onErrorContainer = OnErrorContainerDark,
    background = BackgroundDark,
    onBackground = OnBackgroundDark,
    surface = SurfaceDark,
    onSurface = OnSurfaceDark,
    surfaceVariant = SurfaceVariantDark,
    onSurfaceVariant = OnSurfaceVariantDark,
    outline = OutlineDark,
    outlineVariant = OutlineVariantDark,
    scrim = ScrimDark,
    inverseSurface = InverseSurfaceDark,
    inverseOnSurface = InverseOnSurfaceDark,
    inversePrimary = InversePrimaryDark,
    surfaceDim = SurfaceDimDark,
    surfaceBright = SurfaceBrightDark,
    surfaceContainerLowest = SurfaceContainerLowestDark,
    surfaceContainerLow = SurfaceContainerLowDark,
    surfaceContainer = SurfaceContainerDark,
    surfaceContainerHigh = SurfaceContainerHighDark,
    surfaceContainerHighest = SurfaceContainerHighestDark,
)

internal val LocalThemeIsDark = compositionLocalOf { mutableStateOf(true) }

@Composable
internal fun AppTheme(
    content: @Composable () -> Unit
) {
    val systemIsDark = isSystemInDarkTheme()
    val isDarkState = remember(systemIsDark) { mutableStateOf(systemIsDark) }
    CompositionLocalProvider(
        LocalThemeIsDark provides isDarkState
    ) {
        val isDark by isDarkState
        SystemAppearance(!isDark)
        MaterialTheme(
            colorScheme = if (isDark) DarkColorScheme else LightColorScheme,
            content = { Surface(content = content) }
        )
    }
}

@Composable
internal expect fun SystemAppearance(isDark: Boolean)
</file>

<file path="composeApp/src/commonMain/kotlin/io/github/kdroidfilter/seforimapp/App.kt">
package io.github.kdroidfilter.seforimapp

import androidx.compose.animation.core.*
import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.rotate
import androidx.compose.ui.graphics.ColorFilter
import androidx.compose.ui.platform.LocalUriHandler
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.unit.dp
import seforimapp.composeapp.generated.resources.*
import io.github.kdroidfilter.seforimapp.theme.AppTheme
import io.github.kdroidfilter.seforimapp.theme.LocalThemeIsDark
import kotlinx.coroutines.isActive
import org.jetbrains.compose.resources.Font
import org.jetbrains.compose.resources.stringResource
import org.jetbrains.compose.resources.vectorResource
import org.jetbrains.compose.ui.tooling.preview.Preview

@Preview
@Composable
internal fun App() = AppTheme {

}
</file>

<file path="composeApp/src/jvmMain/kotlin/io/github/kdroidfilter/seforimapp/core/presentation/utils/WindowUtils.kt">
package io.github.kdroidfilter.seforimapp.core.presentation.utils

import androidx.compose.ui.input.key.Key
import androidx.compose.ui.input.key.KeyEvent
import androidx.compose.ui.input.key.KeyEventType
import androidx.compose.ui.input.key.isAltPressed
import androidx.compose.ui.input.key.key
import androidx.compose.ui.input.key.type
import androidx.compose.ui.unit.DpSize
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.WindowPosition
import androidx.compose.ui.window.WindowState
import java.awt.Toolkit

fun getCenteredWindowState(width: Int, height: Int): WindowState {
    val screenSize = Toolkit.getDefaultToolkit().screenSize
    val windowX = (screenSize.width - width) / 2
    val windowY = (screenSize.height - height) / 2

    return WindowState(
        size = DpSize(width.dp, height.dp),
        position = WindowPosition(windowX.dp, windowY.dp)
    )
}

fun processKeyShortcuts(keyEvent: KeyEvent, onNavigateTo: (String) -> Unit): Boolean {
    if (!keyEvent.isAltPressed || keyEvent.type != KeyEventType.KeyDown) return false
    return when (keyEvent.key) {
        Key.W -> {
            onNavigateTo("Welcome")
            true
        }

        Key.M -> {
            onNavigateTo("Markdown")
            true
        }

        Key.C -> {
            onNavigateTo("Components")
            true
        }

        else -> false
    }
}
</file>

<file path="composeApp/src/jvmMain/kotlin/io/github/kdroidfilter/seforimapp/framework/di/desktopModule.kt">
package io.github.kdroidfilter.seforimapp.framework.di

import org.koin.dsl.module

val desktopModule = module {

}
</file>

<file path="composeApp/src/jvmMain/kotlin/io/github/kdroidfilter/seforimapp/theme/Theme.jvm.kt">
package io.github.kdroidfilter.seforimapp.theme

import androidx.compose.runtime.Composable

@Composable
internal actual fun SystemAppearance(isDark: Boolean) {
}
</file>

<file path="composeApp/src/jvmMain/kotlin/main.kt">
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Surface
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.application
import com.kdroid.composetray.utils.SingleInstanceManager
import io.github.kdroidfilter.platformtools.darkmodedetector.isSystemInDarkMode
import io.github.kdroidfilter.seforimapp.App
import io.github.kdroidfilter.seforimapp.core.presentation.utils.getCenteredWindowState
import io.github.kdroidfilter.seforimapp.core.presentation.utils.processKeyShortcuts
import io.github.kdroidfilter.seforimapp.framework.di.desktopModule
import org.jetbrains.compose.resources.stringResource
import org.jetbrains.jewel.foundation.modifier.trackActivation
import org.jetbrains.jewel.foundation.theme.JewelTheme
import org.jetbrains.jewel.intui.standalone.theme.IntUiTheme
import org.jetbrains.jewel.intui.standalone.theme.darkThemeDefinition
import org.jetbrains.jewel.intui.standalone.theme.default
import org.jetbrains.jewel.intui.standalone.theme.lightThemeDefinition
import org.jetbrains.jewel.intui.window.decoratedWindow
import org.jetbrains.jewel.intui.window.styling.dark
import org.jetbrains.jewel.intui.window.styling.lightWithLightHeader
import org.jetbrains.jewel.ui.ComponentStyling
import org.jetbrains.jewel.window.DecoratedWindow
import org.jetbrains.jewel.window.TitleBar
import org.jetbrains.jewel.window.newFullscreenControls
import org.jetbrains.jewel.window.styling.TitleBarStyle
import org.koin.compose.KoinApplication
import seforimapp.composeapp.generated.resources.Res
import seforimapp.composeapp.generated.resources.app_name
import java.awt.Dimension
import java.awt.Window
import java.util.Locale

fun main() {
    Locale.setDefault(Locale("he","il"))
    application {
        val windowState = remember { getCenteredWindowState(1280, 720) }
        var isWindowVisible by remember { mutableStateOf(true) }
        val isDarkTheme = isSystemInDarkMode()

        val isSingleInstance = SingleInstanceManager.isSingleInstance(onRestoreRequest = {
            isWindowVisible = true
            windowState.isMinimized = false
            Window.getWindows().first().toFront()
        })
        if (!isSingleInstance) {
            exitApplication()
            return@application
        }
        KoinApplication(application = {
            modules(desktopModule)
        }) {
            IntUiTheme(
                theme = if (isDarkTheme) JewelTheme.darkThemeDefinition() else JewelTheme.lightThemeDefinition(),
                styling = ComponentStyling.default()
                    .decoratedWindow(titleBarStyle = if (isSystemInDarkMode()) TitleBarStyle.dark() else TitleBarStyle.lightWithLightHeader()),
            ) {
                DecoratedWindow(
                    onCloseRequest = { exitApplication() },
                    title = stringResource(Res.string.app_name),
//            icon = painterResource(Res.drawable.icon),
                    state = windowState,
                    visible = isWindowVisible,
                    onKeyEvent = { keyEvent ->
                        processKeyShortcuts(keyEvent = keyEvent, onNavigateTo = {
                            //TODO
                        })
                    },                ) {
                    window.minimumSize = Dimension(350, 600)
                    TitleBar(modifier = Modifier.newFullscreenControls()) {

                    }
                    Column (
                        modifier =
                            Modifier.trackActivation().fillMaxSize().background(JewelTheme.globalColors.panelBackground),
                    ) {

                    }
                }
            }
        }
    }
}
</file>

<file path="composeApp/build.gradle.kts">
import org.jetbrains.compose.ExperimentalComposeLibrary
import org.jetbrains.compose.desktop.application.dsl.TargetFormat
import org.jetbrains.compose.reload.ComposeHotRun
import org.jetbrains.kotlin.compose.compiler.gradle.ComposeFeatureFlag
import org.jetbrains.kotlin.gradle.plugin.KotlinSourceSetTree

plugins {
    alias(libs.plugins.multiplatform)
    alias(libs.plugins.compose.compiler)
    alias(libs.plugins.compose)
    alias(libs.plugins.android.application)
    alias(libs.plugins.hotReload)
    alias(libs.plugins.kotlinx.serialization)
    alias(libs.plugins.buildConfig)
}

kotlin {
    androidTarget {
        //https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-test.html
        instrumentedTestVariant.sourceSetTree.set(KotlinSourceSetTree.test)
    }

    jvm()

    sourceSets {
        commonMain.dependencies {
            implementation(compose.runtime)
            implementation(compose.foundation)
            implementation(compose.material3)
            implementation(compose.components.resources)
            implementation(compose.components.uiToolingPreview)
            implementation(libs.kermit)
            implementation(libs.ktor.client.core)
            implementation(libs.ktor.client.content.negotiation)
            implementation(libs.ktor.client.serialization)
            implementation(libs.ktor.serialization.json)
            implementation(libs.ktor.client.logging)
            implementation(libs.androidx.lifecycle.viewmodel)
            implementation(libs.androidx.lifecycle.runtime)
            implementation(libs.androidx.navigation.compose)
            implementation(libs.kotlinx.serialization.json)
            implementation(libs.kotlinx.coroutines.core)
            implementation(libs.koin.core)
            implementation(libs.koin.compose)
            implementation(libs.multiplatformSettings)
            implementation(libs.kotlinx.datetime)
            implementation(libs.materialKolor)
            implementation(libs.platformtools.core)
            implementation(libs.platformtools.darkmodedetector)
            //IMPLEMENT HERE CORE AND DAO


        }

        commonTest.dependencies {
            implementation(kotlin("test"))
            @OptIn(ExperimentalComposeLibrary::class)
            implementation(compose.uiTest)
        }

        androidMain.dependencies {
            implementation(compose.uiTooling)
            implementation(libs.androidx.activityCompose)
            implementation(libs.ktor.client.okhttp)
            implementation(libs.kotlinx.coroutines.android)
        }

        jvmMain.dependencies {
            implementation(compose.desktop.currentOs) {
                exclude(group = "org.jetbrains.compose.material")
            }

            implementation(libs.ktor.client.okhttp)
            implementation(libs.platformtools.rtlwindows)
            implementation(libs.composenativetray)
            implementation(libs.kotlinx.coroutines.swing)
            implementation(libs.slf4j.simple)

            api(project(":jewel"))
        }

    }
}

android {
    namespace = "io.github.kdroidfilter.seforimapp"
    compileSdk = 35

    defaultConfig {
        minSdk = 21
        targetSdk = 35

        applicationId = "io.github.kdroidfilter.seforimapp.androidApp"
        versionCode = 1
        versionName = "1.0.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }
}

//https://developer.android.com/develop/ui/compose/testing#setup
dependencies {
    androidTestImplementation(libs.androidx.uitest.junit4)
    debugImplementation(libs.androidx.uitest.testManifest)
}

compose.desktop {
    application {
        mainClass = "MainKt"

        nativeDistributions {
            targetFormats(TargetFormat.Dmg, TargetFormat.Msi, TargetFormat.Deb)
            packageName = "SeforimApp"
            packageVersion = "1.0.0"

            linux {
                iconFile.set(project.file("desktopAppIcons/LinuxIcon.png"))
            }
            windows {
                iconFile.set(project.file("desktopAppIcons/WindowsIcon.ico"))
            }
            macOS {
                iconFile.set(project.file("desktopAppIcons/MacosIcon.icns"))
                bundleID = "io.github.kdroidfilter.seforimapp.desktopApp"
            }
        }
    }
}

//https://github.com/JetBrains/compose-hot-reload
composeCompiler {
    featureFlags.add(ComposeFeatureFlag.OptimizeNonSkippingGroups)
}
tasks.withType<ComposeHotRun>().configureEach {
    mainClass.set("MainKt")
}

buildConfig {
    // BuildConfig configuration here.
    // https://github.com/gmazzo/gradle-buildconfig-plugin#usage-in-kts
}
</file>

<file path="gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.14.2-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="gradle/libs.versions.toml">
[versions]

kotlin = "2.2.0"
compose = "1.8.2"
agp = "8.10.0"
androidx-activityCompose = "1.10.1"
androidx-uiTest = "1.8.3"
hotReload = "1.0.0-alpha11"
kermit = "2.0.6"
ktor = "3.2.1"
androidx-lifecycle = "2.9.1"
androidx-navigation = "2.9.0-beta03"
kotlinx-serialization = "1.9.0"
koin = "4.1.0"
multiplatformSettings = "1.3.0"
kotlinx-datetime = "0.7.0"
buildConfig = "5.6.5"
materialKolor = "2.1.1"
jewel = "0.28.0-252.15920"
jna = "5.17.0"
platformtools = "0.4.0"
composenativetray = "0.6.7"
kotlinx-coroutines = "1.10.2"
slf4j = "2.0.17"

[libraries]

androidx-activityCompose = { module = "androidx.activity:activity-compose", version.ref = "androidx-activityCompose" }
androidx-uitest-testManifest = { module = "androidx.compose.ui:ui-test-manifest", version.ref = "androidx-uiTest" }
androidx-uitest-junit4 = { module = "androidx.compose.ui:ui-test-junit4", version.ref = "androidx-uiTest" }
kermit = { module = "co.touchlab:kermit", version.ref = "kermit" }
ktor-client-core = { module = "io.ktor:ktor-client-core", version.ref = "ktor" }
ktor-client-content-negotiation = { module = "io.ktor:ktor-client-content-negotiation", version.ref = "ktor" }
ktor-client-serialization = { module = "io.ktor:ktor-client-serialization", version.ref = "ktor" }
ktor-serialization-json = { module = "io.ktor:ktor-serialization-kotlinx-json", version.ref = "ktor" }
ktor-client-logging = { module = "io.ktor:ktor-client-logging", version.ref = "ktor" }
ktor-client-darwin = { module = "io.ktor:ktor-client-darwin", version.ref = "ktor" }
ktor-client-okhttp = { module = "io.ktor:ktor-client-okhttp", version.ref = "ktor" }
ktor-client-js = { module = "io.ktor:ktor-client-js", version.ref = "ktor" }
ktor-client-curl = { module = "io.ktor:ktor-client-curl", version.ref = "ktor" }
ktor-client-winhttp = { module = "io.ktor:ktor-client-winhttp", version.ref = "ktor" }
androidx-lifecycle-viewmodel = { module = "org.jetbrains.androidx.lifecycle:lifecycle-viewmodel-compose", version.ref = "androidx-lifecycle" }
androidx-lifecycle-runtime = { module = "org.jetbrains.androidx.lifecycle:lifecycle-runtime-compose", version.ref = "androidx-lifecycle" }
androidx-navigation-compose = { module = "org.jetbrains.androidx.navigation:navigation-compose", version.ref = "androidx-navigation" }
kotlinx-serialization-json = { module = "org.jetbrains.kotlinx:kotlinx-serialization-json", version.ref = "kotlinx-serialization" }
koin-core = { module = "io.insert-koin:koin-core", version.ref = "koin" }
koin-compose = { module = "io.insert-koin:koin-compose", version.ref = "koin" }
multiplatformSettings = { module = "com.russhwolf:multiplatform-settings-no-arg", version.ref = "multiplatformSettings" }
kotlinx-datetime = { module = "org.jetbrains.kotlinx:kotlinx-datetime", version.ref = "kotlinx-datetime" }
materialKolor = { module = "com.materialkolor:material-kolor", version.ref = "materialKolor" }
foundation-desktop = { module = "org.jetbrains.compose.foundation:foundation-desktop", version.ref = "compose" }
jetbrains-jewel-foundation = { module = "org.jetbrains.jewel:jewel-foundation", version.ref = "jewel" }
jewel-decorated-window = { module = "org.jetbrains.jewel:jewel-decorated-window", version.ref = "jewel" }
jewel-int-ui-decorated-window = { module = "org.jetbrains.jewel:jewel-int-ui-decorated-window", version.ref = "jewel" }
jewel-int-ui-standalone = { module = "org.jetbrains.jewel:jewel-int-ui-standalone", version.ref = "jewel" }
jewel-ui = { module = "org.jetbrains.jewel:jewel-ui", version.ref = "jewel" }
jna = { module = "net.java.dev.jna:jna", version.ref = "jna" }
platformtools-core = { module = "io.github.kdroidfilter:platformtools.core", version.ref = "platformtools" }
platformtools-darkmodedetector = { module = "io.github.kdroidfilter:platformtools.darkmodedetector", version.ref = "platformtools" }
platformtools-rtlwindows = { module = "io.github.kdroidfilter:platformtools.rtlwindows", version.ref = "platformtools" }
composenativetray = { module = "io.github.kdroidfilter:composenativetray", version.ref = "composenativetray" }
kotlinx-coroutines-core = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-core", version.ref = "kotlinx-coroutines" }
kotlinx-coroutines-android = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-android", version.ref = "kotlinx-coroutines" }
kotlinx-coroutines-swing = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-swing", version.ref = "kotlinx-coroutines" }
slf4j-simple = { module = "org.slf4j:slf4j-simple", version.ref = "slf4j" }

[plugins]

multiplatform = { id = "org.jetbrains.kotlin.multiplatform", version.ref = "kotlin" }
compose-compiler = { id = "org.jetbrains.kotlin.plugin.compose", version.ref = "kotlin" }
compose = { id = "org.jetbrains.compose", version.ref = "compose" }
android-application = { id = "com.android.application", version.ref = "agp" }
hotReload = { id = "org.jetbrains.compose.hot-reload", version.ref = "hotReload" }
kotlinx-serialization = { id = "org.jetbrains.kotlin.plugin.serialization", version.ref = "kotlin" }
buildConfig = { id = "com.github.gmazzo.buildconfig", version.ref = "buildConfig" }
</file>

<file path="jewel/src/jvmMain/java/com/jetbrains/DesktopActions.java">
/*
 * Copyright 2000-2022 JetBrains s.r.o.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.jetbrains;

import java.io.File;
import java.io.IOException;
import java.net.URI;

public interface DesktopActions {

    void setHandler(Handler handler);

    interface Handler {
        default void open(File file) throws IOException { throw new UnsupportedOperationException(); }
        default void edit(File file) throws IOException { throw new UnsupportedOperationException(); }
        default void print(File file) throws IOException { throw new UnsupportedOperationException(); }
        default void mail(URI mailtoURL) throws IOException { throw new UnsupportedOperationException(); }
        default void browse(URI uri) throws IOException { throw new UnsupportedOperationException(); }
    }

}
</file>

<file path="jewel/src/jvmMain/java/com/jetbrains/JBR.java">
// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.

package com.jetbrains;

import java.lang.invoke.MethodHandles;
import java.lang.reflect.InvocationTargetException;

/**
 * This class is an entry point into JBR API.
 * JBR API is a collection of services, classes, interfaces, etc.,
 * which require tight interaction with JRE and therefore are implemented inside JBR.
 * <div>JBR API consists of two parts:</div>
 * <ul>
 *     <li>Client side - {@code jetbrains.api} module, mostly containing interfaces</li>
 *     <li>JBR side - actual implementation code inside JBR</li>
 * </ul>
 * Client and JBR side are linked dynamically at runtime and do not have to be of the same version.
 * In some cases (e.g. running on different JRE or old JBR) system will not be able to find
 * implementation for some services, so you'll need a fallback behavior for that case.
 * <h2>Simple usage example:</h2>
 * <blockquote><pre>{@code
 * if (JBR.isSomeServiceSupported()) {
 *     JBR.getSomeService().doSomething();
 * } else {
 *     planB();
 * }
 * }</pre></blockquote>
 *
 * @implNote JBR API is initialized on first access to this class (in static initializer).
 * Actual implementation is linked on demand, when corresponding service is requested by client.
 */
public final class JBR {

    private static final ServiceApi api;
    private static final Exception bootstrapException;

    static {
        ServiceApi a = null;
        Exception exception = null;
        try {
            a = (ServiceApi) Class.forName("com.jetbrains.bootstrap.JBRApiBootstrap")
                    .getMethod("bootstrap", MethodHandles.Lookup.class)
                    .invoke(null, MethodHandles.lookup());
        } catch (InvocationTargetException e) {
            Throwable t = e.getCause();
            if (t instanceof Error error) throw error;
            else throw new Error(t);
        } catch (IllegalAccessException | NoSuchMethodException | ClassNotFoundException e) {
            exception = e;
        }
        api = a;
        bootstrapException = exception;
    }

    private JBR() {
    }

    private static <T> T getService(Class<T> interFace, FallbackSupplier<T> fallback) {
        T service = getService(interFace);
        try {
            return service != null ? service : fallback != null ? fallback.get() : null;
        } catch (Throwable ignore) {
            return null;
        }
    }

    static <T> T getService(Class<T> interFace) {
        return api == null ? null : api.getService(interFace);
    }

    /**
     * @return true when running on JBR which implements JBR API
     */
    public static boolean isAvailable() {
        return api != null;
    }

    /**
     * @return JBR API version in form {@code JBR.MAJOR.MINOR.PATCH}
     * @implNote This is an API version, which comes with client application,
     * it has nothing to do with JRE it runs on.
     */
    public static String getApiVersion() {
        return "17.0.8.1b1070.2.1.9.0";
    }

    /**
     * Internal API interface, contains most basic methods for communication between client and JBR.
     */
    private interface ServiceApi {

        <T> T getService(Class<T> interFace);
    }

    @FunctionalInterface
    private interface FallbackSupplier<T> {
        T get() throws Throwable;
    }

    // ========================== Generated metadata ==========================

    /**
     * Generated client-side metadata, needed by JBR when linking the implementation.
     */
    private static final class Metadata {
        private static final String[] KNOWN_SERVICES = {"com.jetbrains.ExtendedGlyphCache", "com.jetbrains.DesktopActions", "com.jetbrains.CustomWindowDecoration", "com.jetbrains.ProjectorUtils", "com.jetbrains.FontExtensions", "com.jetbrains.RoundedCornersManager", "com.jetbrains.GraphicsUtils", "com.jetbrains.WindowDecorations", "com.jetbrains.JBRFileDialogService", "com.jetbrains.AccessibleAnnouncer", "com.jetbrains.JBR$ServiceApi", "com.jetbrains.Jstack", "com.jetbrains.WindowMove"};
        private static final String[] KNOWN_PROXIES = {"com.jetbrains.JBRFileDialog", "com.jetbrains.WindowDecorations$CustomTitleBar"};
    }

    // ======================= Generated static methods =======================

    private static class DesktopActions__Holder {
        private static final DesktopActions INSTANCE = getService(DesktopActions.class, null);
    }

    /**
     * @return true if current runtime has implementation for all methods in {@link DesktopActions}
     * and its dependencies (can fully implement given service).
     * @see #getDesktopActions()
     */
    public static boolean isDesktopActionsSupported() {
        return DesktopActions__Holder.INSTANCE != null;
    }

    /**
     * @return full implementation of {@link DesktopActions} service if any, or {@code null} otherwise
     */
    public static DesktopActions getDesktopActions() {
        return DesktopActions__Holder.INSTANCE;
    }

    private static class RoundedCornersManager__Holder {
        private static final RoundedCornersManager INSTANCE = getService(RoundedCornersManager.class, null);
    }

    /**
     * @return true if current runtime has implementation for all methods in {@link RoundedCornersManager}
     * and its dependencies (can fully implement given service).
     * @see #getRoundedCornersManager()
     */
    public static boolean isRoundedCornersManagerSupported() {
        return RoundedCornersManager__Holder.INSTANCE != null;
    }

    /**
     * This manager allows decorate awt Window with rounded corners.
     * Appearance depends from operating system.
     *
     * @return full implementation of {@link RoundedCornersManager} service if any, or {@code null} otherwise
     */
    public static RoundedCornersManager getRoundedCornersManager() {
        return RoundedCornersManager__Holder.INSTANCE;
    }

    private static class WindowDecorations__Holder {
        private static final WindowDecorations INSTANCE = getService(WindowDecorations.class, null);
    }

    /**
     * @return true if current runtime has implementation for all methods in {@link WindowDecorations}
     * and its dependencies (can fully implement given service).
     * @see #getWindowDecorations()
     */
    public static boolean isWindowDecorationsSupported() {
        return WindowDecorations__Holder.INSTANCE != null;
    }

    /**
     * Window decorations consist of title bar, window controls and border.
     *
     * @return full implementation of {@link WindowDecorations} service if any, or {@code null} otherwise
     * @see WindowDecorations.CustomTitleBar
     */
    public static WindowDecorations getWindowDecorations() {
        return WindowDecorations__Holder.INSTANCE;
    }

    private static class WindowMove__Holder {
        private static final WindowMove INSTANCE = getService(WindowMove.class, null);
    }

    /**
     * @return true if current runtime has implementation for all methods in {@link WindowMove}
     * and its dependencies (can fully implement given service).
     * @see #getWindowMove()
     */
    public static boolean isWindowMoveSupported() {
        return WindowMove__Holder.INSTANCE != null;
    }

    /**
     * @return full implementation of {@link WindowMove} service if any, or {@code null} otherwise
     */
    public static WindowMove getWindowMove() {
        return WindowMove__Holder.INSTANCE;
    }
}
</file>

<file path="jewel/src/jvmMain/java/com/jetbrains/RoundedCornersManager.java">
/*
 * Copyright 2000-2023 JetBrains s.r.o.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.jetbrains;

import java.awt.*;

/**
 * This manager allows decorated AWT Window with rounded corners.
 * The appearance depends on the operating system.
 */
public interface RoundedCornersManager {
    /**
     * Sets rounded corners on the target {@link Window}.
     *
     * @param params For macOS, it is a {@code Float} object with the radius or an Array containing:
     *               <ul>
     *               <li>A {@code Float} for the radius</li>
     *               <li>An {@code Integer} for the border width</li>
     *               <li>A {@code java.awt.Color} for the border color</li>
     *               </ul>
     *               <br/>
     *               For Windows 11, it is a {@code String} with one of these values:
     *               <ul>
     *               <li>{@code "default"} — let the system decide whether to round window corners</li>
     *               <li>{@code "none"} — never round window corners</li>
     *               <li>{@code "full"} — round the corners if appropriate</li>
     *               <li>{@code "small"} — round the corners if appropriate, with a small radius</li>
     *               </ul>
     *               <br/>
     */
    void setRoundedCorners(Window window, Object params);
}
</file>

<file path="jewel/src/jvmMain/java/com/jetbrains/WindowDecorations.java">
/*
 * Copyright 2023 JetBrains s.r.o.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation. Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.jetbrains;

import java.awt.*;
import java.util.Map;

/**
 * Window decorations consist of title bar, window controls and border.
 * @see CustomTitleBar
 */
public interface WindowDecorations {

    /**
     * If {@code customTitleBar} is not null, system-provided title bar is removed and client area is extended to the
     * top of the frame with window controls painted over the client area.
     * {@code customTitleBar=null} resets to the default appearance with system-provided title bar.
     * @see CustomTitleBar
     * @see #createCustomTitleBar()
     */
    void setCustomTitleBar(Frame frame, CustomTitleBar customTitleBar);

    /**
     * If {@code customTitleBar} is not null, system-provided title bar is removed and client area is extended to the
     * top of the dialog with window controls painted over the client area.
     * {@code customTitleBar=null} resets to the default appearance with system-provided title bar.
     * @see CustomTitleBar
     * @see #createCustomTitleBar()
     */
    void setCustomTitleBar(Dialog dialog, CustomTitleBar customTitleBar);

    /**
     * You must {@linkplain CustomTitleBar#setHeight(float) set title bar height} before adding it to a window.
     * @see CustomTitleBar
     * @see #setCustomTitleBar(Frame, CustomTitleBar)
     * @see #setCustomTitleBar(Dialog, CustomTitleBar)
     */
    CustomTitleBar createCustomTitleBar();

    /**
     * Custom title bar allows merging of window content with native title bar,
     * which is done by treating title bar as part of client area, but with some
     * special behavior like dragging or maximizing on double click.
     * Custom title bar has {@linkplain CustomTitleBar#getHeight()  height} and controls.
     * @implNote Behavior is platform-dependent, only macOS and Windows are supported.
     * @see #setCustomTitleBar(Frame, CustomTitleBar)
     */
    interface CustomTitleBar {

        /**
         * @return title bar height, measured in pixels from the top of client area, i.e. excluding top frame border.
         */
        float getHeight();

        /**
         * @param height title bar height, measured in pixels from the top of client area,
         *               i.e. excluding top frame border. Must be > 0.
         */
        void setHeight(float height);

        /**
         * @see #putProperty(String, Object)
         */
        Map<String, Object> getProperties();

        /**
         * @see #putProperty(String, Object)
         */
        void putProperties(Map<String, ?> m);

        /**
         * Windows & macOS properties:
         * <ul>
         *     <li>{@code controls.visible} : {@link Boolean} - whether title bar controls
         *         (minimize/maximize/close buttons) are visible, default = true.</li>
         * </ul>
         * Windows properties:
         * <ul>
         *     <li>{@code controls.width} : {@link Number} - width of block of buttons (not individual buttons).
         *         Note that dialogs have only one button, while frames usually have 3 of them.</li>
         *     <li>{@code controls.dark} : {@link Boolean} - whether to use dark or light color theme
         *         (light or dark icons respectively).</li>
         *     <li>{@code controls.<layer>.<state>} : {@link Color} - precise control over button colors,
         *         where {@code <layer>} is one of:
         *         <ul><li>{@code foreground}</li><li>{@code background}</li></ul>
         *         and {@code <state>} is one of:
         *         <ul>
         *             <li>{@code normal}</li>
         *             <li>{@code hovered}</li>
         *             <li>{@code pressed}</li>
         *             <li>{@code disabled}</li>
         *             <li>{@code inactive}</li>
         *         </ul>
         * </ul>
         */
        void putProperty(String key, Object value);

        /**
         * @return space occupied by title bar controls on the left (px)
         */
        float getLeftInset();
        /**
         * @return space occupied by title bar controls on the right (px)
         */
        float getRightInset();

        /**
         * By default, any component which has no cursor or mouse event listeners set is considered transparent for
         * native title bar actions. That is, dragging simple JPanel in title bar area will drag the
         * window, but dragging a JButton will not. Adding mouse listener to a component will prevent any native actions
         * inside bounds of that component.
         * <p>
         * This method gives you precise control of whether to allow native title bar actions or not.
         * <ul>
         *     <li>{@code client=true} means that mouse is currently over a client area. Native title bar behavior is disabled.</li>
         *     <li>{@code client=false} means that mouse is currently over a non-client area. Native title bar behavior is enabled.</li>
         * </ul>
         * <em>Intended usage:
         * <ul>
         *     <li>This method must be called in response to all {@linkplain java.awt.event.MouseEvent mouse events}
         *         except {@link java.awt.event.MouseEvent#MOUSE_EXITED} and {@link java.awt.event.MouseEvent#MOUSE_WHEEL}.</li>
         *     <li>This method is called per-event, i.e. when component has multiple listeners, you only need to call it once.</li>
         *     <li>If this method hadn't been called, title bar behavior is reverted back to default upon processing the event.</li>
         * </ul></em>
         * Note that hit test value is relevant only for title bar area, e.g. calling
         * {@code forceHitTest(false)} will not make window draggable via non-title bar area.
         *
         * <h2>Example:</h2>
         * Suppose you have a {@code JPanel} in the title bar area. You want it to respond to right-click for
         * some popup menu, but also retain native drag and double-click behavior.
         * <pre>
         *     CustomTitleBar titlebar = ...;
         *     JPanel panel = ...;
         *     MouseAdapter adapter = new MouseAdapter() {
         *         private void hit() { titlebar.forceHitTest(false); }
         *         public void mouseClicked(MouseEvent e) {
         *             hit();
         *             if (e.getButton() == MouseEvent.BUTTON3) ...;
         *         }
         *         public void mousePressed(MouseEvent e) { hit(); }
         *         public void mouseReleased(MouseEvent e) { hit(); }
         *         public void mouseEntered(MouseEvent e) { hit(); }
         *         public void mouseDragged(MouseEvent e) { hit(); }
         *         public void mouseMoved(MouseEvent e) { hit(); }
         *     };
         *     panel.addMouseListener(adapter);
         *     panel.addMouseMotionListener(adapter);
         * </pre>
         */
        void forceHitTest(boolean client);

        Window getContainingWindow();
    }
}
</file>

<file path="jewel/src/jvmMain/java/com/jetbrains/WindowMove.java">
/*
 * Copyright 2000-2023 JetBrains s.r.o.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.jetbrains;

import java.awt.*;

public interface WindowMove {
    /**
     * Starts moving the top-level parent window of the given window together with the mouse pointer.
     * The intended use is to facilitate the implementation of window management similar to the way
     * it is done natively on the platform.
     *
     * Preconditions for calling this method:
     * <ul>
     * <li>WM supports _NET_WM_MOVE_RESIZE (this is checked automatically when an implementation
     *     of this interface is obtained).</li>
     * <li>Mouse pointer is within this window's bounds.</li>
     * <li>The mouse button specified by {@code mouseButton} is pressed.</li>
     * </ul>
     *
     * Calling this method will make the window start moving together with the mouse pointer until
     * the specified mouse button is released or Esc is pressed. The conditions for cancelling
     * the move may differ between WMs.
     *
     * @param mouseButton indicates the mouse button that was pressed to start moving the window;
     *                   must be one of {@code MouseEvent.BUTTON1}, {@code MouseEvent.BUTTON2},
     *                   or {@code MouseEvent.BUTTON3}.
     */
    void startMovingTogetherWithMouse(Window window, int mouseButton);
}
</file>

<file path="jewel/src/jvmMain/kotlin/org/jetbrains/jewel/window/styling/DecoratedWindowStyling.kt">
package org.jetbrains.jewel.window.styling

import androidx.compose.runtime.Composable
import androidx.compose.runtime.Immutable
import androidx.compose.runtime.ProvidableCompositionLocal
import androidx.compose.runtime.State
import androidx.compose.runtime.rememberUpdatedState
import androidx.compose.runtime.staticCompositionLocalOf
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.Dp
import org.jetbrains.jewel.foundation.GenerateDataFunctions
import org.jetbrains.jewel.window.DecoratedWindowState

@Immutable
@GenerateDataFunctions
public class DecoratedWindowStyle(
    public val colors: DecoratedWindowColors,
    public val metrics: DecoratedWindowMetrics,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as DecoratedWindowStyle

        if (colors != other.colors) return false
        if (metrics != other.metrics) return false

        return true
    }

    override fun hashCode(): Int {
        var result = colors.hashCode()
        result = 31 * result + metrics.hashCode()
        return result
    }

    override fun toString(): String = "DecoratedWindowStyle(colors=$colors, metrics=$metrics)"

    public companion object
}

@Immutable
@GenerateDataFunctions
public class DecoratedWindowColors(public val border: Color, public val borderInactive: Color) {
    @Composable
    public fun borderFor(state: DecoratedWindowState): State<Color> =
        rememberUpdatedState(
            when {
                !state.isActive -> borderInactive
                else -> border
            }
        )

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as DecoratedWindowColors

        if (border != other.border) return false
        if (borderInactive != other.borderInactive) return false

        return true
    }

    override fun hashCode(): Int {
        var result = border.hashCode()
        result = 31 * result + borderInactive.hashCode()
        return result
    }

    override fun toString(): String = "DecoratedWindowColors(border=$border, borderInactive=$borderInactive)"

    public companion object
}

@Immutable
@GenerateDataFunctions
public class DecoratedWindowMetrics(public val borderWidth: Dp) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as DecoratedWindowMetrics

        return borderWidth == other.borderWidth
    }

    override fun hashCode(): Int = borderWidth.hashCode()

    override fun toString(): String = "DecoratedWindowMetrics(borderWidth=$borderWidth)"

    public companion object
}

public val LocalDecoratedWindowStyle: ProvidableCompositionLocal<DecoratedWindowStyle> = staticCompositionLocalOf {
    error("No DecoratedWindowStyle provided. Have you forgotten the theme?")
}
</file>

<file path="jewel/src/jvmMain/kotlin/org/jetbrains/jewel/window/styling/TitleBarStyling.kt">
package org.jetbrains.jewel.window.styling

import androidx.compose.runtime.Composable
import androidx.compose.runtime.Immutable
import androidx.compose.runtime.ProvidableCompositionLocal
import androidx.compose.runtime.Stable
import androidx.compose.runtime.State
import androidx.compose.runtime.rememberUpdatedState
import androidx.compose.runtime.staticCompositionLocalOf
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.DpSize
import org.jetbrains.jewel.foundation.GenerateDataFunctions
import org.jetbrains.jewel.ui.component.styling.DropdownStyle
import org.jetbrains.jewel.ui.component.styling.IconButtonStyle
import org.jetbrains.jewel.ui.icon.IconKey
import org.jetbrains.jewel.window.DecoratedWindowState

@Stable
@GenerateDataFunctions
public class TitleBarStyle(
    public val colors: TitleBarColors,
    public val metrics: TitleBarMetrics,
    public val icons: TitleBarIcons,
    public val dropdownStyle: DropdownStyle,
    public val iconButtonStyle: IconButtonStyle,
    public val paneButtonStyle: IconButtonStyle,
    public val paneCloseButtonStyle: IconButtonStyle,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as TitleBarStyle

        if (colors != other.colors) return false
        if (metrics != other.metrics) return false
        if (icons != other.icons) return false
        if (dropdownStyle != other.dropdownStyle) return false
        if (iconButtonStyle != other.iconButtonStyle) return false
        if (paneButtonStyle != other.paneButtonStyle) return false
        if (paneCloseButtonStyle != other.paneCloseButtonStyle) return false

        return true
    }

    override fun hashCode(): Int {
        var result = colors.hashCode()
        result = 31 * result + metrics.hashCode()
        result = 31 * result + icons.hashCode()
        result = 31 * result + dropdownStyle.hashCode()
        result = 31 * result + iconButtonStyle.hashCode()
        result = 31 * result + paneButtonStyle.hashCode()
        result = 31 * result + paneCloseButtonStyle.hashCode()
        return result
    }

    override fun toString(): String {
        return "TitleBarStyle(" +
            "colors=$colors, " +
            "metrics=$metrics, " +
            "icons=$icons, " +
            "dropdownStyle=$dropdownStyle, " +
            "iconButtonStyle=$iconButtonStyle, " +
            "paneButtonStyle=$paneButtonStyle, " +
            "paneCloseButtonStyle=$paneCloseButtonStyle" +
            ")"
    }

    public companion object
}

@Immutable
@GenerateDataFunctions
public class TitleBarColors(
    public val background: Color,
    public val inactiveBackground: Color,
    public val content: Color,
    public val border: Color,
    // The background color for newControlButtons(three circles in left top corner) in MacOS
    // fullscreen mode
    public val fullscreenControlButtonsBackground: Color,
    // The hover and press background color for window control buttons(minimize, maximize) in Linux
    public val titlePaneButtonHoveredBackground: Color,
    public val titlePaneButtonPressedBackground: Color,
    // The hover and press background color for window close button in Linux
    public val titlePaneCloseButtonHoveredBackground: Color,
    public val titlePaneCloseButtonPressedBackground: Color,
    // The hover and press background color for IconButtons in title bar content
    public val iconButtonHoveredBackground: Color,
    public val iconButtonPressedBackground: Color,
    // The hover and press background color for Dropdown in title bar content
    public val dropdownPressedBackground: Color,
    public val dropdownHoveredBackground: Color,
) {
    @Composable
    public fun backgroundFor(state: DecoratedWindowState): State<Color> =
        rememberUpdatedState(
            when {
                !state.isActive -> inactiveBackground
                else -> background
            }
        )

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as TitleBarColors

        if (background != other.background) return false
        if (inactiveBackground != other.inactiveBackground) return false
        if (content != other.content) return false
        if (border != other.border) return false
        if (fullscreenControlButtonsBackground != other.fullscreenControlButtonsBackground) return false
        if (titlePaneButtonHoveredBackground != other.titlePaneButtonHoveredBackground) return false
        if (titlePaneButtonPressedBackground != other.titlePaneButtonPressedBackground) return false
        if (titlePaneCloseButtonHoveredBackground != other.titlePaneCloseButtonHoveredBackground) return false
        if (titlePaneCloseButtonPressedBackground != other.titlePaneCloseButtonPressedBackground) return false
        if (iconButtonHoveredBackground != other.iconButtonHoveredBackground) return false
        if (iconButtonPressedBackground != other.iconButtonPressedBackground) return false
        if (dropdownPressedBackground != other.dropdownPressedBackground) return false
        if (dropdownHoveredBackground != other.dropdownHoveredBackground) return false

        return true
    }

    override fun hashCode(): Int {
        var result = background.hashCode()
        result = 31 * result + inactiveBackground.hashCode()
        result = 31 * result + content.hashCode()
        result = 31 * result + border.hashCode()
        result = 31 * result + fullscreenControlButtonsBackground.hashCode()
        result = 31 * result + titlePaneButtonHoveredBackground.hashCode()
        result = 31 * result + titlePaneButtonPressedBackground.hashCode()
        result = 31 * result + titlePaneCloseButtonHoveredBackground.hashCode()
        result = 31 * result + titlePaneCloseButtonPressedBackground.hashCode()
        result = 31 * result + iconButtonHoveredBackground.hashCode()
        result = 31 * result + iconButtonPressedBackground.hashCode()
        result = 31 * result + dropdownPressedBackground.hashCode()
        result = 31 * result + dropdownHoveredBackground.hashCode()
        return result
    }

    override fun toString(): String {
        return "TitleBarColors(" +
            "background=$background, " +
            "inactiveBackground=$inactiveBackground, " +
            "content=$content, " +
            "border=$border, " +
            "fullscreenControlButtonsBackground=$fullscreenControlButtonsBackground, " +
            "titlePaneButtonHoveredBackground=$titlePaneButtonHoveredBackground, " +
            "titlePaneButtonPressedBackground=$titlePaneButtonPressedBackground, " +
            "titlePaneCloseButtonHoveredBackground=$titlePaneCloseButtonHoveredBackground, " +
            "titlePaneCloseButtonPressedBackground=$titlePaneCloseButtonPressedBackground, " +
            "iconButtonHoveredBackground=$iconButtonHoveredBackground, " +
            "iconButtonPressedBackground=$iconButtonPressedBackground, " +
            "dropdownPressedBackground=$dropdownPressedBackground, " +
            "dropdownHoveredBackground=$dropdownHoveredBackground" +
            ")"
    }

    public companion object
}

@Immutable
@GenerateDataFunctions
public class TitleBarMetrics(
    public val height: Dp,
    public val gradientStartX: Dp,
    public val gradientEndX: Dp,
    public val titlePaneButtonSize: DpSize,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as TitleBarMetrics

        if (height != other.height) return false
        if (gradientStartX != other.gradientStartX) return false
        if (gradientEndX != other.gradientEndX) return false
        if (titlePaneButtonSize != other.titlePaneButtonSize) return false

        return true
    }

    override fun hashCode(): Int {
        var result = height.hashCode()
        result = 31 * result + gradientStartX.hashCode()
        result = 31 * result + gradientEndX.hashCode()
        result = 31 * result + titlePaneButtonSize.hashCode()
        return result
    }

    override fun toString(): String {
        return "TitleBarMetrics(" +
            "height=$height, " +
            "gradientStartX=$gradientStartX, " +
            "gradientEndX=$gradientEndX, " +
            "titlePaneButtonSize=$titlePaneButtonSize" +
            ")"
    }

    public companion object
}

@Immutable
@GenerateDataFunctions
public class TitleBarIcons(
    public val minimizeButton: IconKey,
    public val maximizeButton: IconKey,
    public val restoreButton: IconKey,
    public val closeButton: IconKey,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as TitleBarIcons

        if (minimizeButton != other.minimizeButton) return false
        if (maximizeButton != other.maximizeButton) return false
        if (restoreButton != other.restoreButton) return false
        if (closeButton != other.closeButton) return false

        return true
    }

    override fun hashCode(): Int {
        var result = minimizeButton.hashCode()
        result = 31 * result + maximizeButton.hashCode()
        result = 31 * result + restoreButton.hashCode()
        result = 31 * result + closeButton.hashCode()
        return result
    }

    override fun toString(): String {
        return "TitleBarIcons(" +
            "minimizeButton=$minimizeButton, " +
            "maximizeButton=$maximizeButton, " +
            "restoreButton=$restoreButton, " +
            "closeButton=$closeButton" +
            ")"
    }

    public companion object
}

public val LocalTitleBarStyle: ProvidableCompositionLocal<TitleBarStyle> = staticCompositionLocalOf {
    error("No TitleBarStyle provided. Have you forgotten the theme?")
}
</file>

<file path="jewel/src/jvmMain/kotlin/org/jetbrains/jewel/window/utils/macos/Foundation.kt">
package org.jetbrains.jewel.window.utils.macos

import com.sun.jna.Function
import com.sun.jna.Library
import com.sun.jna.Native
import com.sun.jna.Pointer
import java.lang.reflect.Proxy
import java.util.Arrays
import java.util.Collections
import java.util.logging.Level
import java.util.logging.Logger
import org.jetbrains.jewel.window.utils.JnaLoader

internal object Foundation {
    private val logger = Logger.getLogger(Foundation::class.java.simpleName)

    init {
        if (!JnaLoader.isLoaded) {
            logger.log(Level.WARNING, "JNA is not loaded")
        }
    }

    private val myFoundationLibrary: FoundationLibrary? by lazy {
        try {
            Native.load("Foundation", FoundationLibrary::class.java, Collections.singletonMap("jna.encoding", "UTF8"))
        } catch (_: Throwable) {
            null
        }
    }

    private val myObjcMsgSend: Function? by lazy {
        try {
            (Proxy.getInvocationHandler(myFoundationLibrary) as Library.Handler)
                .nativeLibrary
                .getFunction("objc_msgSend")
        } catch (_: Throwable) {
            null
        }
    }

    /** Get the ID of the NSClass with className */
    fun getObjcClass(className: String?): ID? = myFoundationLibrary?.objc_getClass(className)

    fun getProtocol(name: String?): ID? = myFoundationLibrary?.objc_getProtocol(name)

    fun createSelector(s: String?): Pointer? = myFoundationLibrary?.sel_registerName(s)

    private fun prepInvoke(id: ID?, selector: Pointer?, args: Array<out Any?>): Array<Any?> {
        val invokArgs = arrayOfNulls<Any>(args.size + 2)
        invokArgs[0] = id
        invokArgs[1] = selector
        System.arraycopy(args, 0, invokArgs, 2, args.size)
        return invokArgs
    }

    // objc_msgSend is called with the calling convention of the target method
    // on x86_64 this does not make a difference, but arm64 uses a different calling convention for
    // varargs
    // it is therefore important to not call objc_msgSend as a vararg function
    operator fun invoke(id: ID?, selector: Pointer?, vararg args: Any?): ID =
        ID(myObjcMsgSend?.invokeLong(prepInvoke(id, selector, args)) ?: 0)

    /**
     * Invokes the given vararg selector. Expects `NSArray arrayWithObjects:(id), ...` like signature, i.e. exactly one
     * fixed argument, followed by varargs.
     */
    fun invokeVarArg(id: ID?, selector: Pointer?, vararg args: Any?): ID {
        // c functions and objc methods have at least 1 fixed argument, we therefore need to
        // separate out the first argument
        return myFoundationLibrary?.objc_msgSend(id, selector, args[0], *Arrays.copyOfRange(args, 1, args.size))
            ?: ID.NIL
    }

    operator fun invoke(cls: String?, selector: String?, vararg args: Any?): ID =
        invoke(getObjcClass(cls), createSelector(selector), *args)

    fun invokeVarArg(cls: String?, selector: String?, vararg args: Any?): ID =
        invokeVarArg(getObjcClass(cls), createSelector(selector), *args)

    fun safeInvoke(stringCls: String?, stringSelector: String?, vararg args: Any?): ID {
        val cls = getObjcClass(stringCls)
        val selector = createSelector(stringSelector)
        if (!invoke(cls, "respondsToSelector:", selector).booleanValue()) {
            error("Missing selector $stringSelector for $stringCls")
        }
        return invoke(cls, selector, *args)
    }

    operator fun invoke(id: ID?, selector: String?, vararg args: Any?): ID = invoke(id, createSelector(selector), *args)
}
</file>

<file path="jewel/src/jvmMain/kotlin/org/jetbrains/jewel/window/utils/macos/FoundationLibrary.kt">
package org.jetbrains.jewel.window.utils.macos

import com.sun.jna.Callback
import com.sun.jna.Library
import com.sun.jna.Pointer

@Suppress(
    "ktlint:standard:function-naming",
    "ktlint:standard:property-naming",
    "Unused",
    "FunctionName",
    "ConstPropertyName",
) // Borrowed code
internal interface FoundationLibrary : Library {
    fun NSLog(pString: Pointer?, thing: Any?)

    fun NSFullUserName(): ID?

    fun objc_allocateClassPair(supercls: ID?, name: String?, extraBytes: Int): ID?

    fun objc_registerClassPair(cls: ID?)

    fun CFStringCreateWithBytes(
        allocator: Pointer?,
        bytes: ByteArray?,
        byteCount: Int,
        encoding: Int,
        isExternalRepresentation: Byte,
    ): ID?

    fun CFStringGetCString(theString: ID?, buffer: ByteArray?, bufferSize: Int, encoding: Int): Byte

    fun CFStringGetLength(theString: ID?): Int

    fun CFStringConvertNSStringEncodingToEncoding(nsEncoding: Long): Long

    fun CFStringConvertEncodingToIANACharSetName(cfEncoding: Long): ID?

    fun CFStringConvertIANACharSetNameToEncoding(encodingName: ID?): Long

    fun CFStringConvertEncodingToNSStringEncoding(cfEncoding: Long): Long

    fun CFRetain(cfTypeRef: ID?)

    fun CFRelease(cfTypeRef: ID?)

    fun CFGetRetainCount(cfTypeRef: Pointer?): Int

    fun objc_getClass(className: String?): ID?

    fun objc_getProtocol(name: String?): ID?

    fun class_createInstance(pClass: ID?, extraBytes: Int): ID?

    fun sel_registerName(selectorName: String?): Pointer?

    fun class_replaceMethod(cls: ID?, selName: Pointer?, impl: Callback?, types: String?): ID?

    fun objc_getMetaClass(name: String?): ID?

    /**
     * Note: Vararg version. Should only be used only for selectors with a single fixed argument followed by varargs.
     */
    fun objc_msgSend(receiver: ID?, selector: Pointer?, firstArg: Any?, vararg args: Any?): ID?

    fun class_respondsToSelector(cls: ID?, selName: Pointer?): Boolean

    fun class_addMethod(cls: ID?, selName: Pointer?, imp: Callback?, types: String?): Boolean

    fun class_addMethod(cls: ID?, selName: Pointer?, imp: ID?, types: String?): Boolean

    fun class_addProtocol(aClass: ID?, protocol: ID?): Boolean

    fun class_isMetaClass(cls: ID?): Boolean

    fun NSStringFromSelector(selector: Pointer?): ID?

    fun NSStringFromClass(aClass: ID?): ID?

    fun objc_getClass(clazz: Pointer?): Pointer?

    companion object {
        const val kCFStringEncodingMacRoman = 0
        const val kCFStringEncodingWindowsLatin1 = 0x0500
        const val kCFStringEncodingISOLatin1 = 0x0201
        const val kCFStringEncodingNextStepLatin = 0x0B01
        const val kCFStringEncodingASCII = 0x0600
        const val kCFStringEncodingUnicode = 0x0100
        const val kCFStringEncodingUTF8 = 0x08000100
        const val kCFStringEncodingNonLossyASCII = 0x0BFF
        const val kCFStringEncodingUTF16 = 0x0100
        const val kCFStringEncodingUTF16BE = 0x10000100
        const val kCFStringEncodingUTF16LE = 0x14000100
        const val kCFStringEncodingUTF32 = 0x0c000100
        const val kCFStringEncodingUTF32BE = 0x18000100
        const val kCFStringEncodingUTF32LE = 0x1c000100

        // https://developer.apple.com/library/mac/documentation/Carbon/Reference/CGWindow_Reference/Constants/Constants.html#//apple_ref/doc/constant_group/Window_List_Option_Constants
        const val kCGWindowListOptionAll = 0
        const val kCGWindowListOptionOnScreenOnly = 1
        const val kCGWindowListOptionOnScreenAboveWindow = 2
        const val kCGWindowListOptionOnScreenBelowWindow = 4
        const val kCGWindowListOptionIncludingWindow = 8
        const val kCGWindowListExcludeDesktopElements = 16

        // https://developer.apple.com/library/mac/documentation/Carbon/Reference/CGWindow_Reference/Constants/Constants.html#//apple_ref/doc/constant_group/Window_Image_Types
        const val kCGWindowImageDefault = 0
        const val kCGWindowImageBoundsIgnoreFraming = 1
        const val kCGWindowImageShouldBeOpaque = 2
        const val kCGWindowImageOnlyShadows = 4
        const val kCGWindowImageBestResolution = 8
        const val kCGWindowImageNominalResolution = 16

        // see enum NSBitmapImageFileType
        const val NSBitmapImageFileTypeTIFF = 0
        const val NSBitmapImageFileTypeBMP = 1
        const val NSBitmapImageFileTypeGIF = 2
        const val NSBitmapImageFileTypeJPEG = 3
        const val NSBitmapImageFileTypePNG = 4
        const val NSBitmapImageFileTypeJPEG2000 = 5
    }
}
</file>

<file path="jewel/src/jvmMain/kotlin/org/jetbrains/jewel/window/utils/macos/ID.kt">
package org.jetbrains.jewel.window.utils.macos

import com.sun.jna.NativeLong

/** Could be an address in memory (if pointer to a class or method) or a value (like 0 or 1) */
@Suppress("OVERRIDE_DEPRECATION") // Copied code
internal class ID : NativeLong {
    constructor()

    constructor(peer: Long) : super(peer)

    fun booleanValue(): Boolean = toInt() != 0

    override fun toByte(): Byte = toInt().toByte()

    override fun toChar(): Char = toInt().toChar()

    override fun toShort(): Short = toInt().toShort()

    @Suppress("RedundantOverride") // Without this, we get a SOE
    override fun toInt(): Int = super.toInt()

    companion object {
        @JvmField val NIL = ID(0L)
    }
}
</file>

<file path="jewel/src/jvmMain/kotlin/org/jetbrains/jewel/window/utils/macos/MacUtil.kt">
package org.jetbrains.jewel.window.utils.macos

import java.awt.Component
import java.awt.Window
import java.lang.reflect.InvocationTargetException
import java.util.logging.Level
import java.util.logging.Logger
import javax.swing.SwingUtilities
import org.jetbrains.jewel.window.utils.UnsafeAccessing
import org.jetbrains.jewel.window.utils.accessible

internal object MacUtil {
    private val logger = Logger.getLogger(MacUtil::class.java.simpleName)

    init {
        try {
            UnsafeAccessing.assignAccessibility(
                UnsafeAccessing.desktopModule,
                listOf("sun.awt", "sun.lwawt", "sun.lwawt.macosx"),
            )
        } catch (@Suppress("TooGenericExceptionCaught") e: Exception) {
            logger.log(Level.WARNING, "Assign access for jdk.desktop failed.", e)
        }
    }

    fun getWindowFromJavaWindow(w: Window?): ID {
        if (w == null) {
            return ID.NIL
        }
        try {
            val cPlatformWindow = getPlatformWindow(w)
            if (cPlatformWindow != null) {
                val ptr = cPlatformWindow.javaClass.superclass.getDeclaredField("ptr")
                ptr.setAccessible(true)
                return ID(ptr.getLong(cPlatformWindow))
            }
        } catch (e: IllegalAccessException) {
            logger.log(Level.WARNING, "Fail to get cPlatformWindow from awt window.", e)
        } catch (e: NoSuchFieldException) {
            logger.log(Level.WARNING, "Fail to get cPlatformWindow from awt window.", e)
        }
        return ID.NIL
    }

    fun getPlatformWindow(w: Window): Any? {
        try {
            val awtAccessor = Class.forName("sun.awt.AWTAccessor")
            val componentAccessor = awtAccessor.getMethod("getComponentAccessor").invoke(null)
            val getPeer = componentAccessor.javaClass.getMethod("getPeer", Component::class.java).accessible()
            val peer = getPeer.invoke(componentAccessor, w)
            if (peer != null) {
                val cWindowPeerClass: Class<*> = peer.javaClass
                val getPlatformWindowMethod = cWindowPeerClass.getDeclaredMethod("getPlatformWindow")
                val cPlatformWindow = getPlatformWindowMethod.invoke(peer)
                if (cPlatformWindow != null) {
                    return cPlatformWindow
                }
            }
        } catch (e: NoSuchMethodException) {
            logger.log(Level.WARNING, "Fail to get cPlatformWindow from awt window.", e)
        } catch (e: IllegalAccessException) {
            logger.log(Level.WARNING, "Fail to get cPlatformWindow from awt window.", e)
        } catch (e: InvocationTargetException) {
            logger.log(Level.WARNING, "Fail to get cPlatformWindow from awt window.", e)
        } catch (e: ClassNotFoundException) {
            logger.log(Level.WARNING, "Fail to get cPlatformWindow from awt window.", e)
        }
        return null
    }

    fun updateColors(w: Window) {
        SwingUtilities.invokeLater {
            val window = getWindowFromJavaWindow(w)
            val delegate = Foundation.invoke(window, "delegate")
            if (
                Foundation.invoke(delegate, "respondsToSelector:", Foundation.createSelector("updateColors"))
                    .booleanValue()
            ) {
                Foundation.invoke(delegate, "updateColors")
            }
        }
    }

    fun updateFullScreenButtons(w: Window) {
        SwingUtilities.invokeLater {
            val selector = Foundation.createSelector("updateFullScreenButtons")
            val window = getWindowFromJavaWindow(w)
            val delegate = Foundation.invoke(window, "delegate")

            if (Foundation.invoke(delegate, "respondsToSelector:", selector).booleanValue()) {
                Foundation.invoke(delegate, "updateFullScreenButtons")
            }
        }
    }
}
</file>

<file path="jewel/src/jvmMain/kotlin/org/jetbrains/jewel/window/utils/DesktopPlatform.kt">
package org.jetbrains.jewel.window.utils

public enum class DesktopPlatform {
    Linux,
    Windows,
    MacOS,
    Unknown;

    public companion object {
        public val Current: DesktopPlatform by lazy {
            val name = System.getProperty("os.name")
            when {
                name?.startsWith("Linux") == true -> Linux
                name?.startsWith("Win") == true -> Windows
                name == "Mac OS X" -> MacOS
                else -> Unknown
            }
        }
    }
}
</file>

<file path="jewel/src/jvmMain/kotlin/org/jetbrains/jewel/window/utils/JnaLoader.kt">
package org.jetbrains.jewel.window.utils

import com.sun.jna.Native
import java.util.logging.Level
import java.util.logging.Logger
import kotlin.system.measureTimeMillis

internal object JnaLoader {
    private var loaded: Boolean? = null
    private val logger = Logger.getLogger(JnaLoader::class.java.simpleName)

    @Synchronized
    fun load() {
        if (loaded == null) {
            loaded = false
            try {
                val time = measureTimeMillis { Native.POINTER_SIZE }
                logger.info("JNA library (${Native.POINTER_SIZE shl 3}-bit) loaded in $time ms")
                loaded = true
            } catch (@Suppress("TooGenericExceptionCaught") t: Throwable) {
                logger.log(
                    Level.WARNING,
                    "Unable to load JNA library(os=${
                        System.getProperty("os.name")
                    } ${System.getProperty("os.version")}, jna.boot.library.path=${
                        System.getProperty("jna.boot.library.path")
                    })",
                    t,
                )
            }
        }
    }

    @get:Synchronized
    val isLoaded: Boolean
        get() {
            if (loaded == null) {
                load()
            }
            return loaded ?: false
        }
}
</file>

<file path="jewel/src/jvmMain/kotlin/org/jetbrains/jewel/window/utils/UnsafeAccessing.kt">
package org.jetbrains.jewel.window.utils

import java.lang.reflect.AccessibleObject
import java.util.logging.Level
import java.util.logging.Logger
import sun.misc.Unsafe

internal object UnsafeAccessing {
    private val logger = Logger.getLogger(UnsafeAccessing::class.java.simpleName)

    private val unsafe: Any? by lazy {
        try {
            val theUnsafe = Unsafe::class.java.getDeclaredField("theUnsafe")
            theUnsafe.isAccessible = true
            theUnsafe.get(null) as Unsafe
        } catch (@Suppress("TooGenericExceptionCaught") error: Throwable) {
            logger.log(Level.WARNING, "Unsafe accessing initializing failed.", error)
            null
        }
    }

    val desktopModule by lazy { ModuleLayer.boot().findModule("java.desktop").get() }

    val ownerModule: Module by lazy { this.javaClass.module }

    private val isAccessibleFieldOffset: Long? by lazy {
        try {
            (unsafe as? Unsafe)?.objectFieldOffset(Parent::class.java.getDeclaredField("first"))
        } catch (_: Throwable) {
            null
        }
    }

    private val implAddOpens by lazy {
        try {
            Module::class.java.getDeclaredMethod("implAddOpens", String::class.java, Module::class.java).accessible()
        } catch (_: Throwable) {
            null
        }
    }

    fun assignAccessibility(obj: AccessibleObject) {
        try {
            val theUnsafe = unsafe as? Unsafe ?: return
            val offset = isAccessibleFieldOffset ?: return
            theUnsafe.putBooleanVolatile(obj, offset, true)
        } catch (_: Throwable) {
            // ignore
        }
    }

    fun assignAccessibility(module: Module, packages: List<String>) {
        try {
            packages.forEach { implAddOpens?.invoke(module, it, ownerModule) }
        } catch (_: Throwable) {
            // ignore
        }
    }

    private class Parent {
        var first = false

        @Volatile var second: Any? = null
    }
}

internal fun <T : AccessibleObject> T.accessible(): T = apply { UnsafeAccessing.assignAccessibility(this) }
</file>

<file path="jewel/src/jvmMain/kotlin/org/jetbrains/jewel/window/utils/WindowControlArea.kt">
package org.jetbrains.jewel.window.utils

import androidx.compose.foundation.focusable
import androidx.compose.foundation.layout.size
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.awt.ComposeWindow
import org.jetbrains.jewel.foundation.theme.JewelTheme
import org.jetbrains.jewel.ui.component.Icon
import org.jetbrains.jewel.ui.component.IconButton
import org.jetbrains.jewel.ui.component.styling.IconButtonStyle
import org.jetbrains.jewel.ui.icon.IconKey
import org.jetbrains.jewel.ui.painter.PainterHint
import org.jetbrains.jewel.ui.painter.PainterProviderScope
import org.jetbrains.jewel.ui.painter.PainterSuffixHint
import org.jetbrains.jewel.window.DecoratedWindowState
import org.jetbrains.jewel.window.TitleBarScope
import org.jetbrains.jewel.window.defaultTitleBarStyle
import org.jetbrains.jewel.window.styling.TitleBarStyle
import java.awt.Frame
import java.awt.event.WindowEvent

@Composable
private fun TitleBarScope.CloseButton(
    onClick: () -> Unit,
    state: DecoratedWindowState,
    style: TitleBarStyle = JewelTheme.defaultTitleBarStyle,
) {
    ControlButton(onClick, state, style.icons.closeButton, "Close", style, style.paneCloseButtonStyle)
}

@Composable
private fun TitleBarScope.ControlButton(
    onClick: () -> Unit,
    state: DecoratedWindowState,
    iconKey: IconKey,
    description: String,
    style: TitleBarStyle = JewelTheme.defaultTitleBarStyle,
    iconButtonStyle: IconButtonStyle = style.paneButtonStyle,
) {
    IconButton(
        onClick,
        Modifier.align(Alignment.End).focusable(false).size(style.metrics.titlePaneButtonSize),
        style = iconButtonStyle,
    ) {
        Icon(iconKey, description, hint = if (state.isActive) PainterHint else Inactive)
    }
}

private data object Inactive : PainterSuffixHint() {
    override fun PainterProviderScope.suffix(): String = "Inactive"
}

@Composable
internal fun TitleBarScope.WindowControlArea(
    window: ComposeWindow,
    state: DecoratedWindowState,
    style: TitleBarStyle = JewelTheme.defaultTitleBarStyle,
) {
    CloseButton({ window.dispatchEvent(WindowEvent(window, WindowEvent.WINDOW_CLOSING)) }, state, style)

    if (state.isMaximized) {
        ControlButton({ window.extendedState = Frame.NORMAL }, state, style.icons.restoreButton, "Restore")
    } else {
        ControlButton(
            { window.extendedState = Frame.MAXIMIZED_BOTH },
            state,
            style.icons.maximizeButton,
            "Maximize",
        )
    }
    ControlButton({ window.extendedState = Frame.ICONIFIED }, state, style.icons.minimizeButton, "Minimize")
}
</file>

<file path="jewel/src/jvmMain/kotlin/org/jetbrains/jewel/window/DecoratedWindow.kt">
package org.jetbrains.jewel.window

import androidx.compose.foundation.layout.padding
import androidx.compose.runtime.Composable
import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.Immutable
import androidx.compose.runtime.ProvidableCompositionLocal
import androidx.compose.runtime.Stable
import androidx.compose.runtime.compositionLocalOf
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.awt.ComposeWindow
import androidx.compose.ui.graphics.RectangleShape
import androidx.compose.ui.graphics.painter.Painter
import androidx.compose.ui.input.key.KeyEvent
import androidx.compose.ui.layout.Layout
import androidx.compose.ui.layout.Measurable
import androidx.compose.ui.layout.MeasurePolicy
import androidx.compose.ui.layout.MeasureResult
import androidx.compose.ui.layout.MeasureScope
import androidx.compose.ui.layout.Placeable
import androidx.compose.ui.layout.layoutId
import androidx.compose.ui.unit.Constraints
import androidx.compose.ui.unit.offset
import androidx.compose.ui.window.FrameWindowScope
import androidx.compose.ui.window.Window
import androidx.compose.ui.window.WindowPlacement
import androidx.compose.ui.window.WindowState
import androidx.compose.ui.window.rememberWindowState
import com.jetbrains.JBR
import java.awt.event.ComponentEvent
import java.awt.event.ComponentListener
import java.awt.event.WindowAdapter
import java.awt.event.WindowEvent
import org.jetbrains.jewel.foundation.Stroke
import org.jetbrains.jewel.foundation.modifier.border
import org.jetbrains.jewel.foundation.modifier.trackWindowActivation
import org.jetbrains.jewel.foundation.theme.JewelTheme
import org.jetbrains.jewel.window.styling.DecoratedWindowStyle
import org.jetbrains.jewel.window.utils.DesktopPlatform

@Composable
public fun DecoratedWindow(
    onCloseRequest: () -> Unit,
    state: WindowState = rememberWindowState(),
    visible: Boolean = true,
    title: String = "",
    icon: Painter? = null,
    resizable: Boolean = true,
    enabled: Boolean = true,
    focusable: Boolean = true,
    alwaysOnTop: Boolean = false,
    onPreviewKeyEvent: (KeyEvent) -> Boolean = { false },
    onKeyEvent: (KeyEvent) -> Boolean = { false },
    style: DecoratedWindowStyle = JewelTheme.defaultDecoratedWindowStyle,
    content: @Composable DecoratedWindowScope.() -> Unit,
) {
    remember {
        if (!JBR.isAvailable()) {
            error(
                "DecoratedWindow can only be used on JetBrainsRuntime(JBR) platform, " +
                    "please check the document https://github.com/JetBrains/jewel#int-ui-standalone-theme"
            )
        }
    }

    // Using undecorated window for linux
    val undecorated = DesktopPlatform.Linux == DesktopPlatform.Current

    Window(
        onCloseRequest,
        state,
        visible,
        title,
        icon,
        undecorated,
        transparent = false,
        resizable,
        enabled,
        focusable,
        alwaysOnTop,
        onPreviewKeyEvent,
        onKeyEvent,
    ) {
        var decoratedWindowState by remember { mutableStateOf(DecoratedWindowState.of(window)) }

        DisposableEffect(window) {
            val adapter =
                object : WindowAdapter(), ComponentListener {
                    override fun windowActivated(e: WindowEvent?) {
                        decoratedWindowState = DecoratedWindowState.of(window)
                    }

                    override fun windowDeactivated(e: WindowEvent?) {
                        decoratedWindowState = DecoratedWindowState.of(window)
                    }

                    override fun windowIconified(e: WindowEvent?) {
                        decoratedWindowState = DecoratedWindowState.of(window)
                    }

                    override fun windowDeiconified(e: WindowEvent?) {
                        decoratedWindowState = DecoratedWindowState.of(window)
                    }

                    override fun windowStateChanged(e: WindowEvent) {
                        decoratedWindowState = DecoratedWindowState.of(window)
                    }

                    override fun componentResized(e: ComponentEvent?) {
                        decoratedWindowState = DecoratedWindowState.of(window)
                    }

                    override fun componentMoved(e: ComponentEvent?) {
                        // Empty
                    }

                    override fun componentShown(e: ComponentEvent?) {
                        // Empty
                    }

                    override fun componentHidden(e: ComponentEvent?) {
                        // Empty
                    }
                }

            window.addWindowListener(adapter)
            window.addWindowStateListener(adapter)
            window.addComponentListener(adapter)

            onDispose {
                window.removeWindowListener(adapter)
                window.removeWindowStateListener(adapter)
                window.removeComponentListener(adapter)
            }
        }

        val undecoratedWindowBorder =
            if (undecorated && !decoratedWindowState.isMaximized) {
                Modifier.border(
                        Stroke.Alignment.Inside,
                        style.metrics.borderWidth,
                        style.colors.borderFor(decoratedWindowState).value,
                        RectangleShape,
                    )
                    .padding(style.metrics.borderWidth)
            } else {
                Modifier
            }

        CompositionLocalProvider(LocalTitleBarInfo provides TitleBarInfo(title, icon)) {
            Layout(
                content = {
                    val scope =
                        object : DecoratedWindowScope {
                            override val state: DecoratedWindowState
                                get() = decoratedWindowState

                            override val window: ComposeWindow
                                get() = this@Window.window
                        }
                    scope.content()
                },
                modifier = undecoratedWindowBorder.trackWindowActivation(window),
                measurePolicy = DecoratedWindowMeasurePolicy,
            )
        }
    }
}

@Stable
public interface DecoratedWindowScope : FrameWindowScope {
    override val window: ComposeWindow

    public val state: DecoratedWindowState
}

private object DecoratedWindowMeasurePolicy : MeasurePolicy {
    override fun MeasureScope.measure(measurables: List<Measurable>, constraints: Constraints): MeasureResult {
        if (measurables.isEmpty()) {
            return layout(width = constraints.minWidth, height = constraints.minHeight) {}
        }

        val titleBars = measurables.filter { it.layoutId == TITLE_BAR_LAYOUT_ID }
        if (titleBars.size > 1) {
            error("Window just can have only one title bar")
        }
        val titleBar = titleBars.firstOrNull()
        val titleBarBorder = measurables.firstOrNull { it.layoutId == TITLE_BAR_BORDER_LAYOUT_ID }

        val contentConstraints = constraints.copy(minWidth = 0, minHeight = 0)

        val titleBarPlaceable = titleBar?.measure(contentConstraints)
        val titleBarHeight = titleBarPlaceable?.height ?: 0

        val titleBarBorderPlaceable = titleBarBorder?.measure(contentConstraints)
        val titleBarBorderHeight = titleBarBorderPlaceable?.height ?: 0

        val measuredPlaceable = mutableListOf<Placeable>()

        for (it in measurables) {
            if (it.layoutId.toString().startsWith(TITLE_BAR_COMPONENT_LAYOUT_ID_PREFIX)) continue
            val offsetConstraints = contentConstraints.offset(vertical = -titleBarHeight - titleBarBorderHeight)
            val placeable = it.measure(offsetConstraints)
            measuredPlaceable += placeable
        }

        return layout(constraints.maxWidth, constraints.maxHeight) {
            titleBarPlaceable?.placeRelative(0, 0)
            titleBarBorderPlaceable?.placeRelative(0, titleBarHeight)

            measuredPlaceable.forEach { it.placeRelative(0, titleBarHeight + titleBarBorderHeight) }
        }
    }
}

@Immutable
@JvmInline
public value class DecoratedWindowState(public val state: ULong) {
    public val isActive: Boolean
        get() = state and Active != 0UL

    public val isFullscreen: Boolean
        get() = state and Fullscreen != 0UL

    public val isMinimized: Boolean
        get() = state and Minimize != 0UL

    public val isMaximized: Boolean
        get() = state and Maximize != 0UL

    public fun copy(
        fullscreen: Boolean = isFullscreen,
        minimized: Boolean = isMinimized,
        maximized: Boolean = isMaximized,
        active: Boolean = isActive,
    ): DecoratedWindowState = of(fullscreen = fullscreen, minimized = minimized, maximized = maximized, active = active)

    override fun toString(): String = "${javaClass.simpleName}(isFullscreen=$isFullscreen, isActive=$isActive)"

    public companion object {
        public val Active: ULong = 1UL shl 0
        public val Fullscreen: ULong = 1UL shl 1
        public val Minimize: ULong = 1UL shl 2
        public val Maximize: ULong = 1UL shl 3

        public fun of(
            fullscreen: Boolean = false,
            minimized: Boolean = false,
            maximized: Boolean = false,
            active: Boolean = true,
        ): DecoratedWindowState =
            DecoratedWindowState(
                (if (fullscreen) Fullscreen else 0UL) or
                    (if (minimized) Minimize else 0UL) or
                    (if (maximized) Maximize else 0UL) or
                    (if (active) Active else 0UL)
            )

        public fun of(window: ComposeWindow): DecoratedWindowState =
            of(
                fullscreen = window.placement == WindowPlacement.Fullscreen,
                minimized = window.isMinimized,
                maximized = window.placement == WindowPlacement.Maximized,
                active = window.isActive,
            )
    }
}

internal data class TitleBarInfo(val title: String, val icon: Painter?)

internal val LocalTitleBarInfo: ProvidableCompositionLocal<TitleBarInfo> = compositionLocalOf {
    error("LocalTitleBarInfo not provided, TitleBar must be used in DecoratedWindow")
}
</file>

<file path="jewel/src/jvmMain/kotlin/org/jetbrains/jewel/window/Theme.kt">
package org.jetbrains.jewel.window

import androidx.compose.runtime.Composable
import androidx.compose.runtime.ReadOnlyComposable
import org.jetbrains.jewel.foundation.theme.JewelTheme
import org.jetbrains.jewel.window.styling.DecoratedWindowStyle
import org.jetbrains.jewel.window.styling.LocalDecoratedWindowStyle
import org.jetbrains.jewel.window.styling.LocalTitleBarStyle
import org.jetbrains.jewel.window.styling.TitleBarStyle

public val JewelTheme.Companion.defaultTitleBarStyle: TitleBarStyle
    @Composable @ReadOnlyComposable get() = LocalTitleBarStyle.current

public val JewelTheme.Companion.defaultDecoratedWindowStyle: DecoratedWindowStyle
    @Composable @ReadOnlyComposable get() = LocalDecoratedWindowStyle.current
</file>

<file path="jewel/src/jvmMain/kotlin/org/jetbrains/jewel/window/TitleBar.kt">
package org.jetbrains.jewel.window

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.runtime.Composable
import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.runtime.Stable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.focus.focusProperties
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.SolidColor
import androidx.compose.ui.graphics.isUnspecified
import androidx.compose.ui.graphics.painter.Painter
import androidx.compose.ui.layout.Layout
import androidx.compose.ui.layout.Measurable
import androidx.compose.ui.layout.MeasurePolicy
import androidx.compose.ui.layout.MeasureResult
import androidx.compose.ui.layout.MeasureScope
import androidx.compose.ui.layout.Placeable
import androidx.compose.ui.layout.layoutId
import androidx.compose.ui.layout.onSizeChanged
import androidx.compose.ui.node.ModifierNodeElement
import androidx.compose.ui.node.ParentDataModifierNode
import androidx.compose.ui.platform.InspectableValue
import androidx.compose.ui.platform.InspectorInfo
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.platform.NoInspectorInfo
import androidx.compose.ui.platform.debugInspectorInfo
import androidx.compose.ui.unit.Constraints
import androidx.compose.ui.unit.Density
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.offset
import java.awt.Window
import kotlin.math.max
import org.jetbrains.jewel.foundation.theme.JewelTheme
import org.jetbrains.jewel.foundation.theme.LocalContentColor
import org.jetbrains.jewel.foundation.theme.OverrideDarkMode
import org.jetbrains.jewel.ui.component.styling.LocalDefaultDropdownStyle
import org.jetbrains.jewel.ui.component.styling.LocalIconButtonStyle
import org.jetbrains.jewel.ui.util.isDark
import org.jetbrains.jewel.window.styling.TitleBarStyle
import org.jetbrains.jewel.window.utils.DesktopPlatform
import org.jetbrains.jewel.window.utils.macos.MacUtil

internal const val TITLE_BAR_COMPONENT_LAYOUT_ID_PREFIX = "__TITLE_BAR_"

internal const val TITLE_BAR_LAYOUT_ID = "__TITLE_BAR_CONTENT__"

internal const val TITLE_BAR_BORDER_LAYOUT_ID = "__TITLE_BAR_BORDER__"

@Composable
public fun DecoratedWindowScope.TitleBar(
    modifier: Modifier = Modifier,
    gradientStartColor: Color = Color.Unspecified,
    style: TitleBarStyle = JewelTheme.defaultTitleBarStyle,
    content: @Composable TitleBarScope.(DecoratedWindowState) -> Unit,
) {
    when (DesktopPlatform.Current) {
        DesktopPlatform.Linux -> TitleBarOnLinux(modifier, gradientStartColor, style, content)
        DesktopPlatform.Windows -> TitleBarOnWindows(modifier, gradientStartColor, style, content)
        DesktopPlatform.MacOS -> TitleBarOnMacOs(modifier, gradientStartColor, style, content)
        DesktopPlatform.Unknown -> error("TitleBar is not supported on this platform(${System.getProperty("os.name")})")
    }
}

@Composable
internal fun DecoratedWindowScope.TitleBarImpl(
    modifier: Modifier = Modifier,
    gradientStartColor: Color = Color.Unspecified,
    style: TitleBarStyle = JewelTheme.defaultTitleBarStyle,
    applyTitleBar: (Dp, DecoratedWindowState) -> PaddingValues,
    backgroundContent: @Composable () -> Unit = {},
    content: @Composable TitleBarScope.(DecoratedWindowState) -> Unit,
) {
    val titleBarInfo = LocalTitleBarInfo.current

    val background by style.colors.backgroundFor(state)

    val density = LocalDensity.current

    val backgroundBrush =
        remember(background, gradientStartColor) {
            if (gradientStartColor.isUnspecified) {
                SolidColor(background)
            } else {
                with(density) {
                    Brush.horizontalGradient(
                        0.0f to background,
                        0.5f to gradientStartColor,
                        1.0f to background,
                        startX = style.metrics.gradientStartX.toPx(),
                        endX = style.metrics.gradientEndX.toPx(),
                    )
                }
            }
        }

    Box(
        modifier =
            modifier
                .background(backgroundBrush)
                .focusProperties { canFocus = false }
                .layoutId(TITLE_BAR_LAYOUT_ID)
                .height(style.metrics.height)
                .onSizeChanged { with(density) { applyTitleBar(it.height.toDp(), state) } }
                .fillMaxWidth()
    ) {
        backgroundContent()
        Layout(
            content = {
                CompositionLocalProvider(
                    LocalContentColor provides style.colors.content,
                    LocalIconButtonStyle provides style.iconButtonStyle,
                    LocalDefaultDropdownStyle provides style.dropdownStyle,
                ) {
                    OverrideDarkMode(background.isDark()) {
                        val scope = TitleBarScopeImpl(titleBarInfo.title, titleBarInfo.icon)
                        scope.content(state)
                    }
                }
            },
            modifier = modifier.fillMaxSize(),
            measurePolicy = rememberTitleBarMeasurePolicy(window, state, applyTitleBar),
        )
    }

    Spacer(Modifier.layoutId(TITLE_BAR_BORDER_LAYOUT_ID).height(1.dp).fillMaxWidth().background(style.colors.border))
}

internal class TitleBarMeasurePolicy(
    private val window: Window,
    private val state: DecoratedWindowState,
    private val applyTitleBar: (Dp, DecoratedWindowState) -> PaddingValues,
) : MeasurePolicy {
    override fun MeasureScope.measure(measurables: List<Measurable>, constraints: Constraints): MeasureResult {
        if (measurables.isEmpty()) {
            return layout(width = constraints.minWidth, height = constraints.minHeight) {}
        }

        var occupiedSpaceHorizontally = 0

        var maxSpaceVertically = constraints.minHeight
        val contentConstraints = constraints.copy(minWidth = 0, minHeight = 0)
        val measuredPlaceable = mutableListOf<Pair<Measurable, Placeable>>()

        for (it in measurables) {
            val placeable = it.measure(contentConstraints.offset(horizontal = -occupiedSpaceHorizontally))
            if (constraints.maxWidth < occupiedSpaceHorizontally + placeable.width) {
                break
            }
            occupiedSpaceHorizontally += placeable.width
            maxSpaceVertically = max(maxSpaceVertically, placeable.height)
            measuredPlaceable += it to placeable
        }

        val boxHeight = maxSpaceVertically

        val contentPadding = applyTitleBar(boxHeight.toDp(), state)

        val leftInset = contentPadding.calculateLeftPadding(layoutDirection).roundToPx()
        val rightInset = contentPadding.calculateRightPadding(layoutDirection).roundToPx()

        occupiedSpaceHorizontally += leftInset
        occupiedSpaceHorizontally += rightInset

        val boxWidth = maxOf(constraints.minWidth, occupiedSpaceHorizontally)

        return layout(boxWidth, boxHeight) {
            if (state.isFullscreen) {
                MacUtil.updateFullScreenButtons(window)
            }
            val placeableGroups =
                measuredPlaceable.groupBy { (measurable, _) ->
                    (measurable.parentData as? TitleBarChildDataNode)?.horizontalAlignment
                        ?: Alignment.CenterHorizontally
                }

            var headUsedSpace = leftInset
            var trailerUsedSpace = rightInset

            placeableGroups[Alignment.Start]?.forEach { (_, placeable) ->
                val x = headUsedSpace
                val y = Alignment.CenterVertically.align(placeable.height, boxHeight)
                placeable.placeRelative(x, y)
                headUsedSpace += placeable.width
            }
            placeableGroups[Alignment.End]?.forEach { (_, placeable) ->
                val x = boxWidth - placeable.width - trailerUsedSpace
                val y = Alignment.CenterVertically.align(placeable.height, boxHeight)
                placeable.placeRelative(x, y)
                trailerUsedSpace += placeable.width
            }

            val centerPlaceable = placeableGroups[Alignment.CenterHorizontally].orEmpty()

            val requiredCenterSpace = centerPlaceable.sumOf { it.second.width }
            val minX = headUsedSpace
            val maxX = boxWidth - trailerUsedSpace - requiredCenterSpace
            var centerX = (boxWidth - requiredCenterSpace) / 2

            if (minX <= maxX) {
                if (centerX > maxX) {
                    centerX = maxX
                }
                if (centerX < minX) {
                    centerX = minX
                }

                centerPlaceable.forEach { (_, placeable) ->
                    val x = centerX
                    val y = Alignment.CenterVertically.align(placeable.height, boxHeight)
                    placeable.placeRelative(x, y)
                    centerX += placeable.width
                }
            }
        }
    }
}

@Composable
internal fun rememberTitleBarMeasurePolicy(
    window: Window,
    state: DecoratedWindowState,
    applyTitleBar: (Dp, DecoratedWindowState) -> PaddingValues,
): MeasurePolicy = remember(window, state, applyTitleBar) { TitleBarMeasurePolicy(window, state, applyTitleBar) }

public interface TitleBarScope {
    public val title: String

    public val icon: Painter?

    @Stable public fun Modifier.align(alignment: Alignment.Horizontal): Modifier
}

private class TitleBarScopeImpl(override val title: String, override val icon: Painter?) : TitleBarScope {
    override fun Modifier.align(alignment: Alignment.Horizontal): Modifier =
        this then
            TitleBarChildDataElement(
                alignment,
                debugInspectorInfo {
                    name = "align"
                    value = alignment
                },
            )
}

private class TitleBarChildDataElement(
    val horizontalAlignment: Alignment.Horizontal,
    val inspectorInfo: InspectorInfo.() -> Unit = NoInspectorInfo,
) : ModifierNodeElement<TitleBarChildDataNode>(), InspectableValue {
    override fun create(): TitleBarChildDataNode = TitleBarChildDataNode(horizontalAlignment)

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        val otherModifier = other as? TitleBarChildDataElement ?: return false
        return horizontalAlignment == otherModifier.horizontalAlignment
    }

    override fun hashCode(): Int = horizontalAlignment.hashCode()

    override fun update(node: TitleBarChildDataNode) {
        node.horizontalAlignment = horizontalAlignment
    }

    override fun InspectorInfo.inspectableProperties() {
        inspectorInfo()
    }
}

private class TitleBarChildDataNode(var horizontalAlignment: Alignment.Horizontal) :
    ParentDataModifierNode, Modifier.Node() {
    override fun Density.modifyParentData(parentData: Any?) = this@TitleBarChildDataNode
}
</file>

<file path="jewel/src/jvmMain/kotlin/org/jetbrains/jewel/window/TitleBar.Linux.kt">
package org.jetbrains.jewel.window

import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.runtime.Composable
import androidx.compose.ui.ExperimentalComposeUiApi
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.pointer.PointerButton
import androidx.compose.ui.input.pointer.PointerEventPass
import androidx.compose.ui.input.pointer.PointerEventType
import androidx.compose.ui.input.pointer.onPointerEvent
import androidx.compose.ui.platform.LocalViewConfiguration
import androidx.compose.ui.unit.dp
import com.jetbrains.JBR
import org.jetbrains.jewel.foundation.theme.JewelTheme
import org.jetbrains.jewel.window.styling.TitleBarStyle
import org.jetbrains.jewel.window.utils.WindowControlArea
import java.awt.Frame
import java.awt.event.MouseEvent

@OptIn(ExperimentalComposeUiApi::class)
@Composable
internal fun DecoratedWindowScope.TitleBarOnLinux(
    modifier: Modifier = Modifier,
    gradientStartColor: Color = Color.Unspecified,
    style: TitleBarStyle = JewelTheme.defaultTitleBarStyle,
    content: @Composable TitleBarScope.(DecoratedWindowState) -> Unit,
) {
    var lastPress = 0L
    val viewConfig = LocalViewConfiguration.current
    TitleBarImpl(
        modifier.onPointerEvent(PointerEventType.Press, PointerEventPass.Main) {
            if (
                this.currentEvent.button == PointerButton.Primary &&
                    this.currentEvent.changes.any { changed -> !changed.isConsumed }
            ) {
                JBR.getWindowMove()?.startMovingTogetherWithMouse(window, MouseEvent.BUTTON1)
                if (
                    System.currentTimeMillis() - lastPress in
                        viewConfig.doubleTapMinTimeMillis..viewConfig.doubleTapTimeoutMillis
                ) {
                    if (state.isMaximized) {
                        window.extendedState = Frame.NORMAL
                    } else {
                        window.extendedState = Frame.MAXIMIZED_BOTH
                    }
                }
                lastPress = System.currentTimeMillis()
            }
        },
        gradientStartColor,
        style,
        { _, _ -> PaddingValues(0.dp) },
    ) { state ->
        WindowControlArea(window, state, style)
        content(state)
    }
}
</file>

<file path="jewel/src/jvmMain/kotlin/org/jetbrains/jewel/window/TitleBar.MacOS.kt">
package org.jetbrains.jewel.window

import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.node.ModifierNodeElement
import androidx.compose.ui.platform.InspectorInfo
import androidx.compose.ui.platform.debugInspectorInfo
import androidx.compose.ui.unit.dp
import com.jetbrains.JBR
import org.jetbrains.jewel.foundation.theme.JewelTheme
import org.jetbrains.jewel.window.styling.TitleBarStyle
import org.jetbrains.jewel.window.utils.macos.MacUtil

public fun Modifier.newFullscreenControls(newControls: Boolean = true): Modifier =
    this then
        NewFullscreenControlsElement(
            newControls,
            debugInspectorInfo {
                name = "newFullscreenControls"
                value = newControls
            },
        )

private class NewFullscreenControlsElement(val newControls: Boolean, val inspectorInfo: InspectorInfo.() -> Unit) :
    ModifierNodeElement<NewFullscreenControlsNode>() {
    override fun create(): NewFullscreenControlsNode = NewFullscreenControlsNode(newControls)

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        val otherModifier = other as? NewFullscreenControlsElement ?: return false
        return newControls == otherModifier.newControls
    }

    override fun hashCode(): Int = newControls.hashCode()

    override fun InspectorInfo.inspectableProperties() {
        inspectorInfo()
    }

    override fun update(node: NewFullscreenControlsNode) {
        node.newControls = newControls
    }
}

private class NewFullscreenControlsNode(var newControls: Boolean) : Modifier.Node()

@Composable
internal fun DecoratedWindowScope.TitleBarOnMacOs(
    modifier: Modifier = Modifier,
    gradientStartColor: Color = Color.Unspecified,
    style: TitleBarStyle = JewelTheme.defaultTitleBarStyle,
    content: @Composable TitleBarScope.(DecoratedWindowState) -> Unit,
) {
    val newFullscreenControls =
        modifier.foldOut(false) { e, r ->
            if (e is NewFullscreenControlsElement) {
                e.newControls
            } else {
                r
            }
        }

    if (newFullscreenControls) {
        System.setProperty("apple.awt.newFullScreenControls", true.toString())
        System.setProperty(
            "apple.awt.newFullScreenControls.background",
            "${style.colors.fullscreenControlButtonsBackground.toArgb()}",
        )
        MacUtil.updateColors(window)
    } else {
        System.clearProperty("apple.awt.newFullScreenControls")
        System.clearProperty("apple.awt.newFullScreenControls.background")
    }

    val titleBar = remember { JBR.getWindowDecorations().createCustomTitleBar() }

    TitleBarImpl(
        modifier = modifier.customTitleBarMouseEventHandler(titleBar),
        gradientStartColor = gradientStartColor,
        style = style,
        applyTitleBar = { height, state ->
            if (state.isFullscreen) {
                MacUtil.updateFullScreenButtons(window)
            }
            titleBar.height = height.value
            JBR.getWindowDecorations().setCustomTitleBar(window, titleBar)

            if (state.isFullscreen && newFullscreenControls) {
                PaddingValues(start = 80.dp)
            } else {
                PaddingValues(start = titleBar.leftInset.dp, end = titleBar.rightInset.dp)
            }
        },
        content = content,
    )
}
</file>

<file path="jewel/src/jvmMain/kotlin/org/jetbrains/jewel/window/TitleBar.Windows.kt">
package org.jetbrains.jewel.window

import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.pointer.PointerEventPass
import androidx.compose.ui.input.pointer.PointerEventType
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalLayoutDirection
import androidx.compose.ui.unit.LayoutDirection
import androidx.compose.ui.unit.dp
import com.jetbrains.JBR
import com.jetbrains.WindowDecorations.CustomTitleBar
import kotlinx.coroutines.currentCoroutineContext
import kotlinx.coroutines.isActive
import org.jetbrains.jewel.foundation.theme.JewelTheme
import org.jetbrains.jewel.ui.util.isDark
import org.jetbrains.jewel.window.styling.TitleBarStyle
import org.jetbrains.jewel.window.utils.WindowControlArea

@Composable
internal fun DecoratedWindowScope.TitleBarOnWindows(
    modifier: Modifier = Modifier,
    gradientStartColor: Color = Color.Unspecified,
    style: TitleBarStyle = JewelTheme.defaultTitleBarStyle,
    content: @Composable TitleBarScope.(DecoratedWindowState) -> Unit,
) {
    val titleBar = remember { JBR.getWindowDecorations().createCustomTitleBar() }
    val layoutDirection = LocalLayoutDirection.current
    val isRtl = layoutDirection == LayoutDirection.Rtl
    TitleBarImpl(
        modifier = modifier,
        gradientStartColor = gradientStartColor,
        style = style,
        applyTitleBar = { height, _ ->
            titleBar.height = height.value
            titleBar.putProperty("controls.dark", style.colors.background.isDark())
            if (isRtl) titleBar.putProperty("controls.visible", false)
            JBR.getWindowDecorations().setCustomTitleBar(window, titleBar)
            PaddingValues(start = titleBar.leftInset.dp, end = titleBar.rightInset.dp)
        },
        backgroundContent = { Spacer(modifier = modifier.fillMaxSize().customTitleBarMouseEventHandler(titleBar)) },
    ) { state ->
        if (isRtl) WindowControlArea(window, state, style)
        content(state)
    }
}

internal fun Modifier.customTitleBarMouseEventHandler(titleBar: CustomTitleBar): Modifier =
    pointerInput(Unit) {
        val currentContext = currentCoroutineContext()
        awaitPointerEventScope {
            var inUserControl = false
            while (currentContext.isActive) {
                val event = awaitPointerEvent(PointerEventPass.Main)
                event.changes.forEach {
                    if (!it.isConsumed && !inUserControl) {
                        titleBar.forceHitTest(false)
                    } else {
                        if (event.type == PointerEventType.Press) {
                            inUserControl = true
                        }
                        if (event.type == PointerEventType.Release) {
                            inUserControl = false
                        }
                        titleBar.forceHitTest(true)
                    }
                }
            }
        }
    }
</file>

<file path="jewel/build.gradle.kts">
import org.jetbrains.compose.ExperimentalComposeLibrary
import org.jetbrains.compose.desktop.application.dsl.TargetFormat
import org.jetbrains.compose.reload.ComposeHotRun
import org.jetbrains.kotlin.compose.compiler.gradle.ComposeFeatureFlag
import org.jetbrains.kotlin.gradle.plugin.KotlinSourceSetTree
import java.time.LocalDate
import java.time.format.DateTimeFormatter

plugins {
    alias(libs.plugins.multiplatform)
    alias(libs.plugins.compose.compiler)
    alias(libs.plugins.compose)
}


kotlin {
    jvmToolchain(21)
    jvm()

    sourceSets {
        commonMain.dependencies {
            implementation(compose.runtime)
            implementation(compose.foundation)
        }

        jvmMain.dependencies {
            implementation(libs.foundation.desktop)
            implementation(libs.jna)
            // Define the Jewel version once
            val jewelVersion = libs.versions.jewel.get()

            // Common exclusions for all Jewel libraries
            val jewelExclusions = Action<ExternalModuleDependency> {
                exclude(group = "org.jetbrains.compose.foundation", module = "foundation-desktop")
                exclude(group = "org.jetbrains.jewel", module = "jewel-decorated-window")
                exclude(group = "org.jetbrains.skiko", module = "skiko-awt")
                exclude(group = "org.jetbrains.skiko", module = "skiko-awt-runtime-all")
            }

            // Apply the exclusions to all Jewel libraries
            api("org.jetbrains.jewel:jewel-ui:$jewelVersion", jewelExclusions)
            //api("org.jetbrains.jewel:jewel-decorated-window:$jewelVersion", jewelExclusions)
            api("org.jetbrains.jewel:jewel-foundation:$jewelVersion", jewelExclusions)
            api("org.jetbrains.jewel:jewel-int-ui-standalone:$jewelVersion", jewelExclusions)
            api("org.jetbrains.jewel:jewel-int-ui-decorated-window:$jewelVersion", jewelExclusions)

        }

    }
}
</file>

<file path=".gitignore">
*.iml
.gradle
.idea
.kotlin
.DS_Store
build
*/build
captures
.externalNativeBuild
.cxx
local.properties
xcuserdata/
Pods/
*.jks
*.gpg
*yarn.lock
</file>

<file path="build.gradle.kts">
plugins {
    alias(libs.plugins.multiplatform).apply(false)
    alias(libs.plugins.compose.compiler).apply(false)
    alias(libs.plugins.compose).apply(false)
    alias(libs.plugins.android.application).apply(false)
    alias(libs.plugins.hotReload).apply(false)
    alias(libs.plugins.kotlinx.serialization).apply(false)
    alias(libs.plugins.buildConfig).apply(false)
}
</file>

<file path="gradle.properties">
#Gradle
org.gradle.jvmargs=-Xmx4G
org.gradle.caching=true
org.gradle.configuration-cache=true
org.gradle.daemon=true
org.gradle.parallel=true

#Kotlin
kotlin.code.style=official
kotlin.daemon.jvmargs=-Xmx4G
kotlin.native.binary.gc=cms
kotlin.incremental.wasm=true

#Android
android.useAndroidX=true
android.nonTransitiveRClass=true
</file>

<file path="gradlew">
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd "${APP_HOME:-./}" > /dev/null && pwd -P ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="README.MD">
# Compose Multiplatform Application

## Before running!
 - install JDK 17 or higher on your machine  
 - add `local.properties` file to the project root and set a path to Android SDK there  

### Android
To run the application on android device/emulator:  
 - open project in Android Studio and run imported android run configuration  

To build the application bundle:  
 - run `./gradlew :composeApp:assembleDebug`  
 - find `.apk` file in `composeApp/build/outputs/apk/debug/composeApp-debug.apk`  

Run android UI tests on the connected device: `./gradlew :composeApp:connectedDebugAndroidTest`

### Desktop
Run the desktop application: `./gradlew :composeApp:run`  
Run the desktop **hot reload** application: `./gradlew :composeApp:jvmRunHot`  
Run desktop UI tests: `./gradlew :composeApp:jvmTest`
</file>

<file path="settings.gradle.kts">
rootProject.name = "SeforimApp"

pluginManagement {
    repositories {
        google {
            content { 
              	includeGroupByRegex("com\\.android.*")
              	includeGroupByRegex("com\\.google.*")
              	includeGroupByRegex("androidx.*")
              	includeGroupByRegex("android.*")
            }
        }
        gradlePluginPortal()
        mavenCentral()
    }
}

dependencyResolutionManagement {
    repositories {
        google {
            content { 
              	includeGroupByRegex("com\\.android.*")
              	includeGroupByRegex("com\\.google.*")
              	includeGroupByRegex("androidx.*")
              	includeGroupByRegex("android.*")
            }
        }
        mavenCentral()
        maven("https://jitpack.io")
        maven("https://packages.jetbrains.team/maven/p/kpm/public/")
        maven("https://packages.jetbrains.team/maven/p/ij/intellij-dependencies/")
        maven("https://www.jetbrains.com/intellij-repository/releases")
        maven("https://www.jetbrains.com/intellij-repository/snapshots")
    }
}
plugins {
    //https://github.com/JetBrains/compose-hot-reload?tab=readme-ov-file#set-up-automatic-provisioning-of-the-jetbrains-runtime-jbr-via-gradle
    id("org.gradle.toolchains.foojay-resolver-convention").version("0.10.0")
}

include(":composeApp")
include(":jewel")
includeBuild("lib")
</file>

</files>
