package io.github.kdroidfilter.seforimapp.cataloggen

import app.cash.sqldelight.driver.jdbc.sqlite.JdbcSqliteDriver
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import io.github.kdroidfilter.seforimlibrary.dao.repository.SeforimRepository
import kotlinx.coroutines.runBlocking
import java.io.File

/**
 * Code generator that reads the SQLite DB and emits a Kotlin object with
 * precomputed titles and mappings used by the app UI.
 *
 * Usage (via Gradle task):
 *   ./gradlew :cataloggen:generatePrecomputedCatalog
 */
fun main(args: Array<String>) {
    require(args.size >= 2) { "Expected arguments: <dbPath> <outputDir>" }
    val dbPath = args[0]
    val outputDir = File(args[1])

    val driver = JdbcSqliteDriver("jdbc:sqlite:$dbPath")
    val repo = SeforimRepository(dbPath, driver)

    // Only include categories used in the current UI
    val categoriesOfInterest = setOf<Long>(
        2, 3, 4, // Tanakh
        5, 6, 7, 8, 9, 10, 11, // Mishnah root + orders
        12, 13, 14, 15, 16, 17, 18, // Bavli root + orders
        19, 20, 21, 22, 23, 24, // Yerushalmi root + orders
        59, // Tur
        60  // Shulchan Aruch
    )
    val categoryTitles: MutableMap<Long, String> = mutableMapOf()
    runBlocking {
        categoriesOfInterest.forEach { cid ->
            runCatching { repo.getCategory(cid) }.getOrNull()?.let { categoryTitles[cid] = it.title }
        }
    }

    // Collect books per category and book titles (strip display titles by category label)
    val bookTitles: MutableMap<Long, String> = mutableMapOf()
    val categoryBooks: MutableMap<Long, List<Pair<Long, String>>> = mutableMapOf()
    runBlocking {
        categoryTitles.keys.forEach { cid ->
            val books = runCatching { repo.getBooksByCategory(cid) }.getOrDefault(emptyList())
            // Prefer stripping both the current category label and the root label,
            // to support cases like "שולחן ערוך, ..." and "תלמוד ירושלמי ...".
            val categoryLabel = categoryTitles[cid]
            val rootLabel = rootCategoryTitle(repo, cid)
            val labels = listOfNotNull(categoryLabel, rootLabel).distinct()
            val refs = books.map { b ->
                bookTitles[b.id] = b.title
                val display = stripAnyLabelPrefix(labels, b.title)
                b.id to display
            }
            categoryBooks[cid] = refs
        }
    }

    // Collect per-book TOC-textId → (label, tocEntryId, firstLineId) for books we use in UI
    val tocByTocTextId: MutableMap<Long, Map<Long, Triple<String, Long, Long?>>> = mutableMapOf()
    val booksOfInterest = setOf<Long>(410) // Tur
    val tocTextIdsOfInterest = setOf<Long>(3455, 4098, 4099, 4100) // OC, YD, EH, CM
    runBlocking {
        booksOfInterest.forEach { bookId ->
            val toc = runCatching { repo.getBookToc(bookId) }.getOrDefault(emptyList())
            val mappings = runCatching { repo.getLineTocMappingsForBook(bookId) }.getOrDefault(emptyList())
            val firstLineByToc: MutableMap<Long, Long> = mutableMapOf()
            mappings.forEach { m -> if (!firstLineByToc.containsKey(m.tocEntryId)) firstLineByToc[m.tocEntryId] = m.lineId }
            val map = mutableMapOf<Long, Triple<String, Long, Long?>>()
            for (e in toc) {
                val txId = e.textId ?: continue
                if (!tocTextIdsOfInterest.contains(txId)) continue
                val label = e.text
                if (label.isBlank()) continue
                map[txId] = Triple(label, e.id, firstLineByToc[e.id])
            }
            if (map.isNotEmpty()) tocByTocTextId[bookId] = map
        }
    }

    // Emit Kotlin file
    val pkg = "io.github.kdroidfilter.seforimapp.catalog"
    val fileSpecBuilder = FileSpec.builder(pkg, "PrecomputedCatalog")
        .addFileComment(
            """
            DO NOT EDIT.
            This file is auto-generated by the catalog generator.
            To regenerate: ./gradlew :cataloggen:generatePrecomputedCatalog
            Manual changes will be lost.
            """.trimIndent()
        )
    // Top-level helper types
    val bookRef = TypeSpec.classBuilder("BookRef")
        .addModifiers(KModifier.DATA)
        .primaryConstructor(FunSpec.constructorBuilder()
            .addParameter("id", LONG)
            .addParameter("title", STRING)
            .build())
        .addProperty(PropertySpec.builder("id", LONG).initializer("id").build())
        .addProperty(PropertySpec.builder("title", STRING).initializer("title").build())
        .build()
    val tocQL = TypeSpec.classBuilder("TocQuickLink")
        .addModifiers(KModifier.DATA)
        .primaryConstructor(FunSpec.constructorBuilder()
            .addParameter("label", STRING)
            .addParameter("tocEntryId", LONG)
            .addParameter("firstLineId", LONG.copy(nullable = true))
            .build())
        .addProperty(PropertySpec.builder("label", STRING).initializer("label").build())
        .addProperty(PropertySpec.builder("tocEntryId", LONG).initializer("tocEntryId").build())
        .addProperty(PropertySpec.builder("firstLineId", LONG.copy(nullable = true)).initializer("firstLineId").build())
        .build()
    // Polymorphic dropdown descriptors
    val dropdownSpec = TypeSpec.interfaceBuilder("DropdownSpec")
        .addModifiers(KModifier.SEALED)
        .build()
    val categorySpec = TypeSpec.classBuilder("CategoryDropdownSpec")
        .addModifiers(KModifier.DATA)
        .addSuperinterface(ClassName(pkg, "DropdownSpec"))
        .primaryConstructor(FunSpec.constructorBuilder()
            .addParameter("categoryId", LONG)
            .build())
        .addProperty(PropertySpec.builder("categoryId", LONG).initializer("categoryId").build())
        .build()
    val multiCategorySpec = TypeSpec.classBuilder("MultiCategoryDropdownSpec")
        .addModifiers(KModifier.DATA)
        .addSuperinterface(ClassName(pkg, "DropdownSpec"))
        .primaryConstructor(FunSpec.constructorBuilder()
            .addParameter("labelCategoryId", LONG)
            .addParameter("bookCategoryIds", LIST.parameterizedBy(LONG))
            .build())
        .addProperty(PropertySpec.builder("labelCategoryId", LONG).initializer("labelCategoryId").build())
        .addProperty(PropertySpec.builder("bookCategoryIds", LIST.parameterizedBy(LONG)).initializer("bookCategoryIds").build())
        .build()
    val tocQuickLinksSpec = TypeSpec.classBuilder("TocQuickLinksSpec")
        .addModifiers(KModifier.DATA)
        .addSuperinterface(ClassName(pkg, "DropdownSpec"))
        .primaryConstructor(FunSpec.constructorBuilder()
            .addParameter("bookId", LONG)
            .addParameter("tocTextIds", LIST.parameterizedBy(LONG))
            .build())
        .addProperty(PropertySpec.builder("bookId", LONG).initializer("bookId").build())
        .addProperty(PropertySpec.builder("tocTextIds", LIST.parameterizedBy(LONG)).initializer("tocTextIds").build())
        .build()
    fileSpecBuilder
        .addType(bookRef)
        .addType(tocQL)
        .addType(dropdownSpec)
        .addType(categorySpec)
        .addType(multiCategorySpec)
        .addType(tocQuickLinksSpec)

    val catalogObject = buildCatalogType(pkg, bookTitles, categoryTitles, categoryBooks, tocByTocTextId)
    val fileSpec = fileSpecBuilder.addType(catalogObject)
        .build()

    outputDir.mkdirs()
    fileSpec.writeTo(outputDir)
}

private fun collectCategoryTitles(repo: SeforimRepository, parentId: Long, out: MutableMap<Long, String>) {
    runBlocking {
        val children = runCatching { repo.getCategoryChildren(parentId) }.getOrDefault(emptyList())
        children.forEach { c ->
            out[c.id] = c.title
            collectCategoryTitles(repo, c.id, out)
        }
    }
}

private fun rootCategoryTitle(repo: SeforimRepository, categoryId: Long): String = runBlocking {
    var cur = runCatching { repo.getCategory(categoryId) }.getOrNull()
    var lastTitle: String? = cur?.title
    var guard = 0
    while (cur?.parentId != null && guard++ < 50) {
        cur = runCatching { repo.getCategory(cur.parentId!!) }.getOrNull()
        if (cur?.title != null) lastTitle = cur.title
    }
    lastTitle ?: ""
}

private fun buildCatalogType(
    pkg: String,
    bookTitles: Map<Long, String>,
    categoryTitles: Map<Long, String>,
    categoryBooks: Map<Long, List<Pair<Long, String>>>,
    tocByTocTextId: Map<Long, Map<Long, Triple<String, Long, Long?>>>
): TypeSpec {
    val builder = TypeSpec.objectBuilder("PrecomputedCatalog")

    // BOOK_TITLES
    val btCode = CodeBlock.builder().add("mapOf(\n")
    bookTitles.entries.sortedBy { it.key }.forEach { (id, title) ->
        btCode.add("  %LL to %S,\n", id, title)
    }
    btCode.add(")")
    builder.addProperty(PropertySpec.builder("BOOK_TITLES", MAP.parameterizedBy(LONG, STRING))
        .initializer(btCode.build()).build())

    // CATEGORY_TITLES
    val ctCode = CodeBlock.builder().add("mapOf(\n")
    categoryTitles.entries.sortedBy { it.key }.forEach { (id, title) ->
        ctCode.add("  %LL to %S,\n", id, title)
    }
    ctCode.add(")")
    builder.addProperty(PropertySpec.builder("CATEGORY_TITLES", MAP.parameterizedBy(LONG, STRING))
        .initializer(ctCode.build()).build())

    // CATEGORY_BOOKS
    val bookRefType = ClassName(pkg, "BookRef")
    val listBookRef = LIST.parameterizedBy(bookRefType)
    val mapCatBooks = MAP.parameterizedBy(LONG, listBookRef)
    val cbCode = CodeBlock.builder().add("mapOf(\n")
    categoryBooks.entries.sortedBy { it.key }.forEach { (cid, refs) ->
        cbCode.add("  %LL to listOf(", cid)
        refs.forEachIndexed { idx, (bid, btitle) ->
            if (idx > 0) cbCode.add(", ")
            cbCode.add("BookRef(%LL, %S)", bid, btitle)
        }
        cbCode.add(") ,\n")
    }
    cbCode.add(")")
    builder.addProperty(PropertySpec.builder("CATEGORY_BOOKS", mapCatBooks)
        .initializer(cbCode.build()).build())

    // TOC_BY_TOC_TEXT_ID
    val tocQLType = ClassName(pkg, "TocQuickLink")
    val innerMap = MAP.parameterizedBy(LONG, tocQLType)
    val tocMapType = MAP.parameterizedBy(LONG, innerMap)
    val tocCode = CodeBlock.builder().add("mapOf(\n")
    tocByTocTextId.entries.sortedBy { it.key }.forEach { (bookId, inner) ->
        tocCode.add("  %LL to mapOf(", bookId)
        inner.entries.forEachIndexed { idx, (tx, triple) ->
            if (idx > 0) tocCode.add(", ")
            val (label, tocEntryId, firstLineId) = triple
            tocCode.add("%LL to TocQuickLink(%S, %LL, %L)", tx, label, tocEntryId, firstLineId)
        }
        tocCode.add(") ,\n")
    }
    tocCode.add(")")
    builder.addProperty(PropertySpec.builder("TOC_BY_TOC_TEXT_ID", tocMapType)
        .initializer(tocCode.build()).build())

    // Ids: pretty-named constants for UI code (avoid magic numbers)
    val idsObj = TypeSpec.objectBuilder("Ids")

    // Categories
    val categoriesPretty = linkedMapOf(
        2L to "TORAH",
        3L to "NEVIIM",
        4L to "KETUVIM",
        5L to "MISHNA",
        6L to "MISHNA_ZERAIM",
        7L to "MISHNA_MOED",
        8L to "MISHNA_NASHIM",
        9L to "MISHNA_NEZIKIN",
        10L to "MISHNA_KODASHIM",
        11L to "MISHNA_TAHAROT",
        12L to "BAVLI",
        13L to "BAVLI_ZERAIM",
        14L to "BAVLI_MOED",
        15L to "BAVLI_NASHIM",
        16L to "BAVLI_NEZIKIN",
        17L to "BAVLI_KODASHIM",
        18L to "BAVLI_TAHAROT",
        19L to "YERUSHALMI",
        20L to "YERUSHALMI_ZERAIM",
        21L to "YERUSHALMI_MOED",
        22L to "YERUSHALMI_NASHIM",
        23L to "YERUSHALMI_NEZIKIN",
        24L to "YERUSHALMI_TAHAROT",
        59L to "TUR",
        60L to "SHULCHAN_ARUCH",
    )
    val catObj = TypeSpec.objectBuilder("Categories")
    categoriesPretty.forEach { (id, name) ->
        val he = categoryTitles[id] ?: ""
        catObj.addProperty(
            PropertySpec.builder(name, LONG)
                .addModifiers(KModifier.CONST)
                .initializer("%LL", id)
                .addKdoc("%L", he)
                .build()
        )
    }
    idsObj.addType(catObj.build())

    // Books (featured ones referenced in UI)
    val booksPretty = linkedMapOf(
        410L to "TUR", // טור
    )
    val bookObj = TypeSpec.objectBuilder("Books")
    booksPretty.forEach { (id, name) ->
        val he = bookTitles[id] ?: ""
        bookObj.addProperty(
            PropertySpec.builder(name, LONG)
                .addModifiers(KModifier.CONST)
                .initializer("%LL", id)
                .addKdoc("%L", he)
                .build()
        )
    }
    idsObj.addType(bookObj.build())

    // TocTexts (featured quick-jump entries)
    val tocTextPretty = linkedMapOf(
        3455L to "ORACH_CHAIM",
        4098L to "YOREH_DEAH",
        4099L to "EVEN_HAEZER",
        4100L to "CHOSHEN_MISHPAT",
    )
    val heByTocId: Map<Long, String> = tocByTocTextId.values
        .flatMap { it.entries }
        .associate { (tx, triple) -> tx to triple.first }
    val tocObj = TypeSpec.objectBuilder("TocTexts")
    tocTextPretty.forEach { (id, name) ->
        val he = heByTocId[id] ?: ""
        tocObj.addProperty(
            PropertySpec.builder(name, LONG)
                .addModifiers(KModifier.CONST)
                .initializer("%LL", id)
                .addKdoc("%L", he)
                .build()
        )
    }
    idsObj.addType(tocObj.build())

    builder.addType(idsObj.build())

    // Dropdown presets for HomeView (polymorphic descriptors)
    val dropdownsObj = TypeSpec.objectBuilder("Dropdowns")
    val dropdownSpecClass = ClassName(pkg, "DropdownSpec")
    val listOfDropdownSpec = LIST.parameterizedBy(dropdownSpecClass)
    val homeDropdowns = CodeBlock.builder().add("listOf(\n")
        // 3 single categories
        .add("  CategoryDropdownSpec(%LL),\n", 2L)
        .add("  CategoryDropdownSpec(%LL),\n", 3L)
        .add("  CategoryDropdownSpec(%LL),\n", 4L)
        // Mishna
        .add("  MultiCategoryDropdownSpec(%LL, listOf(%LL, %LL, %LL, %LL, %LL, %LL)),\n",
            5L, 6L, 7L, 8L, 9L, 10L, 11L)
        // Bavli
        .add("  MultiCategoryDropdownSpec(%LL, listOf(%LL, %LL, %LL, %LL, %LL, %LL)),\n",
            12L, 13L, 14L, 15L, 16L, 17L, 18L)
        // Yerushalmi
        .add("  MultiCategoryDropdownSpec(%LL, listOf(%LL, %LL, %LL, %LL, %LL)),\n",
            19L, 20L, 21L, 22L, 23L, 24L)
        // Shulchan Aruch
        .add("  CategoryDropdownSpec(%LL),\n", 60L)
        // Tur quick links
        .add("  TocQuickLinksSpec(%LL, listOf(%LL, %LL, %LL, %LL)),\n",
            410L, 3455L, 4098L, 4099L, 4100L)
        .add(")")
        .build()
    dropdownsObj.addProperty(
        PropertySpec.builder("HOME", listOfDropdownSpec)
            .initializer(homeDropdowns)
            .build()
    )
    // Named specs for easy use in UI
    dropdownsObj.addProperty(
        PropertySpec.builder("TORAH", dropdownSpecClass)
            .initializer("CategoryDropdownSpec(%LL)", 2L)
            .build()
    )
    dropdownsObj.addProperty(
        PropertySpec.builder("NEVIIM", dropdownSpecClass)
            .initializer("CategoryDropdownSpec(%LL)", 3L)
            .build()
    )
    dropdownsObj.addProperty(
        PropertySpec.builder("KETUVIM", dropdownSpecClass)
            .initializer("CategoryDropdownSpec(%LL)", 4L)
            .build()
    )
    dropdownsObj.addProperty(
        PropertySpec.builder("MISHNA", dropdownSpecClass)
            .initializer("MultiCategoryDropdownSpec(%LL, listOf(%LL, %LL, %LL, %LL, %LL, %LL))",
                5L, 6L, 7L, 8L, 9L, 10L, 11L)
            .build()
    )
    dropdownsObj.addProperty(
        PropertySpec.builder("BAVLI", dropdownSpecClass)
            .initializer("MultiCategoryDropdownSpec(%LL, listOf(%LL, %LL, %LL, %LL, %LL, %LL))",
                12L, 13L, 14L, 15L, 16L, 17L, 18L)
            .build()
    )
    dropdownsObj.addProperty(
        PropertySpec.builder("YERUSHALMI", dropdownSpecClass)
            .initializer("MultiCategoryDropdownSpec(%LL, listOf(%LL, %LL, %LL, %LL, %LL))",
                19L, 20L, 21L, 22L, 23L, 24L)
            .build()
    )
    dropdownsObj.addProperty(
        PropertySpec.builder("SHULCHAN_ARUCH", dropdownSpecClass)
            .initializer("CategoryDropdownSpec(%LL)", 60L)
            .build()
    )
    dropdownsObj.addProperty(
        PropertySpec.builder("TUR_QUICK_LINKS", dropdownSpecClass)
            .initializer("TocQuickLinksSpec(%LL, listOf(%LL, %LL, %LL, %LL))",
                410L, 3455L, 4098L, 4099L, 4100L)
            .build()
    )
    builder.addType(dropdownsObj.build())

    return builder.build()
}

private val STRING = String::class.asClassName()
private val LONG = Long::class.asClassName()
private val LIST = ClassName("kotlin.collections", "List")
private val MAP = ClassName("kotlin.collections", "Map")

private fun stripLabelPrefix(label: String, title: String): String {
    if (label.isBlank()) return title
    val prefix = Regex.escape(label)
    val patterns = listOf(
        Regex("^$prefix\\s*,\\s*"),  // label + comma
        Regex("^$prefix,\\s*"),       // label,comma
        Regex("^$prefix\\s*[:–—-]\\s*"), // label + colon/en/em dash/hyphen
        Regex("^$prefix\\s*\\+\\s*"), // label + plus
        Regex("^$prefix\\s+")         // label + space
    )
    for (p in patterns) {
        val replaced = title.replaceFirst(p, "")
        if (replaced !== title) return replaced.trimStart()
    }
    return title
}

private fun stripAnyLabelPrefix(labels: List<String>, title: String): String {
    var result = title
    for (lbl in labels) {
        result = stripLabelPrefix(lbl, result)
    }
    return result
}

private inline fun <K, V, R> Iterable<Map.Entry<K, V>>.associateNotNull(transform: (Map.Entry<K, V>) -> R?): Map<K, R> {
    val dest = LinkedHashMap<K, R>()
    for (e in this) {
        val v = transform(e) ?: continue
        dest[e.key] = v
    }
    return dest
}
